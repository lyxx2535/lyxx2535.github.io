<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Annie">





<title>力扣刷题（hot100、代码随想录等） | Annie&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Annie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Annie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">力扣刷题（hot100、代码随想录等）</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Annie</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">April 2, 2025&nbsp;&nbsp;22:58:59</a>
                        </span>
                    
                    
                        <span class="post-category">
                        分类:
                            
                                <a href="/categories/%E8%BD%AF%E4%BB%B6/">软件</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>已完成：</p>
<ul>
<li>hot100 python版本三刷（<a target="_blank" rel="noopener" href="https://leetcode.cn/studyplan/top-100-liked/%E5%92%8Chttps://leetcode.cn/problem-list/2cktkvj/%EF%BC%89">https://leetcode.cn/studyplan/top-100-liked/和https://leetcode.cn/problem-list/2cktkvj/）</a></li>
<li>代码随想录到图论和额外题目，4.2节之前使用Java和Python3刷题，之后使用Python3</li>
</ul>
<p>TODO:</p>
<ol>
<li>代码随想录剩下的（相关题目推荐我没做，有缘再巩固）</li>
<li>labuladong</li>
<li>hot150</li>
<li>剑指offer</li>
<li>力扣75</li>
</ol>
<h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-数组理论基础"><a href="#1-1-数组理论基础" class="headerlink" title="1.1 数组理论基础"></a>1.1 数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<p>因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要<strong>移动</strong>其他元素的地址。</p>
<ul>
<li><code>vector</code>的底层实现是<code>array</code><ul>
<li>在 C++ 中，<code>vector</code>是一种动态数组，它的底层是基于普通数组（<code>array</code>）来实现的。这意味着<code>vector</code>在内存中是以连续的存储单元来存放元素的，就像普通数组一样。这种底层实现方式使得<code>vector</code>能够像数组一样快速地随机访问元素，即可以通过索引快速获取到任意位置的元素。</li>
</ul>
</li>
<li><code>vector</code>是容器，不是数组<ul>
<li><strong>容器的概念</strong>：<code>vector</code>是 C++ 标准模板库（STL）中的一种容器类。容器是一种能够存储和管理其他对象的对象，它提供了一系列的成员函数和操作符，用于方便地对存储的元素进行各种操作，如插入、删除、遍历等。<code>vector</code>作为容器，具有很多方便的功能和特性，比如它可以自动管理内存，根据元素的添加和删除自动调整自身的大小。</li>
<li><strong>与数组的区别</strong>：虽然<code>vector</code>在底层利用了数组的存储方式，但它和普通的 C 风格数组有很多不同之处。普通数组的大小是固定的，在定义时就需要指定其大小，而且在程序运行期间大小不能改变。而<code>vector</code>的大小是可以动态变化的，可以在运行时根据需要添加或删除元素，它会自动分配和释放内存来适应元素数量的变化。</li>
</ul>
</li>
</ul>
<p>在C++中二维数组是连续分布的，对于int型数组，两个相邻数组元素地址差4个字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//0x7ffee4065820 0x7ffee4065824 0x7ffee4065828</span></span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//0x7ffee406582c 0x7ffee4065830 0x7ffee4065834</span></span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_arr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机，所以看不到每个元素的地址情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_arr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//[I@7852e922 [I@4e25154f [I@70dea4e [I@5c647e05</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arr[0]</code> 实际上是一个一维数组对象的引用</li>
<li>输出一个类似 <code>[I@hashcode</code> 的字符串，其中 <code>[I</code> 表示这是一个一维整数数组，<code>@hashcode</code> 是该数组对象在内存中的哈希码，它可以在一定程度上被认为是该数组对象的地址码（但不是真正的物理地址，而是处理过后的数值）</li>
<li>行指针数组在内存中是连续存储的，而每个行所指向的一维数组（即二维数组的每一行）在内存中的存储位置是不连续的<ul>
<li>这样可以使每行的长度不同，实现不规则的二维数组</li>
</ul>
</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329398.png" alt="算法通关数组3" style="zoom: 25%;" />

<h2 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>二分法的前提条件：有序数组+无重复元素</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)<ul>
<li>这是因为search只使用left、right、middle，在执行过程中额外占用的空间是固定的，与输入数据的规模n无关</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//先在开头判断下可以提升效率，避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//注意可以写成并排，int left = 0, right = nums.length - 1;</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;<span class="comment">//当left和right都很大时可能会溢出，</span></span><br><span class="line">            <span class="comment">// int mid = left + ((right - left) &gt;&gt; 1);写成位运算可以提升效率，改为减法的形式也可以避免溢出。注意要写括号，不然+的优先级大于&gt;&gt;有符号右移</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] == target)&#123; <span class="comment">//看target是否在[left, right]区间内</span></span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:<span class="comment">#-&gt; int是返回值类型提示，List[int]是参数类型提示，self 会自动指向调用该方法的对象</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; target <span class="keyword">or</span> nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>] &lt; target: <span class="comment">#注意逻辑或</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-移除元素"><a href="#1-3-移除元素" class="headerlink" title="1.3 移除元素"></a>1.3 移除元素</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。不需要考虑数组中超出新长度后面的元素。</p>
<p>可以使用暴力解法，发现需要移除的元素，就将数组集体向前移动一位</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针：时间复杂度：O(n)、空间复杂度：O(1)。并不改变元素的相对位置。</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新新数组下标的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//fast指向新数组的元素，slow表示新数组的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        fast, slow = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):<span class="comment">#fast会遍历现有数组的每一个值，等于val的被覆盖</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h4 id="相向双指针法"><a href="#相向双指针法" class="headerlink" title="相向双指针法"></a>相向双指针法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br></pre></td></tr></table></figure>

<p>题目描述中的示例告诉我们不一定要按照顺序得到新数组，所以可以另一个指针从后往前</p>
<p>可以让右指针不断地指向不为val的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;<span class="comment">//fast指向新数组的元素，slow表示新数组的下标</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == val)&#123;</span><br><span class="line">            right--;<span class="comment">//先把右指针移到第一个不是val的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; left &lt;= right; left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == val)&#123;</span><br><span class="line">                    right--;<span class="comment">//先把右指针移到第一个不是val的值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以不判断右指针是否为val，先用右侧覆盖左侧再说，后面再检查左指针（最简洁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;<span class="comment">//fast指向新数组的元素，slow表示新数组的下标</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;<span class="comment">//不管right指向的是不是val，先覆盖，反正马上left又会检查</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[left] == val:</span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h2 id="1-4-有序数组的平方"><a href="#1-4-有序数组的平方" class="headerlink" title="1.4 有序数组的平方"></a>1.4 有序数组的平方</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p>暴力法： O(n + nlogn)</p>
<p>双指针法：两侧的数字绝对值大，所以平方也大，所以可以用两侧到中间，不断比较大小。O(n)</p>
<ul>
<li>注意这道题得创建个新数组，如果在原数组上改的话两个指针不够<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329400.png" alt="image-20250122204856186"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] * nums[left] &gt;= nums[right] * nums[right])&#123;</span><br><span class="line">                result[i--] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[i--] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(nums[l]) &gt;= <span class="built_in">abs</span>(nums[r]):</span><br><span class="line">                res.append(nums[l] ** <span class="number">2</span>)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(nums[r] ** <span class="number">2</span>)</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="1-5-长度最小的子数组"><a href="#1-5-长度最小的子数组" class="headerlink" title="1.5 长度最小的子数组"></a>1.5 长度最小的子数组</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><p>找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度</p>
<p>暴力法：两层循环，看每个起点连续多少能超过s，比较哪个最短</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>滑动窗口</strong>：不断调节子序列的起始位置和终止位置，从而得出我们要想的结果</p>
<p>只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。（不然还要一个循环表示起始位置：暴力）</p>
<p>滑动窗口也可以理解为双指针法的一种：主要确定如下三点：</p>
<ul>
<li>窗口内是什么？就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li>
<li>如何移动窗口的起始位置？如果当前窗口的值大于等于s了，窗口就要向前移动了。（此时已获得一个子序列）</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p><strong>精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置</strong></p>
<ul>
<li>时间复杂度：O(n)：因为每个元素在滑动窗后进来操作一次，出去操作一次，其实是O(2n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前子序列的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录序列的左指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++)&#123;<span class="comment">//记录序列的右指针</span></span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;<span class="comment">//因为每次移动i都会产生新的子序列，所以每次都要检查</span></span><br><span class="line">                res = Math.min(j - i + <span class="number">1</span> , res);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE? <span class="number">0</span> : res;<span class="comment">//Java才有的条件表达式，python没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, <span class="built_in">sum</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span> += nums[r]</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">sum</span> &gt;= target:</span><br><span class="line">                res = <span class="built_in">min</span>(res, r - l + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">sum</span> -= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-螺旋矩阵II"><a href="#1-6-螺旋矩阵II" class="headerlink" title="1.6 螺旋矩阵II"></a>1.6 螺旋矩阵II</h2><h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><p><strong>模拟行为</strong>：如何坚持循环不变量？确定1-4每次循环的数目为n-loop，然后用左闭右开的区间约束</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img" style="zoom:33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//没必要专门记录起始点，因为每轮循环的起始点就是(loop - 1, loop - 1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop &lt;= n / <span class="number">2</span>)&#123;<span class="comment">//采用左闭右开的写法，每次只循环n-loop个数字 注意n/2是整数</span></span><br><span class="line">            <span class="keyword">for</span>(; j &lt; n - loop; j++)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &lt; n - loop; i++)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt; loop - <span class="number">1</span>; j--)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt; loop - <span class="number">1</span>; i--)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            nums[i][j] = count;<span class="comment">//最后存中间的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment">#这里是创建n*n的数组，其中_表示占位符，因为不需要知道此时循环到第几层，无需写for i in range(n)</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        loop = <span class="number">1</span> </span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> loop &lt;= n // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">while</span> j &lt; n - loop:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n - loop:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; loop - <span class="number">1</span>:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt; loop - <span class="number">1</span>:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[i][j] = count</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="1-7-区间和"><a href="#1-7-区间和" class="headerlink" title="1.7 区间和"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1070">1.7 区间和</a></h2><p>输出每个指定区间内元素的总和。</p>
<p>前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240627110604.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Scanner 对象，用于从标准输入读取数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//跳过前面的空白字符（包括空格、制表符、换行符等），直到找到一个有效的整数输入</span></span><br><span class="line">        <span class="type">int</span>[] vec = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//存储数组</span></span><br><span class="line">        <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//存储前缀和</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            vec[i] = scanner.nextInt();</span><br><span class="line">            presum += vec[i];</span><br><span class="line">            p[i] = presum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;<span class="comment">//判断是否还有输入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">0</span>)&#123;<span class="comment">//注意这里防止下标越界</span></span><br><span class="line">                res = p[b];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = p[b] - p[a - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 Scanner 对象，释放资源</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.read</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = <span class="built_in">input</span>() <span class="comment">#输入为&#x27;5\n1\n2\n3\n4\n5\n0 1\n1 3&#x27; 可以打印了解格式</span></span><br><span class="line">    data = data.split()<span class="comment">#[&#x27;5&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;3&#x27;]</span></span><br><span class="line">    index = <span class="number">0</span> <span class="comment">#表示当前遍历到的data下标</span></span><br><span class="line">    n = <span class="built_in">int</span>(data[index])</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    vec = []</span><br><span class="line">    p = []</span><br><span class="line">    presum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        num = <span class="built_in">int</span>(data[index])</span><br><span class="line">        presum += num</span><br><span class="line">        vec.append(num)</span><br><span class="line">        p.append(presum)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(data):</span><br><span class="line">        a, b = <span class="built_in">int</span>(data[index]), <span class="built_in">int</span>(data[index + <span class="number">1</span>])</span><br><span class="line">        index += <span class="number">2</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">            res = p[b]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = p[b] - p[a - <span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="1-8-开发商购买土地"><a href="#1-8-开发商购买土地" class="headerlink" title="1.8 开发商购买土地"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1044">1.8 开发商购买土地</a></h2><p>注意只能按行分或按列分：二维前缀和枚举按行分和按列分的所有情况，然后取最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">// 前缀和,row[i]表示前i行（包括第i行）的数据之和</span></span><br><span class="line">        <span class="type">int</span>[] col = <span class="keyword">new</span> <span class="title class_">int</span>[m];<span class="comment">// 前缀和,col[i]表示前i列（包括第i列）的数据之和</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                array[i][j] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求row[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rowSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                rowSum += array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            row[i] = rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求col[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">colSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                colSum += array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            col[j] = colSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowResult</span> <span class="operator">=</span> Main.result(row);<span class="comment">//按行分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">colResult</span> <span class="operator">=</span> Main.result(col);<span class="comment">//按列分</span></span><br><span class="line">        System.out.println(Math.min(rowResult, colResult));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">result</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;<span class="comment">//求该前缀和划分如何最小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> array[array.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;<span class="comment">//注意total不用于划分，所以要-1</span></span><br><span class="line">            res = Math.min(res, Math.abs(total - <span class="number">2</span> * array[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.read</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">arr</span>):<span class="comment">#这里没有class，所以不用写self</span></span><br><span class="line">    total = arr[<span class="built_in">len</span>(arr) - <span class="number">1</span>]</span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(total - <span class="number">2</span> * arr[i]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = <span class="built_in">input</span>().split()</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    n, m = <span class="built_in">int</span>(data[index]), <span class="built_in">int</span>(data[index + <span class="number">1</span>])</span><br><span class="line">    index += <span class="number">2</span></span><br><span class="line">    array = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    row = [<span class="number">0</span>] * n</span><br><span class="line">    col = [<span class="number">0</span>] * m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            array[i][j] = <span class="built_in">int</span>(data[index])</span><br><span class="line">            index += <span class="number">1</span><span class="comment">#注意这里别忘了写</span></span><br><span class="line">            </span><br><span class="line">    rowsum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            rowsum += array[i][j]</span><br><span class="line">        row[i] = rowsum</span><br><span class="line">        </span><br><span class="line">    colsum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            colsum += array[i][j]</span><br><span class="line">        col[j] = colsum</span><br><span class="line"></span><br><span class="line">    rowresult = result(row)</span><br><span class="line">    colresult = result(col)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">min</span>(rowresult, colresult))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="1-9-总结篇"><a href="#1-9-总结篇" class="headerlink" title="1.9 总结篇"></a>1.9 总结篇</h2><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"></p>
<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><h2 id="2-1-链表理论基础"><a href="#2-1-链表理论基础" class="headerlink" title="2.1 链表理论基础"></a>2.1 链表理论基础</h2><p>单链表：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="链表1"></p>
<p>双链表：既可以向前查询也可以向后查询。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt="链表2"></p>
<p>循环链表：链表首尾相连，可以用来解决约瑟夫环问题（n个人围成圈，报到k出列）。</p>
<p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329363.png" alt="链表3"></p>
<p>链表的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 结点的值</span></span><br><span class="line">    ListNode next;<span class="comment">// 下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>删除节点：C++需要手动释放，Java、Python有自己的内存回收机制无需手动释放</p>
<blockquote>
<p>就算使用C++来做leetcode，如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p>
</blockquote>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png" alt="链表-链表与数据性能对比">数组在定义的时候长度是固定的，链表长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h2 id="2-2-移除链表元素"><a href="#2-2-移除链表元素" class="headerlink" title="2.2 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">2.2 移除链表元素</a></h2><p>这里就涉及如下链表操作的两种方式：</p>
<ul>
<li><strong>直接使用原来的链表来进行删除操作。</strong></li>
<li><strong>设置一个虚拟头结点在进行删除操作。</strong>dummy会简单些，统一写dummy！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy; </span><br><span class="line">        <span class="keyword">while</span>(curr.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:<span class="comment">#Optional表示可以是ListNode类型，也可以是None。</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        curr = dummy</span><br><span class="line">        <span class="keyword">while</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == val:</span><br><span class="line">                curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-设计链表"><a href="#2-3-设计链表" class="headerlink" title="2.3 设计链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/description/">2.3 设计链表</a></h2><p>这道题目设计链表的五个接口：</p>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
<p>采用设置一个虚拟头结点</p>
<ul>
<li>时间复杂度: 涉及 <code>index</code> 的相关操作为 O(index), 其余为 O(1)</li>
<li>空间复杂度: O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MyLinkedList类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;<span class="comment">//dummy结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;<span class="comment">//注意index从0开始，所以实际的下标为index+1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//私有属性，相当于this.size</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index == size)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size)&#123;<span class="comment">//实际的下标是index + 1</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            newNode.next = cur;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ListNode</code> 就是一个非静态内部类。它的实例依赖于外部类的实例。内部类 <code>ListNode</code> 可以直接访问 <code>MyLinkedList</code> 的私有属性（如 <code>head</code> 和 <code>size</code>），但在这个例子中并没有直接访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val = <span class="number">0</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>):</span><br><span class="line">            <span class="variable language_">self</span>.val = val</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.head = <span class="variable language_">self</span>.ListNode()<span class="comment">#内部类也要写self</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= <span class="variable language_">self</span>.size: <span class="comment">#访问内部属性必须写self</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        newNode = <span class="variable language_">self</span>.ListNode(val)</span><br><span class="line">        newNode.<span class="built_in">next</span> = <span class="variable language_">self</span>.head.<span class="built_in">next</span></span><br><span class="line">        <span class="variable language_">self</span>.head.<span class="built_in">next</span> = newNode</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        newNode = <span class="variable language_">self</span>.ListNode(val)</span><br><span class="line">        cur = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = newNode</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index == <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="variable language_">self</span>.addAtTail(val) <span class="comment">#注意访问实例方法也要写self</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; <span class="variable language_">self</span>.size:</span><br><span class="line">            newNode = <span class="variable language_">self</span>.ListNode(val)</span><br><span class="line">            pre = <span class="variable language_">self</span>.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">            newNode.<span class="built_in">next</span> = pre.<span class="built_in">next</span>   </span><br><span class="line">            pre.<span class="built_in">next</span> = newNode</span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; <span class="variable language_">self</span>.size:</span><br><span class="line">            pre = <span class="variable language_">self</span>.head </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>注意python<strong>访问实例属性、实例方法、内部类</strong>都要使用 <code>self</code>。但是访问外部类不用。</p>
<h2 id="2-4-翻转链表"><a href="#2-4-翻转链表" class="headerlink" title="2.4 翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">2.4 翻转链表</a></h2><p>不需要定义一个新的链表，直接改变链表的next指针的指向即可，记得把 cur-&gt;next 节点用tmp指针保存一下即可</p>
<ul>
<li>用双指针法从前往后翻转指针指向，比较直接好理解（递归感觉这题没啥必要，反而复杂了）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;<span class="comment">//如果直接访问head.next，那head为空时会报错，这样更有普适性</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//写外面单纯更简洁</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;<span class="comment">//会把head.next赋为空</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span><span class="comment">#写里面也可以，与效率无关</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<p>因为每次循环都会进行垃圾回收，所以tmp定义在循环外部内部感觉区别不大，编译器会复用栈上的同一块内存，创建和销毁都很高效。</p>
<h2 id="2-5-两两交换链表中的节点"><a href="#2-5-两两交换链表中的节点" class="headerlink" title="2.5 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">2.5 两两交换链表中的节点</a></h2><p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="24.两两交换链表中的节点2"></p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p>
<p>重点是每次只交换2个数，不用纠结tmp3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> tmp1.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp3</span> <span class="operator">=</span> tmp2.next;<span class="comment">//可能为空</span></span><br><span class="line">            cur.next = tmp2;<span class="comment">//每次交换2个数</span></span><br><span class="line">            tmp2.next = tmp1;</span><br><span class="line">            tmp1.next = tmp3;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            tmp1 = cur.<span class="built_in">next</span></span><br><span class="line">            tmp2 = tmp1.<span class="built_in">next</span></span><br><span class="line">            tmp3 = tmp2.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = tmp2</span><br><span class="line">            tmp2.<span class="built_in">next</span> = tmp1</span><br><span class="line">            tmp1.<span class="built_in">next</span> = tmp3</span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-删除链表的倒数第-N-个结点"><a href="#2-6-删除链表的倒数第-N-个结点" class="headerlink" title="2.6 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">2.6 删除链表的倒数第 N 个结点</a></h2><p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img"></p>
<p>扫描两遍很简单，如何只扫描一遍？双指针法！</p>
<ul>
<li>fast首先走n + 1步，然后fast和slow同时移动，直到fast指向末尾</li>
<li>这样可以让slow正好在待删节点的前一个，原理是间距固定为n+1，fast为空时flow正好指向倒数n+1个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy, slow = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        fast = slow = dummy <span class="comment">#注意可以写连等</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-链表相交"><a href="#2-7-链表相交" class="headerlink" title="2.7 链表相交"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">2.7 链表相交</a></h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329861.png" alt="面试题02.07.链表相交_2.png"></p>
<p>注意交点不是数值相等，而是指针相等，可以理解为物理结构就是相交的，先有图这样的物理结构再有题目。所以不要纠结为什么val和next一样但地址不一样，题目比较的就是地址。</p>
<ul>
<li><strong>引用</strong>指的是链表节点在内存中的地址。当我们说两个链表相交时，意味着它们共享同一个节点（即两个链表中的某个节点的内存地址相同），即引用完全相同。</li>
</ul>
<p>因为相交后面的节点一定一样，所以先将长一点的链表移动到<strong>相同的位置</strong>，然后同时向后移动cur比较即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">null</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> Math.abs(lenA - lenB);</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">while</span>(gap != <span class="number">0</span>)&#123;</span><br><span class="line">                curA = curA.next;</span><br><span class="line">                gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(gap != <span class="number">0</span>)&#123;</span><br><span class="line">                curB = curB.next;</span><br><span class="line">                gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不断比较节点是否相同</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curA = curA.next;</span><br><span class="line">                curB = curB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        lenA, lenB = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="keyword">while</span> curA:</span><br><span class="line">            curA = curA.<span class="built_in">next</span></span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> curB:</span><br><span class="line">            curB = curB.<span class="built_in">next</span></span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        gap = <span class="built_in">abs</span>(lenA - lenB)</span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">            <span class="keyword">while</span> gap:</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">                gap -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> gap:</span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">                gap -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> curA:</span><br><span class="line">            <span class="keyword">if</span> curA == curB:</span><br><span class="line">                <span class="keyword">return</span> curA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-环形链表-II"><a href="#2-8-环形链表-II" class="headerlink" title="2.8 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">2.8 环形链表 II</a></h2><p>哈希表是直观的思路，时间&#x2F;空间复杂度是O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pos</span> <span class="operator">=</span> head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;<span class="comment">//环的入口就是第一个重复的节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pos = head</span><br><span class="line">        visited = <span class="built_in">set</span>()  <span class="comment"># 使用 Python 的 set 来存储访问过的节点</span></span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            <span class="keyword">if</span> pos <span class="keyword">in</span> visited:  <span class="comment"># 如果节点已经存在于 set 中，说明是环的入口</span></span><br><span class="line">                <span class="keyword">return</span> pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.add(pos)  <span class="comment"># 将当前节点添加到 set 中</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span>  <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 如果没有环，返回 None</span></span><br></pre></td></tr></table></figure>

<p>进阶：用空间O(1)实现，Floyd判圈算法</p>
<ul>
<li><p>判断链表是否环：可以使用<strong>快慢指针法</strong>，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p>
</li>
<li><p>如果有环，如何找到这个环的入口：首先可以证明<strong>第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y</strong> ，然后相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，可以得到x &#x3D; n (y + z) - y。</p>
</li>
<li><p>从头结点出发一个指针ptr，从相遇节点也出发一个指针slow，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点。如果n&#x3D;1，则slow没有在环中走多余的路，如果n&gt;1，则相遇前会在环中转n-1圈，但最后会和ptr在入口相遇。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;<span class="comment">//在环中相遇</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                ptr = head</span><br><span class="line">                <span class="keyword">while</span> ptr != slow:</span><br><span class="line">                    ptr = ptr.<span class="built_in">next</span></span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> ptr</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-9-总结篇"><a href="#2-9-总结篇" class="headerlink" title="2.9 总结篇"></a>2.9 总结篇</h2><p>统一使用虚拟头节点dummy<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329784.png" alt="img"></p>
<h1 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3. 哈希表"></a>3. 哈希表</h1><h2 id="3-1-哈希表理论基础"><a href="#3-1-哈希表理论基础" class="headerlink" title="3.1 哈希表理论基础"></a>3.1 哈希表理论基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构，用来快速判断一个元素是否出现集合里。</p>
<p>哈希函数：通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt="哈希表2" style="zoom:50%;" />

<p>哈希碰撞：小李和小王都映射到了索引下标 1 的位置</p>
<ul>
<li>拉链法：发生冲突的元素都被存储在链表中。需要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png" alt="哈希表4" style="zoom:33%;" /></li>
<li>线性探测法：一定要保证tableSize大于dataSize，因为需要依靠哈希表中的空位来解决碰撞问题。如向下找一个空位。<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png" alt="哈希表5" style="zoom:33%;" /></li>
</ul>
<p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map（映射）</li>
</ul>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>
<p>虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。</p>
<p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p>
<p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329127.png" alt="哈希表6" style="zoom:50%;" />

<blockquote>
<p>以下是我的补充：</p>
<p>Java：红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>哈希表 + 链表</td>
<td>有序（插入顺序）</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>TreeSet</td>
<td>红黑树</td>
<td>有序（自然顺序或自定义顺序）</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">映射</th>
<th align="left">底层实现</th>
<th align="left">是否有序</th>
<th align="left">key是否可以重复</th>
<th align="left">能否更改key</th>
<th align="left">查询效率</th>
<th align="left">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HashMap</td>
<td align="left">哈希表</td>
<td align="left">无序</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">LinkedHashMap</td>
<td align="left">哈希表 + 链表</td>
<td align="left">有序（插入顺序或访问顺序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">红黑树</td>
<td align="left">有序（自然顺序或自定义顺序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(log n)</td>
<td align="left">O(log n)</td>
</tr>
</tbody></table>
<p>Python：</p>
<table>
<thead>
<tr>
<th align="left">集合</th>
<th align="left">底层实现</th>
<th align="left">是否有序</th>
<th align="left">数值是否可以重复</th>
<th align="left">能否更改数值</th>
<th align="left">查询效率</th>
<th align="left">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="left">set</td>
<td align="left">哈希表</td>
<td align="left">无序</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">frozenset</td>
<td align="left">哈希表</td>
<td align="left">无序</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">不可变</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">映射</th>
<th align="left">底层实现</th>
<th align="left">是否有序</th>
<th align="left">key是否可以重复</th>
<th align="left">能否更改key</th>
<th align="left">查询效率</th>
<th align="left">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dict</td>
<td align="left">哈希表</td>
<td align="left">无序（Python 3.7+ 有序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">OrderedDict</td>
<td align="left">哈希表 + 双向链表</td>
<td align="left">有序（插入顺序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p>当我们要使用集合来解决哈希问题的时候，优先使用HashSet，因为它的查询和增删效率是最优的。基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。</p>
</blockquote>
<p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<h2 id="3-2-有效的字母异位词"><a href="#3-2-有效的字母异位词" class="headerlink" title="3.2 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">3.2 有效的字母异位词</a></h2><p>排序法时间复杂度<em>O</em>(<em>n</em>log<em>n</em>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(s) == <span class="built_in">sorted</span>(t)</span><br></pre></td></tr></table></figure>

<p><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p>
<p>定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。对一个字符串统计+1，对另一个字符串-1，最后看是否有元素不为0，有则不是字母异位词。时间复杂度: O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;<span class="comment">//先看边界情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**for (int count: record) &#123; 可以写作访问数组内容int的格式</span></span><br><span class="line"><span class="comment">            if (count != 0) &#123;               </span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;**/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):  <span class="comment"># 先看边界情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span>  <span class="comment"># 初始化一个长度为26的列表，对应英文字母的数量</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            record[<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span>  <span class="comment"># 计算s中每个字符的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            record[<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span>  <span class="comment"># 减去t中每个字符的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> count <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">if</span> count != <span class="number">0</span>:  <span class="comment"># 如果record数组中有非零元素，则表示s和t不是字母异位词</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>另外python的Counter和defaultdict也可以解题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> Counter(s) == Counter(t)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s_dict = defaultdict(<span class="built_in">int</span>)<span class="comment">#表示对于任何未见过的键，其初始值都会被设置为 0</span></span><br><span class="line">        t_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            s_dict[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">            t_dict[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s_dict == t_dict</span><br></pre></td></tr></table></figure>

<h2 id="3-3-两个数组的交集"><a href="#3-3-两个数组的交集" class="headerlink" title="3.3 两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">3.3 两个数组的交集</a></h2><p>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序。</p>
<p>使用数组来做哈希的题目，是因为题目都限制了数值的大小，如上一题只需要26位记录次数，但这里没有限制大小，哈希值可能比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。此处就适合使用集合。</p>
<ul>
<li>那为什么有时哈希问题要用数组？直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。不要小瞧这个耗时，在数据量大的情况，差距是很明显的。</li>
<li>后来此题限制了大小在1000以内，也可以用数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//这里用set是因为不确定长度，同时避免重复，list不能避免重复</span></span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将set转为int[]</span></span><br><span class="line">        <span class="comment">//法1：将流中的每个Integer对象映射到其对应的int值</span></span><br><span class="line">        <span class="keyword">return</span> resSet.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">        <span class="comment">/**法2：另外构造一个int[]数组，比较符合记不住简单方法时候的用法</span></span><br><span class="line"><span class="comment">        int[] arr = new int[resSet.size()];</span></span><br><span class="line"><span class="comment">        int j = 0;</span></span><br><span class="line"><span class="comment">        for(int i : resSet)&#123;</span></span><br><span class="line"><span class="comment">            arr[j++] = i;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return arr;</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>(nums1) &amp; <span class="built_in">set</span>(nums2))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        st = <span class="built_in">set</span>(nums1)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> st:</span><br><span class="line">                st.remove(x)<span class="comment">#保证nums2的重复数字不会添加到ans，相当于保证ans是set，对nums2也做了set</span></span><br><span class="line">                ans.append(x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="3-4-快乐数"><a href="#3-4-快乐数" class="headerlink" title="3.4 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">3.4 快乐数</a></h2><p>注意无限循环：如果sum重复出现了，就不可能是快乐数，sum达到1了。所以需要用set存储出现过的sum值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//保存出现过的sum值</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !record.contains(n))&#123;</span><br><span class="line">            record.add(n);<span class="comment">//注意最开始的数字就应该加入进去了</span></span><br><span class="line">            n = getNextNum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;<span class="comment">//如果无限循环也会来到这里，但不满足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//对每一位求平方和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += Math.pow(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        record = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record.add(n)</span><br><span class="line">            n_str = <span class="built_in">str</span>(n)</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">                <span class="built_in">sum</span> += <span class="built_in">int</span>(i)**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == <span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-两数之和"><a href="#3-5-两数之和" class="headerlink" title="3.5 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">3.5 两数之和</a></h2><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p>
<p>本题我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p>再来看一下使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的<strong>下标位置</strong>，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一" style="zoom:50%;" />

<ul>
<li>因为只允许两数之和，所以可以随时作差</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;<span class="comment">//先看边界情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//注意里面写Integer而不是int，因为int不是类</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(tmp);<span class="comment">//返回tmp对应的下标</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);<span class="comment">//注意key是数组的值，value是数组的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = <span class="built_in">dict</span>() <span class="comment">#python中map就是dict</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  </span><br><span class="line">            <span class="keyword">if</span> target - value <span class="keyword">in</span> record:<span class="comment">#寻找匹配的key</span></span><br><span class="line">                <span class="keyword">return</span> [index, record[target - value]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                record[value] = index <span class="comment">#key不重复</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h2 id="3-6-四数相加-II"><a href="#3-6-四数相加-II" class="headerlink" title="3.6 四数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">3.6 四数相加 II</a></h2><p>参考前文的两数之和，建立map，先记录A+B数组的元素之和和出现次数，然后遍历C+D，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</p>
<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j: nums2)&#123;</span><br><span class="line">                map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);<span class="comment">//如果找不到key，就返回设置的默认值0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j: nums4)&#123;</span><br><span class="line">                count += map.getOrDefault(- i - j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">map</span> = <span class="built_in">dict</span>()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="built_in">map</span>[i + j] = <span class="built_in">map</span>.get(i + j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                count += <span class="built_in">map</span>.get( - i - j, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h2 id="3-7-赎金信"><a href="#3-7-赎金信" class="headerlink" title="3.7 赎金信"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">3.7 赎金信</a></h2><p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个<strong>长度为26的数组</strong>来记录magazine里字母出现的次数。然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p>
<p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">//ransomNote中的每个字符在magazine中都出现过</span></span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++)&#123;</span><br><span class="line">            record[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++)&#123;</span><br><span class="line">            record[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> magazine:</span><br><span class="line">            record[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> ransomNote:</span><br><span class="line">            record[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#Counter对字符串的每个字符计数，结果为空则为True</span></span><br><span class="line">        <span class="comment">#return (Counter(ransomNote) - Counter(magazine)) == &#123;&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (Counter(ransomNote) - Counter(magazine))</span><br></pre></td></tr></table></figure>

<h2 id="3-8-三数之和"><a href="#3-8-三数之和" class="headerlink" title="3.8 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">3.8 三数之和</a></h2><p>两层for循环就可以确定 两个数值，可以使用哈希法来确定 第三个数 0-(a+b) 或者 0 - (a + c) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。</p>
<ul>
<li>哈希法用set存b，a是nums[i]，c是nums[k](另一层循环，k&#x3D;i+1…n)，过程中要不断对a和c去重，比较繁琐</li>
<li>时间复杂度: O(n^2)，第二层循环有时作c有时作b，总之有点难理解，用双指针！</li>
</ul>
<p>而排序可以去除重复解。拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329194.gif" alt="15.三数之和"></p>
<p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。</p>
<ul>
<li>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</li>
<li>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。时间复杂度：O(n^2)。</li>
</ul>
<p>去重逻辑的思考</p>
<ol>
<li>a的去重：不是与nums[i + 1]比较，而是与nums[i - 1]比较，因为不能有重复的三元组，但三元组内的元素是可以重复的</li>
<li>b与c的去重：在三数之和非0时，无需去重bc，因为下一个循环也会校验。等于0时要校验是否重复。</li>
</ol>
<p>两数之和 就不能使用双指针法，因为<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>要求返回的是索引下标， 而<strong>双指针法一定要排序</strong>，一旦排序之后原数组的索引就被改变了（要求返回的是数值的话，就可以使用双指针法了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//排序，令左指针 L=i+1，右指针 R=n−1</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// a=nums[i], b=nums[left], c=nums[right]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//如果最小的a已然大于0，不可能和为0</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//对a去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;<span class="comment">//定义双指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left)&#123;<span class="comment">//在找以a为基础的这一轮循环</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">//此时要去重，直到b和c是新的数字</span></span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    right--;<span class="comment">//注意跳出循环后仍要移动，不然停在重复值上</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                sum_ = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="3-9-四数之和"><a href="#3-9-四数之和" class="headerlink" title="3.9 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">3.9 四数之和</a></h2><p>三数之和：一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] &#x3D;&#x3D; 0。</p>
<p>四数之和：两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</p>
<ul>
<li>对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;<span class="comment">//枚举a=nums[i]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; target)&#123;<span class="comment">// 剪枝处理</span></span><br><span class="line">                <span class="keyword">return</span> res;<span class="comment">//列举可以发现相加只会越来越大</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//在i-1时已经覆盖了所有情况</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++)&#123;<span class="comment">//枚举b=nums[j]</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] &gt;= <span class="number">0</span> &amp;&amp; nums[i] + nums[j] &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//注意这里不应该return res，不像外层循环一样杜绝了可能的结果</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//遇到重复值要过</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort() <span class="comment">#先排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] + nums[j] &gt; target:</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">#注意这里不能直接返回</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    sum_ = nums[i] + nums[j] + nums[left] + nums[right]<span class="comment">#和求和函数作区分</span></span><br><span class="line">                    <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="3-10-总结篇"><a href="#3-10-总结篇" class="headerlink" title="3.10 总结篇"></a>3.10 总结篇</h2><p>要求只有小写字母时，很合适用数组，因为空间消耗固定</p>
<p>没有限制数值大小时，用set做映射</p>
<p>当需要记录下标时，用map，因为是<code>&lt;key, value&gt;</code>结构（虽然map是万能的，但数组和set当然效率更高）</p>
<ul>
<li>std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），并不需要key有序时选择std::unordered_map 效率更高</li>
</ul>
<h1 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h1><h2 id="4-1-反转字符串"><a href="#4-1-反转字符串" class="headerlink" title="4.1 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">4.1 反转字符串</a></h2><p>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p>
<p>swap可以有两种实现。</p>
<p>一种就是常见的交换数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> s[i];</span><br><span class="line">s[i] = s[j];</span><br><span class="line">s[j] = tmp;</span><br></pre></td></tr></table></figure>

<p>一种就是通过位运算：01，则结果为1；11&#x2F;00，则结果为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s[i] ^= s[j];<span class="comment">//i=i^j</span></span><br><span class="line">s[j] ^= s[i];<span class="comment">//j=j^(i^j)=i 自己和自己异或是0</span></span><br><span class="line">s[i] ^= s[j];<span class="comment">//i=(i^j)^i=j</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="comment">//原地修改数组，就是用一个tmp存，然后把最先和最后进行交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]<span class="comment">#在内存中会使用一个临时的元组来保存中间状态</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="4-2-反转字符串-II"><a href="#4-2-反转字符串-II" class="headerlink" title="4.2 反转字符串 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">4.2 反转字符串 II</a></h2><p>在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<p>我独立完成的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_substring</span>(<span class="params">self, s:<span class="built_in">str</span>, i:<span class="built_in">int</span>, j:<span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:<span class="comment">#反转[i,j)</span></span><br><span class="line">        before = s[:i]</span><br><span class="line">        reversed_part = s[i:j][::-<span class="number">1</span>]</span><br><span class="line">        after = s[j:]</span><br><span class="line">        <span class="keyword">return</span> before + reversed_part + after</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s) // (<span class="number">2</span> * k)</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:<span class="comment">#反转n次前k个字符</span></span><br><span class="line">            index = (n - <span class="number">1</span>)*<span class="number">2</span>*k</span><br><span class="line">            s = <span class="variable language_">self</span>.reverse_substring(s, index, index + k)</span><br><span class="line">            <span class="comment">#s[index, index + k] = s[index, index + k][::-1]这样直接修改是错的，元组不能作为索引</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(s) // (<span class="number">2</span> * k)</span><br><span class="line">        last = <span class="built_in">len</span>(s) - n*<span class="number">2</span>*k <span class="comment">#7-1*2*2=3</span></span><br><span class="line">        <span class="keyword">if</span> last &gt; <span class="number">0</span> <span class="keyword">and</span> last &lt; k:</span><br><span class="line">            s = <span class="variable language_">self</span>.reverse_substring(s, n*<span class="number">2</span>*k, <span class="built_in">len</span>(s))</span><br><span class="line">        <span class="keyword">elif</span> last &gt;= k <span class="keyword">and</span> last &lt; <span class="number">2</span>*k:</span><br><span class="line">            s = <span class="variable language_">self</span>.reverse_substring(s, n*<span class="number">2</span>*k, n*<span class="number">2</span>*k + k)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p>改善版：其实每次看2k个，反转前k个就行，最后剩余字符的两种情况也符合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            p2 = p + k</span><br><span class="line">            s = s[:p] + s[p: p2][::-<span class="number">1</span>] + s[p2:]</span><br><span class="line">            p = p + <span class="number">2</span> * k</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h2 id="4-3-替换数字"><a href="#4-3-替换数字" class="headerlink" title="4.3 替换数字"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1064">4.3 替换数字</a></h2><p>申请新数组的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数字替换为number</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> char.isdigit():</span><br><span class="line">        result += <span class="string">&quot;number&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += char</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>正则表达式的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(sc.next().replaceAll(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;number&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想把这道题目做到极致，就不要只用额外的辅助空间了！ （不过使用Java刷题的录友，一定要使用辅助空间，因为Java里的string不能修改）</p>
<p>注意<strong>从后往前</strong>填充：从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。</p>
<p>很多数组填充类的问题，其做法都是先预先给数组扩容到填充后的大小，然后在从后向前进行操作。这么做有两个好处：</p>
<ol>
<li>不用申请新数组。</li>
<li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li>
</ol>
<h2 id="4-4-反转字符串中的单词"><a href="#4-4-反转字符串中的单词" class="headerlink" title="4.4 反转字符串中的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">4.4 反转字符串中的单词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = s.split()</span><br><span class="line">        reversed_list = s_list[::-<span class="number">1</span>]<span class="comment">#反转列表而不是反转字符串</span></span><br><span class="line">        res = <span class="string">&quot; &quot;</span>.join(reversed_list)<span class="comment"># 使用单个空格将反转后的单词列表拼接成字符串</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 使用 split() 方法按任意连续空白字符分割字符串，注意不要写split(&quot; &quot;)，否则结果是[&#x27;a&#x27;, &#x27;good&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;example&#x27;]</span></span><br><span class="line">        s_list = s.split()</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> index, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(s_list):</span><br><span class="line">            res = word + <span class="string">&quot; &quot;</span> + res</span><br><span class="line">        <span class="keyword">return</span> res.strip() <span class="comment">#去除字符串首尾的空白字符</span></span><br></pre></td></tr></table></figure>

<p>不要使用辅助空间，空间复杂度要求为O(1)。所以解题思路如下：</p>
<ul>
<li><p>移除多余空格：包括前后的空格，中间的连续空格。要保持O(n)的话，用“1.3移除元素”的快慢指针法</p>
<ul>
<li>C++的话可以在string上原地修改，但Java的String不能修改（使用<code>final char[]</code>数组来存储字符），所以要使用<code>StringBuilder</code>或<code>char[]</code>数组作为辅助空间</li>
</ul>
</li>
<li><p>将整个字符串反转：参考4.1，用双指针+一个额外空间进行交换</p>
</li>
<li><p>将每个单词反转：等价于反转字符串</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用Java内置方法实现</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 1.去除首尾以及中间多余空格</span></span><br><span class="line"><span class="comment">     * 2.反转整个字符串</span></span><br><span class="line"><span class="comment">     * 3.反转各个单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder <span class="title function_">removeSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;<span class="comment">//去除前后的空格</span></span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;<span class="comment">//去除中间的连续空格，加入sb</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串指定区间[start, end]的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;<span class="comment">//双指针</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);<span class="comment">//用一个额外空间暂存</span></span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;<span class="comment">//主要是识别单词</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-右旋字符串"><a href="#4-5-右旋字符串" class="headerlink" title="4.5 右旋字符串"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1065">4.5 右旋字符串</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">input</span>()</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">index = <span class="built_in">len</span>(s) - <span class="built_in">int</span>(k)</span><br><span class="line">res = s[index:] + s[:index]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>通过 整体倒叙，把两段子串顺序颠倒，两个段子串里的的字符在倒叙一把，<strong>负负得正</strong>，这样就不影响子串里面字符的顺序了。</p>
<p>这样额外空间只有交换时的O(1)，左反转和右反转的思路一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(in.nextLine());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();  <span class="comment">//获取字符串长度</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();<span class="comment">//转成数组的原因是Java字符串无法修改，但数组可以修改</span></span><br><span class="line">        reverseString(chars, <span class="number">0</span>, len - <span class="number">1</span>);  <span class="comment">//反转整个字符串</span></span><br><span class="line">        reverseString(chars, <span class="number">0</span>, n - <span class="number">1</span>);  <span class="comment">//反转前一段字符串，此时的字符串首尾尾是0,n - 1</span></span><br><span class="line">        reverseString(chars, n, len - <span class="number">1</span>);  <span class="comment">//反转后一段字符串，此时的字符串首尾尾是n,len - 1</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;<span class="comment">//只用一个额外空间</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            ch[start] ^= ch[end];</span><br><span class="line">            ch[end] ^= ch[start];</span><br><span class="line">            ch[start] ^= ch[end];</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-找出字符串中第一个匹配项的下标"><a href="#4-6-找出字符串中第一个匹配项的下标" class="headerlink" title="4.6 找出字符串中第一个匹配项的下标"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">4.6 找出字符串中第一个匹配项的下标</a></h2><p>“mississippi”注意这种用例，不能一直前移haystack，朴素做法：<em>O</em>(<em>m</em>∗<em>n</em>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(haystack) &lt; <span class="built_in">len</span>(needle):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(haystack) - <span class="built_in">len</span>(needle) + <span class="number">1</span>):<span class="comment">#记得要写range，刚开始没注意</span></span><br><span class="line">            <span class="keyword">if</span> haystack[i: i+<span class="built_in">len</span>(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>KMP算法：<em>O</em>(<em>m</em>+<em>n</em>) 应用于匹配DNA片段、文本搜索</p>
<p>详见本人博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53632564/article/details/145783773?spm=1001.2014.3001.5502">超简单理解KMP算法（最长公共前后缀next数组、合并主子串、子串偏移法）-CSDN博客</a></p>
<p>获得next数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">       		len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">			<span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>合并主串子串的方法：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329235.png" alt="image-20250221224217526"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(haystack) <span class="comment">#主串的的长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(needle) <span class="comment">#子串的长度</span></span><br><span class="line">        <span class="keyword">if</span> haystack == needle: <span class="comment">#因为i从1开始，所以处理edge case</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s = needle + <span class="string">&quot;#&quot;</span> + haystack <span class="comment">#注意把子串放前面，这样前缀和才能覆盖子串</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + m + <span class="number">1</span>): <span class="comment">#注意+1是因为&quot;#&quot;多了一位</span></span><br><span class="line">            len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">                len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">                <span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span>[i] == m:<span class="comment">#返回第一个</span></span><br><span class="line">                    <span class="keyword">return</span> i - m*<span class="number">2</span> <span class="comment">#合并串从第m+1位开始才是主串，所以主串中开始匹配的下标是i - (m+1) - m + 1=i-2*m</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>子串偏移的做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">                len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">                <span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(needle)</span><br><span class="line">        <span class="variable language_">self</span>.getNext(<span class="built_in">next</span>, needle)</span><br><span class="line">        i = <span class="number">0</span> <span class="comment">#主串指针</span></span><br><span class="line">        j = <span class="number">0</span> <span class="comment">#子串指针</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:<span class="comment">#不匹配，子串到下一个可能匹配的地方next[j-1]，注意只要j&gt;0要一直找，而不是只试一次</span></span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:<span class="comment">#字符匹配，指针后移</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):<span class="comment">#在主串中找到了子串</span></span><br><span class="line">                <span class="keyword">return</span> i - <span class="built_in">len</span>(needle) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-7-重复的子字符串"><a href="#4-7-重复的子字符串" class="headerlink" title="4.7 重复的子字符串"></a>4.7 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></h2><p>暴力法：用一个for循环获取子串的终止位置（起始位置肯定是第一个字母，不然不可能重复多次构成，同时这里可以优化：子串至少重复一次，所以终止位置遍历到n&#x2F;2的中间位置即可），再用一个循环判断子串是否能重复构成字符串。<em>O</em>(n^2)</p>
<p><strong>移动匹配</strong>法：如果将两个<em>s</em>连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含<em>s</em>，即<em>s</em>是它的一个子串</p>
<ul>
<li>这种方法只能判断有没有，不能立马得到子串是什么，仅用于此题返回true&#x2F;false的情况</li>
<li>我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数， 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。也就是4.6中的KMP。</li>
<li>这里构造 <code>s + s</code> 的时间复杂度是 <em>O</em>(<em>n</em>)，在 <code>s + s</code> 中查找 <code>s</code> 的时间复杂度也是 <em>O</em>(<em>n</em>)。所以总的也是<em>O</em>(<em>n</em>)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>

<p>KMP法：</p>
<p>充分条件：如果字符串s是由重复子串组成，那么 最长相等前后缀不包含的子串 一定是 s的最小重复子串。</p>
<p>必要条件：如果字符串s的最长相等前后缀不包含的子串 是 s最小重复子串，那么 s是由重复子串组成。</p>
<p>当 最长相等前后缀不包含的子串的<strong>长度</strong> 可以被 字符串s的长度整除，那么不包含的子串 就是s的最小重复子串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):<span class="comment">#不减一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">                len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">                <span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="variable language_">self</span>.getNext(<span class="built_in">next</span>, s) <span class="comment">#最长相等前后缀在该题中就是next[-1]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">next</span>[-<span class="number">1</span>] != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(s) % (<span class="built_in">len</span>(s) - <span class="built_in">next</span>[-<span class="number">1</span>]) == <span class="number">0</span>:<span class="comment">#可以被整除那不包含的子串就是重复子串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="4-8-总结篇"><a href="#4-8-总结篇" class="headerlink" title="4.8 总结篇"></a>4.8 总结篇</h2><p>建议不使用库函数</p>
<p>很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在<strong>从后向前</strong>进行操作。</p>
<p>双指针法是字符串处理的常客。</p>
<h1 id="5-双指针法"><a href="#5-双指针法" class="headerlink" title="5. 双指针法"></a>5. 双指针法</h1><h2 id="5-11-总结篇"><a href="#5-11-总结篇" class="headerlink" title="5.11 总结篇"></a>5.11 总结篇</h2><p>双指针不能同时存下标和数值</p>
<p>双指针有时是快慢（一个走2，一个走1），有时是从两头向中间逼近，有时是从后往前。虽然惯性思维经常是从前往后</p>
<p>除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将O(n^2)的时间复杂度，降为 $O(n)$</p>
<h1 id="6-栈与队列"><a href="#6-栈与队列" class="headerlink" title="6. 栈与队列"></a>6. 栈与队列</h1><h2 id="6-1-理论基础"><a href="#6-1-理论基础" class="headerlink" title="6.1 理论基础"></a>6.1 理论基础</h2><p>栈：先进后出</p>
<p>队列：先进先出</p>
<h2 id="6-2-用栈实现队列"><a href="#6-2-用栈实现队列" class="headerlink" title="6.2 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">6.2 用栈实现队列</a></h2><p>一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        in主要负责push，out主要负责pop</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_in = []</span><br><span class="line">        <span class="variable language_">self</span>.stack_out = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        有新元素进来，就往in里面push</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_in.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack_out:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#[10,20,30]就以30 20 10的顺序导入 这样是先进后出</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.stack_in)):</span><br><span class="line">                <span class="variable language_">self</span>.stack_out.append(<span class="variable language_">self</span>.stack_in.pop())</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()<span class="comment">#这里又会以10 20 30的顺序pop，两次先进后出实现队列的先进先出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="variable language_">self</span>.pop()<span class="comment">#复用了上面的方法，已经移除了不妨加入out</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        只要in或者out有元素，说明队列不为空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (<span class="variable language_">self</span>.stack_in <span class="keyword">or</span> <span class="variable language_">self</span>.stack_out)</span><br></pre></td></tr></table></figure>

<p>需要两个栈<strong>一个输入栈，一个输出栈</strong>，在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p>
<h2 id="6-3-用队列实现栈"><a href="#6-3-用队列实现栈" class="headerlink" title="6.3 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">6.3 用队列实现栈</a></h2><p>两个队列：新来的数字入2，然后把1中的数字加入，最后返回1中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.q1 = deque()</span><br><span class="line">        <span class="variable language_">self</span>.q2 = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.q2.append(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.q1:</span><br><span class="line">            <span class="variable language_">self</span>.q2.append(<span class="variable language_">self</span>.q1.popleft())</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.q2:</span><br><span class="line">            <span class="variable language_">self</span>.q1.append(<span class="variable language_">self</span>.q2.popleft())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:<span class="comment">#这里和top都m</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.q1.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.q1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.q1</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>

<p>一个队列：模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。O(n)</p>
<h2 id="6-4-有效的括号"><a href="#6-4-有效的括号" class="headerlink" title="6.4 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">6.4 有效的括号</a></h2><p>linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd a/b/c/../../</span><br></pre></td></tr></table></figure>

<p>这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用（..退，就是后面的目录级要出栈）</p>
<p>判断右括号的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;]&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;&#125;&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> st <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>碰到左括号，就把相应的右括号入栈，然后右括号来时对比是否一样即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二，使用字典</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        mapping = &#123;<span class="comment">#keys/[] 学习字典的用法</span></span><br><span class="line">            <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> mapping.keys():</span><br><span class="line">                stack.append(mapping[item])</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != item: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="6-5-删除字符串中的所有相邻重复项"><a href="#6-5-删除字符串中的所有相邻重复项" class="headerlink" title="6.5 删除字符串中的所有相邻重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">6.5 删除字符串中的所有相邻重复项</a></h2><p>这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。</p>
<p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。无限递归会引发调用栈溢出<code>Segmentation fault</code></p>
<p>而且<strong>在企业项目开发中，尽量不要使用递归</strong>！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p>
<p>如果不让用栈可以用双指针模拟</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> st <span class="keyword">and</span> c == st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(c)</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> st:<span class="comment">#这里简单的写法是&quot;&quot;.join(res) 数组转字符串</span></span><br><span class="line">            res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="6-6-逆波兰表达式求值"><a href="#6-6-逆波兰表达式求值" class="headerlink" title="6.6 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">6.6 逆波兰表达式求值</a></h2><p>栈与递归之间在某种程度上是可以转换的！逆波兰表达式相当于是二叉树中的后序遍历。<strong>后缀表达式RPN对计算机来说是非常友好的</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        st = []</span><br><span class="line">        sign = [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> sign:</span><br><span class="line">                num1 = st.pop()</span><br><span class="line">                num2 = st.pop()</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    num = num1 + num2</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    num = num2 - num1</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    num = num1 * num2</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    num = num2 / num1<span class="comment">#注意向零截断，所以要用/+int，而不能用//</span></span><br><span class="line">                st.append(<span class="built_in">int</span>(num))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(<span class="built_in">int</span>(c))</span><br><span class="line">        <span class="keyword">return</span> st[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>可以学习下面这种调用函数的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, sub, mul</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># 使用整数除法的向零取整方式 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(x / y)<span class="comment">#答案是下面，但这样写也过了，感觉已经满足向0截断了</span></span><br><span class="line">    <span class="comment">#return int(x / y) if x * y &gt; 0 else -(abs(x) // abs(y))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    op_map = &#123;<span class="string">&#x27;+&#x27;</span>: add, <span class="string">&#x27;-&#x27;</span>: sub, <span class="string">&#x27;*&#x27;</span>: mul, <span class="string">&#x27;/&#x27;</span>: div&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(token))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                op2 = stack.pop()</span><br><span class="line">                op1 = stack.pop()</span><br><span class="line">                stack.append(<span class="variable language_">self</span>.op_map[token](op1, op2))  <span class="comment"># 第一个出来的在运算符后面</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>

<h2 id="6-7-滑动窗口最大值"><a href="#6-7-滑动窗口最大值" class="headerlink" title="6.7 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">6.7 滑动窗口最大值</a></h2><p>不能每k个数都调用一次max，会超时（如k&#x3D;5000）</p>
<p>每次出一个数，来一个数，和max比较，也会超时</p>
<p>后来我的思路是不需要维护滑动窗口中的每个数，只要维护第一大和第二大即可，这样如果最大数离开了，比较新来的数和第二大数即可 </p>
<ul>
<li>我本来觉得维护第一大和第二大简单，看答案后发现复杂度是一样的，不是非要死板地保证队列长度为2，不出界就行</li>
<li>标答的while和每次都加入巧妙地保证了队列一定单调，且无需重新计算也知道目前窗口里的最值（如果q长度为1就是1，不然长度为3就是top3）</li>
</ul>
<p>也就是单调队列维护队列递减，不断把新的数与队尾元素比较即可</p>
<p>存下标非常巧妙，因为和滑动窗口的位置息息相关！！这样窗口变更后才知道现有队列中的最值是否出去了，while保证队列里的每个值都被判断，留下来的都是还在滑动窗口里的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = deque()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 移除不在窗口内的队首元素 保证q中的每个下标都没有超越窗口的左边界</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt; i - k + <span class="number">1</span>:</span><br><span class="line">                q.popleft()</span><br><span class="line">            <span class="comment"># 维护队列递减性质 如果当前元素大于队尾元素 则队尾元素出队 有可能把队列全清空</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)<span class="comment">#我不懂为啥当前的数字非得存进去，只和队尾比较一次不好吗（仔细想和维护top1/2的复杂性是一样的，这样写单调性更简单灵活，不是说非要有2个数）</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:<span class="comment">#其实除了最开始窗口小于k，后面每次都会有一个最大值</span></span><br><span class="line">                result.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="6-8-前-K-个高频元素"><a href="#6-8-前-K-个高频元素" class="headerlink" title="6.8 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">6.8 前 K 个高频元素</a></h2><p>优先级队列：披着队列外衣的堆，看起来就是队列，但内部元素是自动依照元素的权值排列</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，大顶堆就是节点的值不小于左右孩子的值</p>
<p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<ul>
<li>维护k个有序的序列即可</li>
<li>要用小顶堆，这样每次更新时把最小的元素弹出，留下来的就是前k个最大元素；用大顶堆，每次更新会把最大的元素弹出去，不符合逻辑</li>
</ul>
<p>所以本题先计算频率，然后把频率放入大小为k的小顶堆中，最后留下的就是前k大的高频元素（对于我的重点是小顶堆怎么建？）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="comment"># 统计每个数字出现的频率</span></span><br><span class="line">    count = Counter(nums)<span class="comment">#Counter(&#123;1: 3, 2: 2, 3: 1&#125;)，key是值，value是频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># heapq.nsmallest用于从可迭代对象中获取最小的k个元素，而题目是最高频的，x[1]是频率，所以-x[1]让频率反向</span></span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> item, freq <span class="keyword">in</span> heapq.nsmallest(k, count.items(), key=<span class="keyword">lambda</span> x: (-x[<span class="number">1</span>]))]</span><br></pre></td></tr></table></figure>

<p>注意调用heapq库很方便：排序过程的时间复杂度是 O(log k) ，整个算法的时间复杂度是 O(nlog k)。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        map_ = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            map_[num] = map_.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heap = []  <span class="comment">#从小到大排前k高的元素</span></span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> map_.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k:</span><br><span class="line">                heapq.heappush(heap, (freq, num))</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#比较当前值和堆顶的频率最小值哪个大</span></span><br><span class="line">                <span class="keyword">if</span> freq &gt; heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappushpop(heap, (freq, num))</span><br><span class="line">        <span class="comment">#另一种写法是先加入，让其排序，然后超过k了再弹出最小值</span></span><br><span class="line">        <span class="comment">#for key, freq in map_.items():</span></span><br><span class="line">        <span class="comment">#    heapq.heappush(heap, (freq, key))</span></span><br><span class="line">        <span class="comment">#    if len(heap) &gt; k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">        <span class="comment">#        heapq.heappop(heap)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            res.append(heapq.heappop(heap)[<span class="number">1</span>])<span class="comment">#注意加入的是值不是频率</span></span><br><span class="line">        <span class="comment">#另一种写法是利用range可以倒序遍历索引</span></span><br><span class="line">        <span class="comment">#res = [0] * k</span></span><br><span class="line">        <span class="comment">#for i in range(k-1, -1, -1):#起点是k-1，终点是0（左闭右开所以写-1），步长-1实现倒序遍历</span></span><br><span class="line">        <span class="comment">#    res[i] = heapq.heappop(heap)[1]</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="6-9-总结篇"><a href="#6-9-总结篇" class="headerlink" title="6.9 总结篇"></a>6.9 总结篇</h2><p>栈里面的元素在内存中是连续分布的么？这个问题有两个陷阱：</p>
<ul>
<li>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。（python用list实现栈时是连续的）</li>
<li>陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。</li>
</ul>
<p><strong>递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<h1 id="7-二叉树"><a href="#7-二叉树" class="headerlink" title="7. 二叉树"></a>7. 二叉树</h1><h2 id="7-1-理论基础"><a href="#7-1-理论基础" class="headerlink" title="7.1 理论基础"></a>7.1 理论基础</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>满二叉树：所以排序的过程的时间复杂度是 $O(\log k)$ ，整个算法的时间复杂度是 $O(n\log k)$ 。深度为k，有2^k-1个节点</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329298.png" alt="img" style="zoom:33%;" />

<p>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。<strong>堆就是一个完全二叉树。</strong><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329500.png" alt="img" style="zoom: 33%;" /></p>
<p>二叉搜索树：有数值，有序。下面这两棵树都是搜索树</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329473.png" alt="img" style="zoom:50%;" />

<p>平衡二叉搜索树：AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>如图：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329685.png" alt="img"></p>
<p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p>
<p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p>
<ul>
<li>正是高度差&lt;&#x3D;1，以及红黑树的规则，保证了O(logn)的复杂度</li>
</ul>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>链式存储方式就用指针， 顺序存储的方式就是用数组。顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。一般是用链式表示二叉树，有助于理解。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329706.png" alt="img" style="zoom:33%;" /><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111611874.png" alt="img" style="zoom: 33%;" /></p>
<p>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><ul>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。<ul>
<li>前序遍历（递归法，迭代法）中左右</li>
<li>中序遍历（递归法，迭代法）左中右</li>
<li>后序遍历（递归法，迭代法）左右中</li>
</ul>
</li>
<li>广度优先遍历：一层一层的去遍历。<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329809.png" alt="img" style="zoom:50%;" />

<p><strong>栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br></pre></td></tr></table></figure>

<h2 id="7-2-二叉树的递归遍历"><a href="#7-2-二叉树的递归遍历" class="headerlink" title="7.2 二叉树的递归遍历"></a>7.2 二叉树的递归遍历</h2><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 左右中</span></span><br><span class="line">        res = []<span class="comment"># 定义在外部函数中的局部变量</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#注意没有null，以及不要用==None，写is None</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">            res.append(node.val)<span class="comment"># 子函数可以访问并修改外部函数的变量 属于闭包</span></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-3-二叉树的迭代遍历"><a href="#7-3-二叉树的迭代遍历" class="headerlink" title="7.3 二叉树的迭代遍历"></a>7.3 二叉树的迭代遍历</h2><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，每次弹出来的加入res，然后将右孩子加入栈，再加入左孩子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="comment">#检查是否为空</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 中节点先处理</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="comment"># 右孩子先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="comment"># 左孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>中序遍历：需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        cur = root <span class="comment">#这里要先迭代到最底层的左子树节点，所以不能把root提前加进去</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment">#到达最左节点后逐步处理子树</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#else说明cur.left为空</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>后序遍历：因为第一个是中比较好处理，所以先得到中右左再反转，跟前序很像，就是先放左节点再放右节点</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329967.png" alt="前序到后序"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack.pop()</span><br><span class="line">            result.append(n.val)</span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                stack.append(n.left)</span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                stack.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p>
<p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p>
<h2 id="7-4-二叉树的统一迭代法"><a href="#7-4-二叉树的统一迭代法" class="headerlink" title="7.4 二叉树的统一迭代法"></a>7.4 二叉树的统一迭代法</h2><p>方法一：<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法可以叫做<code>空指针标记法</code>。这样当遇见空指针时，就应该pop出栈+加入result列表。什么时候加空？就是在当前处理的节点（中）后面加None。</p>
<p>先统一把root加进去，然后左中右的顺序因为是栈，反过来加入即可。要处理指只访问了，没有加入到结果集未处理的点。</p>
<p>前序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st= []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)<span class="comment">#中是当前处理的节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>中序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#添加右节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                st.append(node) <span class="comment">#添加中节点</span></span><br><span class="line">                st.append(<span class="literal">None</span>) <span class="comment">#中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#添加左节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                node = st.pop() <span class="comment">#重新取出栈中元素</span></span><br><span class="line">                result.append(node.val) <span class="comment">#加入到结果集</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>后序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>方法二：<strong>加一个 <code>boolean</code> 值跟随每个节点，<code>false</code> (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，<code>true</code> 表示该节点的位次之前已经安排过了，可以收割节点了。</strong> 这种方法可以叫做<code>boolean 标记法</code>，样例代码见下文<code>C++ 和 Python 的 boolean 标记法</code>。 这种方法更容易理解，在面试中更容易写出来。</p>
<p>还是一开始把root进栈，很好理解的visited数组，如果该节点和两个子节点都安排过了，就可以标为true，准备加入结果集了</p>
<p>前序：中左右</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> [] </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()      </span><br><span class="line">            <span class="keyword">if</span> visited: </span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node.right:<span class="comment">#右</span></span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            <span class="keyword">if</span> node.left:<span class="comment">#左</span></span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) </span><br><span class="line">            stack.append((node, <span class="literal">True</span>))<span class="comment">#中</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>中序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> [] </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()      </span><br><span class="line">            <span class="keyword">if</span> visited: </span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node.right:<span class="comment">#右</span></span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            stack.append((node, <span class="literal">True</span>))<span class="comment">#中</span></span><br><span class="line">            <span class="keyword">if</span> node.left:<span class="comment">#左</span></span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>后序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> [] <span class="comment"># 多加一个参数，False 为默认值</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop() <span class="comment"># 多加一个 visited 参数，使“迭代统一写法”成为一件简单的事</span></span><br><span class="line">            <span class="keyword">if</span> visited: <span class="comment"># visited 为 True，表示该节点和两个儿子位次之前已经安排过了，现在可以收割节点了</span></span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#这一轮循环过掉</span></span><br><span class="line">            <span class="comment"># visited 当前为 False, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次” 同时，设置 visited 为 True，表示下次再访问本节点时，允许收割。</span></span><br><span class="line">            stack.append((node, <span class="literal">True</span>)) <span class="comment">#中节点</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>)) <span class="comment"># 右儿子位置居中</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) <span class="comment"># 左儿子最后入栈，最先出栈</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="7-5-二叉树层序遍历"><a href="#7-5-二叉树层序遍历" class="headerlink" title="7.5 二叉树层序遍历"></a>7.5 二叉树层序遍历</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>栈先进后出适合模拟DFS，深度优先</p>
<p>队列先进先出适合模拟BFS，广度优先</p>
<p>难点是如何确定在某一层？用目前队列的长度len！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []<span class="comment">#当前层的内容，可看作子数组</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h3><p>自底向上的层序遍历，最后反转一下即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>取层序遍历的右值，即level[-1]，其实不需要像上面一样记录每层完整的level，只需要在i&#x3D;&#x3D;len(queue)-1时获取值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue) <span class="comment">#这里要记录，不然popleft后长度会变</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == level_size - <span class="number">1</span>:</span><br><span class="line">                    result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><p>就是把每层求累计再求平均</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level_sum = <span class="number">0</span> <span class="comment">#这里要记录，不然popleft后长度会变</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level_sum += cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level_sum / level_size)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h3><p>从2叉树变为n叉树，遍历每个节点的children即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> cur.children:</span><br><span class="line">                    queue.append(node)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h3><p>定义无穷小值然后去比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            max_ = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.val &gt; max_:</span><br><span class="line">                    max_ = cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(max_)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><p>保证是有两个子节点，仍然是遍历level进行指针的排列，最后一个节点指向null</p>
<p>我刚开始是先把同层节点都加入level，再遍历level进行连接，但其实不用额外的空间level存每层节点，遍历时用prev存即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []<span class="comment">#当前层的内容，可看作子数组</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(level)):</span><br><span class="line">                <span class="keyword">if</span> i != <span class="built_in">len</span>(level) - <span class="number">1</span>:</span><br><span class="line">                    level[i].<span class="built_in">next</span> = level[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    level[i].<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            prev = <span class="literal">None</span> <span class="comment">#存上一个节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> prev: </span><br><span class="line">                    prev.<span class="built_in">next</span> = cur</span><br><span class="line">                prev = cur <span class="comment">#最后一个节点自然不会有next</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h3><p>要求只能使用常量级的额外空间，上面的两种方法均符合，时间复杂度为O(n)，把树上的每个节点都遍历了</p>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>仍然用层序遍历看，最大深度就是二叉树的层数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>哪一层最先出现叶子节点，该层数就是最小深度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res += <span class="number">1</span> <span class="comment">#记录当前的层数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-6-翻转二叉树"><a href="#7-6-翻转二叉树" class="headerlink" title="7.6 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">7.6 翻转二叉树</a></h2><p>我使用的方法是迭代法的层序遍历，把每个节点的左右孩子翻转，用前中后序也是可以的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#存储未翻转的节点</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>递归法的前序遍历举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.left)</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-7-二叉树周末总结"><a href="#7-7-二叉树周末总结" class="headerlink" title="7.7 二叉树周末总结"></a>7.7 二叉树周末总结</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root: <span class="string">&#x27;Node&#x27;</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">                traverse(node)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root: <span class="string">&#x27;Node&#x27;</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">                traverse(node)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。</p>
<p>一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代</p>
<h2 id="7-8-对称二叉树"><a href="#7-8-对称二叉树" class="headerlink" title="7.8 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">7.8 对称二叉树</a></h2><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329159.png" alt="101. 对称二叉树1" style="zoom:50%;" />

<p>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。所以要用后序遍历。</p>
<p>递归三部曲</p>
<ol>
<li><p>确定递归函数的参数和返回值：bool</p>
</li>
<li><p>确定终止条件：</p>
<ol>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ol>
</li>
<li><p>确定单层递归的逻辑：</p>
<ol>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.compare(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#两个节点都不为空时</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#当前两个节点相等，就比较子节点的外侧和内侧</span></span><br><span class="line">        outside = <span class="variable language_">self</span>.compare(left.left, right.right)</span><br><span class="line">        inside = <span class="variable language_">self</span>.compare(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure>

<p>迭代法：我使用层序遍历获得level判断是否对称，但这样有额外的空间开销</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#收集每层的内容，反转数组一样</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)<span class="comment">#这里是代码随想录补充的剪枝，这样某一层是奇数个节点就不用看了，不是对称二叉树</span></span><br><span class="line">            <span class="keyword">if</span> level_size % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                    level.append(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                    level.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> level != level[::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>不适用level记录，直接根据终止条件获得左右子树节点然后判断的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left) <span class="comment">#将左子树头结点加入队列</span></span><br><span class="line">        queue.append(root.right) <span class="comment">#将右子树头结点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment">#接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            leftNode = queue.popleft()</span><br><span class="line">            rightNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode: <span class="comment">#左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#到这一步说明左右节点不为空且数值相同，可以比接下来的。注意加入顺序：先比外侧再比内侧，所以左左+右右一组/左右+右左一组</span></span><br><span class="line">            queue.append(leftNode.left) <span class="comment">#加入左节点左孩子</span></span><br><span class="line">            queue.append(rightNode.right) <span class="comment">#加入右节点右孩子</span></span><br><span class="line">            queue.append(leftNode.right) <span class="comment">#加入左节点右孩子</span></span><br><span class="line">            queue.append(rightNode.left) <span class="comment">#加入右节点左孩子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="7-9-二叉树的最大深度"><a href="#7-9-二叉树的最大深度" class="headerlink" title="7.9 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">7.9 二叉树的最大深度</a></h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<p>递归法：左右中：后序遍历，取最大值作为深度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l, r = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            l = <span class="variable language_">self</span>.maxDepth(root.left) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            r = <span class="variable language_">self</span>.maxDepth(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r)</span><br></pre></td></tr></table></figure>

<p>迭代法：用queue，每轮存一层的所有节点，层数就是深度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列的库</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):<span class="comment">#注意这里长度为len(queue)是最巧妙的</span></span><br><span class="line">                n = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    queue.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    queue.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></p>
<p>递归法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.children:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> root.children:</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="variable language_">self</span>.maxDepth(n))</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                n = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> n.children:</span><br><span class="line">                    <span class="keyword">for</span> node <span class="keyword">in</span> n.children:</span><br><span class="line">                        queue.append(node)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<h2 id="7-10-二叉树的最小深度"><a href="#7-10-二叉树的最小深度" class="headerlink" title="7.10 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">7.10 二叉树的最小深度</a></h2><p>难点在于左右孩子不为空的逻辑</p>
<p>可以设置正无穷，这样只有一边的节点时不会取默认值0，但测出来效率低</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">        l, r = <span class="built_in">float</span>(<span class="string">&#x27;+inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;+inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            l = <span class="variable language_">self</span>.minDepth(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            r = <span class="variable language_">self</span>.minDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(l, r) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>也可以老实写判断逻辑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDepth = <span class="variable language_">self</span>.minDepth(root.left)  <span class="comment"># 左</span></span><br><span class="line">        rightDepth = <span class="variable language_">self</span>.minDepth(root.right)  <span class="comment"># 右</span></span><br><span class="line">        <span class="comment"># 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line">        <span class="comment"># 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth</span><br><span class="line">        result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>迭代法就是层序遍历到第一个叶子节点就返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                n = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n.left <span class="keyword">and</span> <span class="keyword">not</span> n.right:</span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    queue.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    queue.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<h2 id="7-11-完全二叉树的节点个数"><a href="#7-11-完全二叉树的节点个数" class="headerlink" title="7.11 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">7.11 完全二叉树的节点个数</a></h2><p>求节点个数：O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.countNodes(root.left) + <span class="variable language_">self</span>.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>利用完全二叉树：只有两种情况</p>
<ul>
<li>一种是满二叉树：节点个数可以直接用2^树深度-1来计算</li>
<li>一种是最后一层叶子节点没有满，但递归到某一深度后一定会有左右孩子为满二叉树，用上式计算<ul>
<li>满二叉树的判断是左右子树的深度相等</li>
</ul>
</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329127.png" alt="img" style="zoom: 33%;" />

<p>这个情况无需考虑因为不是完全二叉树<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329182.png" alt="img" style="zoom:25%;" /></p>
<p>别看最后还是后序遍历的递归，但用满二叉树的公式计算左右子树是一种剪枝，节约了许多递归开销</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        leftDepth = <span class="number">0</span> <span class="comment">#这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        rightDepth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left: <span class="comment">#求左子树深度</span></span><br><span class="line">            left = left.left</span><br><span class="line">            leftDepth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right: <span class="comment">#求右子树深度</span></span><br><span class="line">            right = right.right</span><br><span class="line">            rightDepth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> leftDepth == rightDepth:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span> <span class="comment">#注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.countNodes(root.left) + <span class="variable language_">self</span>.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>或者把left&#x2F;right写在一个while里循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        left = root.left; right = root.right</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            left = left.left; right = right.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="comment"># 如果同时到底说明是满二叉树，反之则不是，剪枝</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;count)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="variable language_">self</span>.countNodes(root.left)+<span class="variable language_">self</span>.countNodes(root.right) </span><br></pre></td></tr></table></figure>

<h2 id="7-12-平衡二叉树"><a href="#7-12-平衡二叉树" class="headerlink" title="7.12 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">7.12 平衡二叉树</a></h2><p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的高度相差不超过 1。</p>
<ul>
<li>二叉树节点的深度：指从根节点到<strong>该节点</strong>的最长简单路径边的条数。用前序遍历，是层数</li>
<li>二叉树节点的高度：指从该节点到<strong>叶子节点</strong>的最长简单路径边的条数。用后序遍历，是倒数第几层</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329281.png" alt="110.平衡二叉树2" style="zoom:33%;" />

<p>我本来的算法把递归重复了两遍，其实没必要，因为getDepth的过程中就可以进行平衡二叉树的判断了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">root</span>) -&gt; <span class="built_in">int</span>:<span class="comment">#计算左右子树的高度.子函数要写在前面，不然，不然访问不到，认为根节点为0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(getHeight(root.left), getHeight(root.right)) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        l = getHeight(root.left) + <span class="number">1</span></span><br><span class="line">        r = getHeight(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.isBalanced(root.right) <span class="keyword">and</span> <span class="variable language_">self</span>.isBalanced(root.left)</span><br></pre></td></tr></table></figure>

<p>定义getHeight依然返回高度，如果不是平衡二叉树就返回-1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">root</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            l = getHeight(root.left)</span><br><span class="line">            r = getHeight(root.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span> <span class="keyword">or</span> l == -<span class="number">1</span> <span class="keyword">or</span> r == -<span class="number">1</span>:<span class="comment">#这里记得判断l/r是否为-1，会覆盖左右子树不满足平衡的情况</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> getHeight(root) == -<span class="number">1</span> <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>此题用迭代法效率很低，虽然理论上所有递归都可以迭代实现，但这里需要遍历每个节点然后计算当前节点左右子树的高度，没细看感觉很麻烦</p>
<h2 id="7-13-二叉树的所有路径"><a href="#7-13-二叉树的所有路径" class="headerlink" title="7.13 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">7.13 二叉树的所有路径</a></h2><p>从根节点到叶子节点：前序遍历（中左右）递归+回溯</p>
<p>递归法+回溯：回溯这里的path.pop()是关键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur, path, result</span>):</span><br><span class="line">            path.append(cur.val)  <span class="comment"># 中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:  <span class="comment"># 到达叶子节点</span></span><br><span class="line">                sPath = <span class="string">&#x27;-&gt;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, path)) <span class="comment">#把访问到的节点的值都连接起来</span></span><br><span class="line">                result.append(sPath)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:  <span class="comment"># 左</span></span><br><span class="line">                <span class="variable language_">self</span>.traversal(cur.left, path, result)</span><br><span class="line">                path.pop()  <span class="comment"># 回溯</span></span><br><span class="line">            <span class="keyword">if</span> cur.right:  <span class="comment"># 右</span></span><br><span class="line">                <span class="variable language_">self</span>.traversal(cur.right, path, result)</span><br><span class="line">                path.pop()  <span class="comment"># 回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root</span>):</span><br><span class="line">            result = [] <span class="comment">#存路径结果</span></span><br><span class="line">            path = [] <span class="comment">#存每个节点的值</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="variable language_">self</span>.traversal(root, path, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>迭代法：刚开始我用stack不知道如何实现，发现答案用path_st存储遍历到每个节点的路径，而不是仅用一个res保存当前的访问</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment">#需要深度优先搜索，前序遍历（中左右），用栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        path_st = [<span class="built_in">str</span>(root.val)]<span class="comment">#存储遍历到每个节点时的路径</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack.pop()</span><br><span class="line">            path = path_st.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n.left <span class="keyword">and</span> <span class="keyword">not</span> n.right:</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">if</span> n.right:<span class="comment">#因为是栈先进右值</span></span><br><span class="line">                stack.append(n.right)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(n.right.val))<span class="comment">#是下一步的内容</span></span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                stack.append(n.left)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(n.left.val))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-14-二叉树周末总结"><a href="#7-14-二叉树周末总结" class="headerlink" title="7.14 二叉树周末总结"></a>7.14 二叉树周末总结</h2><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">node1: <span class="type">Optional</span>[TreeNode], node2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">if</span> node1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> isSame(node1.left, node2.left) <span class="keyword">and</span> isSame(node1.right, node2.right)<span class="comment">#这里isSame不是self的方法，所以调用不用写self.</span></span><br><span class="line">        <span class="keyword">return</span> isSame(p, q)</span><br></pre></td></tr></table></figure>

<h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><p>注意判断子树的节点和root主树是否为空</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubtree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], subRoot: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isSame</span>(<span class="params">node1: <span class="type">Optional</span>[TreeNode], node2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">and</span> <span class="keyword">not</span> node2:  <span class="comment"># 两个都是 None，匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">or</span> <span class="keyword">not</span> node2:   <span class="comment"># 一个 None，另一个非 None，不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                node1.val == node2.val</span><br><span class="line">                <span class="keyword">and</span> isSame(node1.left, node2.left)</span><br><span class="line">                <span class="keyword">and</span> isSame(node1.right, node2.right)</span><br><span class="line">            )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> subRoot:  <span class="comment"># 空树是任何树的子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:     <span class="comment"># 主树为空，子树非空，不匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查当前树是否匹配，或者左/右子树是否包含 subRoot</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            isSame(root, subRoot)</span><br><span class="line">            <span class="keyword">or</span> <span class="variable language_">self</span>.isSubtree(root.left, subRoot)</span><br><span class="line">            <span class="keyword">or</span> <span class="variable language_">self</span>.isSubtree(root.right, subRoot)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h2 id="7-15-左叶子之和"><a href="#7-15-左叶子之和" class="headerlink" title="7.15 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">7.15 左叶子之和</a></h2><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
<ul>
<li>注意只加左边的叶子节点，非叶子节点不加</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="variable language_">self</span>.res = <span class="number">0</span> <span class="comment">#定义成实例变量，这样都可以访问</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.left.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.left.right <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#注意要是叶子节点</span></span><br><span class="line">                <span class="variable language_">self</span>.res += node.left.val </span><br><span class="line">            <span class="built_in">sum</span>(node.left)</span><br><span class="line">            <span class="built_in">sum</span>(node.right)</span><br><span class="line">        <span class="built_in">sum</span>(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>后面发现这道题也没必要另外定义一个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span> <span class="comment">#定义成实例变量，这样都可以访问</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.left.right <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#注意要是叶子节点</span></span><br><span class="line">            res += root.left.val </span><br><span class="line">        <span class="keyword">return</span> res + <span class="variable language_">self</span>.sumOfLeftLeaves(root.left) + <span class="variable language_">self</span>.sumOfLeftLeaves(root.right)</span><br></pre></td></tr></table></figure>

<h2 id="7-16-找树左下角的值"><a href="#7-16-找树左下角的值" class="headerlink" title="7.16 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">7.16 找树左下角的值</a></h2><p>用迭代很好理解，递归没看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: <span class="comment">#我本来在这里判断是否为叶子节点，但这样有误，不知道后面有没有新的层</span></span><br><span class="line">                    res = node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res <span class="comment">#最后一次赋值一定是叶子节点</span></span><br></pre></td></tr></table></figure>

<h2 id="7-17-路径总和"><a href="#7-17-路径总和" class="headerlink" title="7.17 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">7.17 路径总和</a></h2><p>判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。也是典型的回溯+dfs</p>
<p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要<strong>搜索其中一条符合条件的路径</strong>，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
<p>其实不一定要回溯，因为路径是连续的不会断掉：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> <span class="variable language_">self</span>.hasPathSum(root.right, targetSum - root.val)</span><br></pre></td></tr></table></figure>

<p>回溯：这里要<strong>搜索其中一条符合条件的路径</strong>，所以递归返回的是bool。path+这里体现的就是回溯，因为没有直接改变path</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.dfs(root, targetSum, [root.val])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, root, target, path</span>):<span class="comment">#path记录目前选择的节点值，用数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(path) == target <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:<span class="comment">#满足从根节点到叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        left_flag, right_flag = <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            left_flag = <span class="variable language_">self</span>.dfs(root.left, target, path + [root.left.val])</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            right_flag = <span class="variable language_">self</span>.dfs(root.right, target, path + [root.right.val])</span><br><span class="line">        <span class="keyword">return</span> left_flag <span class="keyword">or</span> right_flag</span><br></pre></td></tr></table></figure>

<p>也可以写成：看剩余的count，这里没用path作为中间值存储，所以count要先减再加（选左或者选右，不能同时选）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur: TreeNode, count: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> count == <span class="number">0</span>: <span class="comment"># 遇到叶子节点，并且计数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right: <span class="comment"># 遇到叶子节点直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cur.left: <span class="comment"># 左</span></span><br><span class="line">            count -= cur.left.val</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.traversal(cur.left, count): <span class="comment"># 递归，处理节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            count += cur.left.val <span class="comment"># 回溯，撤销处理结果</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> cur.right: <span class="comment"># 右</span></span><br><span class="line">            count -= cur.right.val</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.traversal(cur.right, count): <span class="comment"># 递归，处理节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            count += cur.right.val <span class="comment"># 回溯，撤销处理结果</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.traversal(root, targetSum - root.val)</span><br></pre></td></tr></table></figure>

<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>和上面相比就是要把满足条件的记录下来，就不能写简单的递归了，用dfs</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.traversal(root, targetSum, [])</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, root, target, path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        path.append(root.val)<span class="comment">#选这个点</span></span><br><span class="line">        <span class="comment">#以下是选择该点的处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(path) == target <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="comment">#self.res.append(list(path))这样写也可以，也是创建一个全新副本</span></span><br><span class="line">            <span class="variable language_">self</span>.res.append(path.copy())<span class="comment">#注意不能直接添加path！不然添加的是引用（内存地址），最后结果就是[]</span></span><br><span class="line">        <span class="variable language_">self</span>.traversal(root.left, target, path)</span><br><span class="line">        <span class="variable language_">self</span>.traversal(root.right, target, path)</span><br><span class="line">        <span class="comment">#回溯，不选这个点</span></span><br><span class="line">        path.pop()</span><br></pre></td></tr></table></figure>

<h2 id="7-18-从中序与后序遍历序列构造二叉树"><a href="#7-18-从中序与后序遍历序列构造二叉树" class="headerlink" title="7.18 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">7.18 从中序与后序遍历序列构造二叉树</a></h2><p>重点是如何切割和找边界值</p>
<ul>
<li>中序数组用root切割</li>
<li>后序数组用左中序数组的大小切割（因为都是左开始）</li>
<li>得到左子树和右子树的中序和后序后，就可以递归了</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:<span class="comment">#不然下面取-1就会报错了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(root_val)</span><br><span class="line">        <span class="comment">#切割中序数组</span></span><br><span class="line">        idx = inorder.index(root_val)</span><br><span class="line">        inorder_left = inorder[:idx]</span><br><span class="line">        inorder_right = inorder[idx + <span class="number">1</span>:]</span><br><span class="line">        <span class="comment">#切割后序数组</span></span><br><span class="line">        postorder_left = postorder[:<span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left):<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">        root.left = <span class="variable language_">self</span>.buildTree(inorder_left, postorder_left)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.buildTree(inorder_right, postorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment">#前序：中左右 #中序：左中右</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:  <span class="comment"># 空节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left_size = inorder.index(preorder[<span class="number">0</span>])  <span class="comment"># 左子树的大小</span></span><br><span class="line">        left = <span class="variable language_">self</span>.buildTree(preorder[<span class="number">1</span>: <span class="number">1</span> + left_size], inorder[:left_size])</span><br><span class="line">        right = <span class="variable language_">self</span>.buildTree(preorder[<span class="number">1</span> + left_size:], inorder[<span class="number">1</span> + left_size:])</span><br><span class="line">        <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>], left, right)</span><br></pre></td></tr></table></figure>

<p>前序和中序、中序和后序可以唯一确定一棵二叉树，但前序和后序不能唯一确定二叉树</p>
<h2 id="7-19-最大二叉树"><a href="#7-19-最大二叉树" class="headerlink" title="7.19 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">7.19 最大二叉树</a></h2><p>使用切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = <span class="built_in">max</span>(nums)</span><br><span class="line">        idx = nums.index(root)</span><br><span class="line">        <span class="keyword">return</span> TreeNode(root, </span><br><span class="line">                        <span class="variable language_">self</span>.constructMaximumBinaryTree(nums[:idx]),</span><br><span class="line">                        <span class="variable language_">self</span>.constructMaximumBinaryTree(nums[idx + <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>

<h2 id="7-20-二叉树周末总结"><a href="#7-20-二叉树周末总结" class="headerlink" title="7.20 二叉树周末总结"></a>7.20 二叉树周末总结</h2><p>切片的题还是比较简单的，我对回溯不太熟练</p>
<h2 id="7-21-合并二叉树"><a href="#7-21-合并二叉树" class="headerlink" title="7.21 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">7.21 合并二叉树</a></h2><p>我的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">if</span> root2 <span class="keyword">and</span> <span class="keyword">not</span> root1:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(root1.val + root2.val)</span><br><span class="line">        root.left = <span class="variable language_">self</span>.mergeTrees(root1.left, root2.left)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.mergeTrees(root1.right, root2.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>简洁写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1: </span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root2: </span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line">        root1.val += root2.val <span class="comment"># 中</span></span><br><span class="line">        root1.left = <span class="variable language_">self</span>.mergeTrees(root1.left, root2.left) <span class="comment">#左</span></span><br><span class="line">        root1.right = <span class="variable language_">self</span>.mergeTrees(root1.right, root2.right) <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">return</span> root1 </span><br></pre></td></tr></table></figure>

<h2 id="7-22-二叉搜索树中的搜索"><a href="#7-22-二叉搜索树中的搜索" class="headerlink" title="7.22 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">7.22 二叉搜索树中的搜索</a></h2><p>首先是一个我的错误写法：找到目标节点后没有立即返回，如果不加return就相当于遍历整棵树了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.searchBST(root.left, val)</span><br><span class="line">            <span class="variable language_">self</span>.searchBST(root.right, val)</span><br></pre></td></tr></table></figure>

<p>利用二叉搜索树右子树大于root，左子树小于root的性质</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.searchBST(root.left, val)</span><br></pre></td></tr></table></figure>

<p>迭代法也很简单好理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val &lt; root.val: root = root.left</span><br><span class="line">            <span class="keyword">elif</span> val &gt; root.val: root = root.right</span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="7-23-验证二叉搜索树"><a href="#7-23-验证二叉搜索树" class="headerlink" title="7.23 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">7.23 验证二叉搜索树</a></h2><p>首先是我的错误写法：只检查了<strong>当前节点与其直接子节点的关系</strong>，而没有保证<strong>整个左子树是否都小于当前节点，或者整个右子树是否都大于当前节点</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.left.val &gt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">and</span> root.right.val &lt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.isValidBST(root.left) <span class="keyword">and</span> <span class="variable language_">self</span>.isValidBST(root.right)</span><br></pre></td></tr></table></figure>

<p>正确写法：引入min&#x2F;max表示整个子树的上界和下界</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], left=-inf, right=inf</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        x = root.val</span><br><span class="line">        <span class="keyword">return</span> left &lt; x &lt; right <span class="keyword">and</span> <span class="variable language_">self</span>.isValidBST(root.left, left, x) <span class="keyword">and</span> <span class="variable language_">self</span>.isValidBST(root.right, x, right)</span><br></pre></td></tr></table></figure>

<h2 id="7-24-二叉搜索树的最小绝对差"><a href="#7-24-二叉搜索树的最小绝对差" class="headerlink" title="7.24 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">7.24 二叉搜索树的最小绝对差</a></h2><p>二叉搜索树一定有左边&lt;root&lt;右边，中序遍历是升序的，最小查值一定出现在中序遍历时相邻的两个数之间，所以用prev记录前一个节点的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        min_diff = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node</span>): <span class="comment">#中序遍历</span></span><br><span class="line">            <span class="keyword">nonlocal</span> prev, min_diff <span class="comment"># 用nonlocal访问外部数据（self/传参数也可以）</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(node.left)  <span class="comment"># 遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> prev <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="comment"># 不为空时，计算当前节点和前一个节点的查值</span></span><br><span class="line">                min_diff = <span class="built_in">min</span>(min_diff, <span class="built_in">abs</span>(node.val - prev))</span><br><span class="line">            prev = node.val  <span class="comment"># 更新前驱节点</span></span><br><span class="line">            inorder(node.right)  <span class="comment"># 遍历右子树</span></span><br><span class="line">        </span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> min_diff</span><br></pre></td></tr></table></figure>

<h2 id="7-25-二叉搜索树中的众数"><a href="#7-25-二叉搜索树中的众数" class="headerlink" title="7.25 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">7.25 二叉搜索树中的众数</a></h2><p>众数：出现频率最高的数</p>
<p>如果不是BST，就遍历，然后用map统计频率，将频率排序，最后返回最高频元素的集合</p>
<p>是BST，那中序遍历就是有序的，用pre和cur计数，然后因为可能不止一个，要返回集合，所以用列表存储</p>
<p>假设可以使用额外空间，简单，用map统计</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">self, cur, freq_map</span>):</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        freq_map[cur.val] += <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.searchBST(cur.left, freq_map)</span><br><span class="line">        <span class="variable language_">self</span>.searchBST(cur.right, freq_map)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        freq_map = defaultdict(<span class="built_in">int</span>)  <span class="comment"># key:元素，value:出现频率，可以为不存在的key提供默认值，防止keyerror</span></span><br><span class="line">        result = [] <span class="comment"># 结果集合</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="variable language_">self</span>.searchBST(root, freq_map) <span class="comment"># 记录每个元素的出现频率</span></span><br><span class="line">        max_freq = <span class="built_in">max</span>(freq_map.values()) <span class="comment"># 最大的频率 value</span></span><br><span class="line">        <span class="keyword">for</span> key, freq <span class="keyword">in</span> freq_map.items(): <span class="comment"># 遍历找对应的key</span></span><br><span class="line">            <span class="keyword">if</span> freq == max_freq:</span><br><span class="line">                result.append(key)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>不适用额外空间：中序遍历，其中技术的步骤在处理当前节点中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="variable language_">self</span>.result = []</span><br><span class="line">        <span class="variable language_">self</span>.maxCount = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span> <span class="comment"># 当前节点的出现次数</span></span><br><span class="line">        <span class="variable language_">self</span>.pre = <span class="literal">None</span> <span class="comment"># 上一个节点，中序遍历相邻</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">searchBST</span>(<span class="params">cur: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            searchBST(cur.left)</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.pre <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#说明是中序遍历的第一个节点</span></span><br><span class="line">                <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="variable language_">self</span>.pre.val == cur.val:<span class="comment"># 与前一个节点数值相同</span></span><br><span class="line">                <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 与前一个节点数值不同</span></span><br><span class="line">                <span class="variable language_">self</span>.count = <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>.pre = cur</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.count == <span class="variable language_">self</span>.maxCount: <span class="comment">#每遍历一个数都要比较</span></span><br><span class="line">                <span class="variable language_">self</span>.result.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.count &gt; <span class="variable language_">self</span>.maxCount:</span><br><span class="line">                <span class="variable language_">self</span>.maxCount = <span class="variable language_">self</span>.count</span><br><span class="line">                <span class="variable language_">self</span>.result = [cur.val] <span class="comment">#旧列表会被垃圾回收自动释放，不用担心浪费空间</span></span><br><span class="line">            </span><br><span class="line">            searchBST(cur.right)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        searchBST(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.result</span><br></pre></td></tr></table></figure>

<h2 id="7-26-二叉树的最近公共祖先"><a href="#7-26-二叉树的最近公共祖先" class="headerlink" title="7.26 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">7.26 二叉树的最近公共祖先</a></h2><p>如果pq不在在同一侧子树中，不然最近公共节点就是root</p>
<p>左右中：<strong>后序遍历</strong>，是天然的回溯，自底向上查找，如果找到就返回</p>
<p>为什么要遍历整棵树？因为如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == q <span class="keyword">or</span> root == p: <span class="keyword">return</span> root <span class="comment"># 感觉终止条件最重要</span></span><br><span class="line">        left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="7-27-周末总结"><a href="#7-27-周末总结" class="headerlink" title="7.27 周末总结"></a>7.27 周末总结</h2><p>BST注意是全局的性质，有时不能只比相邻节点；然后中序遍历是有序数组很重要，结合prev&#x2F;cur进行中序遍历即可完成一些有序的任务</p>
<p>平衡二叉搜索树是不是二叉搜索树和平衡二叉树的结合？<strong>平衡二叉树</strong> 是指该树所有节点的左右子树的高度相差不超过 1。</p>
<ul>
<li>是的，是二叉搜索树和平衡二叉树的结合。</li>
</ul>
<p>平衡二叉树与完全二叉树的区别在于底层节点的位置？</p>
<ul>
<li>是的，完全二叉树底层必须是从左到右连续的，且次底层是满的（像一层一层铺砖，不能跳过任何位置）</li>
</ul>
<p>堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？</p>
<ul>
<li>堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 <strong>但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树</strong>。</li>
</ul>
<h2 id="7-28-二叉搜索树的最近公共祖先"><a href="#7-28-二叉搜索树的最近公共祖先" class="headerlink" title="7.28 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">7.28 二叉搜索树的最近公共祖先</a></h2><p>首先把二叉树的答案默写了一遍，当然是能过的，但这里是二叉搜索树，我想到的是可以多剪枝一下：把p&#x2F;q和root做比较</p>
<p>我写的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val &lt; q.val <span class="keyword">or</span> q.val &lt; root.val &lt; p.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val: <span class="comment"># 都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val: <span class="comment"># 都在右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br></pre></td></tr></table></figure>

<p>但其实可以观察到除了左右子树的情况其他都是return root，只是我分类讨论了，精简版的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val: <span class="comment"># 都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-29-二叉搜索树中的插入操作"><a href="#7-29-二叉搜索树中的插入操作" class="headerlink" title="7.29 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">7.29 二叉搜索树中的插入操作</a></h2><p>把一个节点插入：刚开始想的很复杂，要调整二叉树结构，但其实遍历二叉搜索树，找到空节点 插入元素就可以了。就是找到空位就行，符合大小规律。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val: <span class="comment">#注意这里针对root处理，保证节点能正确加入</span></span><br><span class="line">            root.left = <span class="variable language_">self</span>.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root.right = <span class="variable language_">self</span>.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-30-删除二叉搜索树中的节点"><a href="#7-30-删除二叉搜索树中的节点" class="headerlink" title="7.30 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">7.30 删除二叉搜索树中的节点</a></h2><p>如果该节点同时有左右节点：这个比较复杂，要找左子树最大&#x2F;右子树最小进行覆盖</p>
<p>如果该节点只有一个子节点，那就用那一个子节点覆盖</p>
<p>如果没有子节点，直接删除</p>
<p>这里的递归注意也是和上一题一样赋值给root.left&#x2F;root.right，保证整棵树的更新</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key: <span class="comment"># 注意这里更新后的节点会自动赋值给父节点，不用担心父子节点对不上号</span></span><br><span class="line">            root.right = <span class="variable language_">self</span>.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left = <span class="variable language_">self</span>.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 已经找到了相等的节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right: <span class="comment">#没有子节点，直接删除</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment">#同时有左右节点，用右子树的最小来覆盖root，把左子树赋给该节点。1.找到cur，覆盖root，2.把cur原来的位置删掉，这里简单的方法是还是root，只覆盖值，这样left不变，变right</span></span><br><span class="line">            cur = root.right</span><br><span class="line">            <span class="keyword">while</span> cur.left:</span><br><span class="line">                cur = cur.left <span class="comment">#下面几行找到root/cur后的处理是最细节的</span></span><br><span class="line">            root.val = cur.val </span><br><span class="line">            root.right = <span class="variable language_">self</span>.deleteNode(root.right, cur.val)</span><br><span class="line">            <span class="comment"># return root 下面就有，不用写了 </span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-31-修剪二叉搜索树"><a href="#7-31-修剪二叉搜索树" class="headerlink" title="7.31 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">7.31 修剪二叉搜索树</a></h2><p>不在范围内的节点要删除，有唯一答案</p>
<p>如果root.val&gt;&#x3D;low，那肯定有root.right.val &gt;&#x3D; low，只需要看root.right.val &lt;&#x3D; high</p>
<ul>
<li>如果root.val &lt; low，那root+整个左子树可以删除，用右子树第一个满足范围的节点替代（这里有错！因为右子树可能还有其他点不满足范围，不能直接就return了，要继续递归）</li>
</ul>
<p>如果root.val&lt;&#x3D;high，那肯定有root.left.val &lt;&#x3D; high，只需要看root.left.val &gt;&#x3D; low</p>
<ul>
<li>如果root.val &gt; high，那root+整个右子树可以删除</li>
</ul>
<p>我的错误写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> low &lt;= root.val &lt;= high: </span><br><span class="line">            root.right = <span class="variable language_">self</span>.trimBST(root.right, low, high)</span><br><span class="line">            root.left = <span class="variable language_">self</span>.trimBST(root.left, low, high)</span><br><span class="line">        <span class="keyword">if</span> low &gt; root.val:</span><br><span class="line">            <span class="keyword">while</span> root <span class="keyword">and</span> root.val &lt; low:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">return</span> root <span class="comment"># 这里不能直接return了，不然右子树没有继续递归</span></span><br><span class="line">        <span class="keyword">if</span> high &lt; root.val:</span><br><span class="line">            <span class="keyword">while</span> root <span class="keyword">and</span> root.val &gt; high:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>正确写法是继续递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">            <span class="comment"># 当前节点太小，修剪右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; high:</span><br><span class="line">            <span class="comment"># 当前节点太大，修剪左子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.trimBST(root.left, low, high)</span><br><span class="line">        <span class="comment"># 当前节点在范围内，递归修剪左右子树</span></span><br><span class="line">        root.left = <span class="variable language_">self</span>.trimBST(root.left, low, high)</span><br><span class="line">        root.right = <span class="variable language_">self</span>.trimBST(root.right, low, high)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-32-将有序数组转换为二叉搜索树"><a href="#7-32-将有序数组转换为二叉搜索树" class="headerlink" title="7.32 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">7.32 将有序数组转换为二叉搜索树</a></h2><p>中间值是root，分割两边的数组，递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        idx = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[idx])</span><br><span class="line">        root.left = <span class="variable language_">self</span>.sortedArrayToBST(nums[: idx])</span><br><span class="line">        root.right = <span class="variable language_">self</span>.sortedArrayToBST(nums[idx + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-33-把二叉搜索树转换为累加树"><a href="#7-33-把二叉搜索树转换为累加树" class="headerlink" title="7.33 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">7.33 把二叉搜索树转换为累加树</a></h2><p>就是一个有序数组，<strong>求从后到前的累加数组</strong>，累加顺序是右中左（反中序遍历）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        s = <span class="number">0</span> <span class="comment"># 记录目前的累加和</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.right)  <span class="comment"># 递归右子树</span></span><br><span class="line">            <span class="comment"># 递归结束后，s 就等于右子树的所有节点值之和</span></span><br><span class="line">            <span class="keyword">nonlocal</span> s</span><br><span class="line">            s += node.val</span><br><span class="line">            node.val = s  <span class="comment"># 此时 s 就是右子树和自己的和</span></span><br><span class="line">            dfs(node.left)  <span class="comment"># 递归左子树</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-34-二叉树：总结篇"><a href="#7-34-二叉树：总结篇" class="headerlink" title="7.34 二叉树：总结篇"></a>7.34 二叉树：总结篇</h2><p>深度：从上到下 高度：从下到上</p>
<ul>
<li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li>
<li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。不过这个类型比较多。</li>
<li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li>
</ul>
<h1 id="8-回溯算法"><a href="#8-回溯算法" class="headerlink" title="8. 回溯算法"></a>8. 回溯算法</h1><h2 id="8-1-回溯算法理论基础"><a href="#8-1-回溯算法理论基础" class="headerlink" title="8.1 回溯算法理论基础"></a>8.1 回溯算法理论基础</h2><p><strong>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。并不是很高效。</p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
<p><strong>回溯法解决的问题都可以抽象为树形结构</strong>（N叉树），因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p>
<p><img src="https://file.kamacoder.com/pics/20210130173631174.png" alt="回溯算法理论基础"></p>
<p><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-组合"><a href="#8-2-组合" class="headerlink" title="8.2 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">8.2 组合</a></h2><p>[1,n]中所有可能的k个数的组合</p>
<p>我的代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = [] <span class="comment"># 存储最终的结果</span></span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 存储当前选择的数</span></span><br><span class="line">        <span class="variable language_">self</span>.num = [] <span class="comment"># [1, n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.num.append(i)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">k: <span class="built_in">int</span>, start: <span class="built_in">int</span></span>): <span class="comment"># start表示从哪个数开始选择</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == k:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy()) <span class="comment"># 注意要浅拷贝，或者写成self.cur[:]也可以</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.num[start:]):<span class="comment"># 不能重复选择元素</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(n)</span><br><span class="line">                backtracking(k, i + start + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur = <span class="variable language_">self</span>.cur[:-<span class="number">1</span>] <span class="comment"># 去掉该节点</span></span><br><span class="line">        backtracking(k, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>可以优化的地方：</p>
<ol>
<li>用pop撤销节点</li>
<li>num数组不用创建，用startindex记录当前遍历到哪个数字了即可</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = [] <span class="comment"># 存储最终的结果</span></span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 存储当前选择的数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">k: <span class="built_in">int</span>, start: <span class="built_in">int</span></span>): <span class="comment"># start表示从哪个数开始选择</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == k:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy()) <span class="comment"># 注意要浅拷贝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n + <span class="number">1</span>):<span class="comment"># 不能重复选择元素</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(i)</span><br><span class="line">                backtracking(k, i + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop() <span class="comment"># 去掉该节点</span></span><br><span class="line">        backtracking(k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-3-组合（优化）"><a href="#8-3-组合（优化）" class="headerlink" title="8.3 组合（优化）"></a>8.3 组合（优化）</h2><p>剪枝：很多情况下继续遍历是没有意义的，因为剩下的数字不足以构成一个长度为k的组合。</p>
<ul>
<li><code>k - len(path)</code>：还需要选择的数字个数。</li>
<li><code>n - (k - len(path)) + 1</code>：最大的起始点，确保从<code>i</code>开始至少还有<code>k - len(path)</code>个数字可供选择。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = [] <span class="comment"># 存储最终的结果</span></span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 存储当前选择的数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">k: <span class="built_in">int</span>, start: <span class="built_in">int</span></span>): <span class="comment"># start表示从哪个数开始选择</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == k:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy()) <span class="comment"># 注意要浅拷贝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n - (k - <span class="built_in">len</span>(<span class="variable language_">self</span>.cur)) + <span class="number">2</span>):<span class="comment"># 不能重复选择元素</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(i)</span><br><span class="line">                backtracking(k, i + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop() <span class="comment"># 去掉该节点</span></span><br><span class="line">        backtracking(k, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>注意for循环是惰性对的，只进入for时计算一次，之后即使self.cur在递归中被修改，也不会重复计算</p>
<h2 id="8-4-组合总和-III"><a href="#8-4-组合总和-III" class="headerlink" title="8.4 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">8.4 组合总和 III</a></h2><p>刚开始照着上面的模板写会超时，加了剪枝后通过</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = [] <span class="comment"># 存储最终的结果</span></span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 存储当前选择的数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">k: <span class="built_in">int</span>, n: <span class="built_in">int</span>, start: <span class="built_in">int</span></span>): <span class="comment"># start表示从哪个数开始选择</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) == n <span class="keyword">and</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == k:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy()) <span class="comment"># 注意要浅拷贝</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt;= n <span class="keyword">or</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) &gt;= k: <span class="comment"># 这里要加剪枝，不然会超时</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="number">11</span> - (k - <span class="built_in">len</span>(<span class="variable language_">self</span>.cur))):<span class="comment"># 不能重复选择元素</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(i)</span><br><span class="line">                backtracking(k, n, i + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop() <span class="comment"># 去掉该节点</span></span><br><span class="line">        backtracking(k, n, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-5-电话号码的字母组合"><a href="#8-5-电话号码的字母组合" class="headerlink" title="8.5 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">8.5 电话号码的字母组合</a></h2><p>hot100时的答案：简短但省略了添加和回溯撤销的操作，下标也用数组划分代替了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        phone = &#123;<span class="string">&#x27;2&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;3&#x27;</span>:[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;4&#x27;</span>:[<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;5&#x27;</span>:[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;6&#x27;</span>:[<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;7&#x27;</span>:[<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;8&#x27;</span>:[<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;9&#x27;</span>:[<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]&#125;<span class="comment">#创建dict</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">conbination, nextdigit</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nextdigit) == <span class="number">0</span>:</span><br><span class="line">                res.append(conbination)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phone[nextdigit[<span class="number">0</span>]]:</span><br><span class="line">                    backtrack(conbination + letter,nextdigit[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="string">&#x27;&#x27;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> res    </span><br></pre></td></tr></table></figure>

<p>更好理解的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="variable language_">self</span>.phone = &#123;<span class="string">&#x27;2&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;3&#x27;</span>:[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;4&#x27;</span>:[<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;5&#x27;</span>:[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;6&#x27;</span>:[<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;7&#x27;</span>:[<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;8&#x27;</span>:[<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;9&#x27;</span>:[<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]&#125; <span class="comment"># 创建dict</span></span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">digits: <span class="built_in">str</span>, start: <span class="built_in">int</span></span>): <span class="comment"># start表示现在在选digit哪个位</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="built_in">len</span>(digits):</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            digit = digits[start]</span><br><span class="line">            letters = <span class="variable language_">self</span>.phone[digit]</span><br><span class="line">            <span class="keyword">for</span> letter <span class="keyword">in</span> letters:</span><br><span class="line">                <span class="variable language_">self</span>.cur += letter</span><br><span class="line">                backtracking(digits, start + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur = <span class="variable language_">self</span>.cur[:-<span class="number">1</span>] <span class="comment"># 字符串不能进行pop/-操作 </span></span><br><span class="line">        backtracking(digits, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-6-回溯周末总结"><a href="#8-6-回溯周末总结" class="headerlink" title="8.6 回溯周末总结"></a>8.6 回溯周末总结</h2><p><strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。</p>
<h2 id="8-7-组合总和"><a href="#8-7-组合总和" class="headerlink" title="8.7 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">8.7 组合总和</a></h2><p>首先写了一版代码，但没有去重，会有[3,5],[5,3]结果同时出现在res里。所以在加入res时加了Counter的比较操作，刚开始只比较counter是超时的，后来加了比较len的就不超时了（还跟我每次用sum求和有关，如果用一个变量记录和计算开销会少一些）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 可以重复选数字</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) == target:</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="variable language_">self</span>.res:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) <span class="keyword">and</span> Counter(l) == Counter(<span class="variable language_">self</span>.cur):</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> candidates:</span><br><span class="line">                <span class="variable language_">self</span>.cur.append(n)</span><br><span class="line">                backtracking(candidates, target)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(candidates, target)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>其实应该用startIndex防止重复，不应该从0开始而应该从i开始</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 可以重复选数字</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, startIndex: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) == target:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="variable language_">self</span>.cur.append(candidates[i])</span><br><span class="line">                backtracking(candidates, target, i)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>进一步剪枝：把candidates排序，这样如果当前循环和超过target了，后面都不用看了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 可以重复选数字</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, startIndex: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) == target:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) + candidates[i] &gt; target:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(candidates[i])</span><br><span class="line">                backtracking(candidates, target, i)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        candidates.sort()</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-8-组合总和-II"><a href="#8-8-组合总和-II" class="headerlink" title="8.8 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">8.8 组合总和 II</a></h2><p>和上一题相比只能使用一次，感觉去重那里没处理好，下面是错误的写法（面对全1数组会超时）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, startIndex: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) == target:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> candidates[i] + <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt; target:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(candidates[i])</span><br><span class="line">                backtracking(candidates, target, i + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 进行数组去重</span></span><br><span class="line">        unique_arr = []</span><br><span class="line">        <span class="keyword">for</span> sub <span class="keyword">in</span> <span class="variable language_">self</span>.res:</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">not</span> <span class="keyword">in</span> unique_arr:</span><br><span class="line">                unique_arr.append(sub)</span><br><span class="line">        <span class="keyword">return</span> unique_arr</span><br></pre></td></tr></table></figure>

<p>理论上应该与前一个数比较，但第一次尝试时是可以重复的，不知道该怎么写</p>
<p>要在搜索过程中去重，同一个树枝无所谓，但同一个树层要去重，方法是用used bool数组，但我觉得不如用i和startIndex比较好理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates.sort()</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, startIndex: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) == target:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; startIndex <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]:<span class="comment">#i&gt;startIndex说明第一个数已经选过了，后面就是判断同一数层不能重复了</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> candidates[i] + <span class="built_in">sum</span>(<span class="variable language_">self</span>.cur) &gt; target:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(candidates[i])</span><br><span class="line">                backtracking(candidates, target, i + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-9-分割回文串"><a href="#8-9-分割回文串" class="headerlink" title="8.9 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">8.9 分割回文串</a></h2><p>分割的地方有1到n-1种，怎么选不同的分割方式？类似组合问题</p>
<ul>
<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个…..。</li>
<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…..。</li>
</ul>
<p>终止条件是分割线已经到字符串末尾</p>
<p>截取子串也不简单，注意start&#x2F;end是开区间还是闭区间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHuiWen</span>(<span class="params">self, s: <span class="built_in">str</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:<span class="comment">#双指针判断s是否为回文串，首位是start，末位是end</span></span><br><span class="line">        i = start         <span class="comment">#或者用反转字符串s[:] = reversed(s) s[:] = s[::-1] s.reverse()比较，库函数简单</span></span><br><span class="line">        j = end</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">s: <span class="built_in">str</span>, start: <span class="built_in">int</span></span>):<span class="comment"># start代表切割线</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.isHuiWen(s, start, i):</span><br><span class="line">                    <span class="variable language_">self</span>.cur.append(s[start : i + <span class="number">1</span>])</span><br><span class="line">                    backtracking(s, i + <span class="number">1</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-10-复原-IP-地址"><a href="#8-10-复原-IP-地址" class="headerlink" title="8.10 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">8.10 复原 IP 地址</a></h2><p>有效的地址是每位在0-255之间，有四位，顺序不能变，在s中插入’.’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">s: <span class="built_in">str</span>, start: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="number">4</span>:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="string">&#x27;.&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="variable language_">self</span>.cur)))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s)):<span class="comment">#这里可优化，见下</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="number">3</span>:<span class="comment">#已经知道三个数后，最后一个数是知道的</span></span><br><span class="line">                    cur_str = s[start: ]</span><br><span class="line">                    i = <span class="built_in">len</span>(s) <span class="comment"># 标记已经找到当前的第四个数了（但不能改变循环，循环中的i还是原来的）</span></span><br><span class="line">                <span class="keyword">else</span>:    </span><br><span class="line">                    cur_str = s[start: i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cur_str) &gt; <span class="number">1</span> <span class="keyword">and</span> cur_str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:  <span class="comment">#不含有前导0</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cur_str) &lt;= <span class="number">3</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= <span class="built_in">int</span>(cur_str) &lt;= <span class="number">255</span>:</span><br><span class="line">                    <span class="variable language_">self</span>.cur.append(cur_str)</span><br><span class="line">                    backtracking(s, i + <span class="number">1</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="built_in">len</span>(s): <span class="keyword">break</span> <span class="comment"># 说明此时是用前三个数推测最后的数的，不用再循环了</span></span><br><span class="line">        backtracking(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>优化：每个数长度最多为3，可以写作<code> for i in range(start, min(start + 3, len(s))):</code></p>
<h2 id="8-11-子集"><a href="#8-11-子集" class="headerlink" title="8.11 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">8.11 子集</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="variable language_">self</span>.res = [[]]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.cur:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy()) <span class="comment"># 这里不return，因为还要继续添加</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-12-回溯周末总结"><a href="#8-12-回溯周末总结" class="headerlink" title="8.12 回溯周末总结"></a>8.12 回溯周末总结</h2><p>如果是一个集合来求组合的话，就需要startIndex，如组合问题；如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</p>
<p><strong>在求和问题中，排序之后加剪枝是常见的套路！</strong></p>
<p>if i &gt; startIndex and candidates[i] &#x3D;&#x3D; candidates[i - 1]:#i&gt;startIndex说明第一个数已经选过了，后面就是判断同一数层不能重复了 树层去重是该题的重点</p>
<h2 id="8-13-子集-II"><a href="#8-13-子集-II" class="headerlink" title="8.13 子集 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">8.13 子集 II</a></h2><p>这里也是使用树层去重，同组合总和II（用used数组用过的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="variable language_">self</span>.res = [[]]</span><br><span class="line">        nums.sort()<span class="comment">#去重需要排序，让相同的数字相邻</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.cur:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy()) <span class="comment"># 这里不return，因为还要继续添加</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; start:<span class="comment">#树层去重</span></span><br><span class="line">                    <span class="keyword">if</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>用used数组的方法：used数组存的是树层的使用情况，并不是树枝的（树枝的进入backtracking就会更新）不过上面i&gt;start更好懂</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums</span>):</span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        nums.sort()  <span class="comment"># 去重需要排序</span></span><br><span class="line">        <span class="variable language_">self</span>.backtracking(nums, <span class="number">0</span>, path, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">self, nums, startIndex, path, result</span>):</span><br><span class="line">        result.append(path[:])  <span class="comment"># 收集子集</span></span><br><span class="line">        uset = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> uset:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            uset.add(nums[i])</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            <span class="variable language_">self</span>.backtracking(nums, i + <span class="number">1</span>, path, result)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>

<h2 id="8-14-非递减子序列"><a href="#8-14-非递减子序列" class="headerlink" title="8.14 非递减子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">8.14 非递减子序列</a></h2><p>不能改变数组现有的顺序，nums &#x3D;[1,2,3,1,1,1,1,1]这个用例总是报错，这道题数组<strong>没有排序</strong>，所以不能用if i &gt; start and nums[i] &#x3D;&#x3D; nums[i - 1]:continue去重，要用set记录用过的数字，不然像[1, 1], [1, 1, 1], [1, 1, 1, 1]这样的用例会错过，下面是错误写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubsequences</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = [] <span class="comment"># 递增子序列</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:<span class="comment">#不能这样去重，不然后面的1会直接漏掉</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="number">0</span>:</span><br><span class="line">                    <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                    backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">                <span class="keyword">elif</span> nums[i] &gt; <span class="variable language_">self</span>.cur[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                    backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">                <span class="comment"># 特殊情况只允许两个整数相等（这里是我理解错题意了，重复元素不限制只有2个）</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] == <span class="variable language_">self</span>.cur[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="number">1</span>:</span><br><span class="line">                        <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                        backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">                        <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">                    <span class="keyword">elif</span> <span class="variable language_">self</span>.cur[-<span class="number">1</span>] != <span class="variable language_">self</span>.cur[-<span class="number">2</span>]:</span><br><span class="line">                        <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                        backtracking(nums, i + <span class="number">1</span>)</span><br><span class="line">                        <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">                </span><br><span class="line">        backtracking(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>另外<strong>子函数（嵌套函数）可以访问父函数（外层函数）的变量</strong>（我上面的题解都写麻烦了，不用传，而且也不用写self），包括父函数传递进来的参数（如<code>nums</code>）。这是因为Python支持<strong>闭包（closure）</strong>，即嵌套函数可以访问其外层作用域中的变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubsequences</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.cur = []  <span class="comment"># 当前递增子序列</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">start: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">            used = <span class="built_in">set</span>()  <span class="comment"># 记录本层已经使用过的数字</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> used:</span><br><span class="line">                    <span class="keyword">continue</span>  <span class="comment"># 跳过本层已经使用过的数字</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.cur <span class="keyword">or</span> nums[i] &gt;= <span class="variable language_">self</span>.cur[-<span class="number">1</span>]:</span><br><span class="line">                    used.add(nums[i]) <span class="comment"># set用add而不是append</span></span><br><span class="line">                    <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                    backtracking(i + <span class="number">1</span>)</span><br><span class="line">                    <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-15-全排列"><a href="#8-15-全排列" class="headerlink" title="8.15 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">8.15 全排列</a></h2><p>因为每个元素要使用一次，但不按顺序，所以回溯时是从0开始找没用过的数字，把used定义在外面</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.used = [] <span class="comment"># 不用set的原因是题目不含重复元素，而且无序pop是随机的</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">start</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> <span class="variable language_">self</span>.used:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="variable language_">self</span>.used.append(nums[i])</span><br><span class="line">                <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                backtracking(<span class="number">0</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">                <span class="variable language_">self</span>.used.pop()</span><br><span class="line">        backtracking(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<p>根据下文的观察self.cur和self.used的操作完全一致，所以self.cur其实就足够表达数字有没有使用过了</p>
<p>因为start也一直从0传，这个也可以省略</p>
<p>比dfs方法要好理解些</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> <span class="variable language_">self</span>.cur: <span class="comment"># 如果不在self.cur里，数字未使用，可添加</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                backtracking()</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">        backtracking()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-16-全排列-II"><a href="#8-16-全排列-II" class="headerlink" title="8.16 全排列 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">8.16 全排列 II</a></h2><p>区别在于要排序+通过相邻节点判断去重</p>
<p>如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重，用<code>used[i - 1] == true</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="variable language_">self</span>.cur = []</span><br><span class="line">        <span class="variable language_">self</span>.res = []</span><br><span class="line">        <span class="variable language_">self</span>.used = [<span class="literal">False</span>] * <span class="built_in">len</span>(nums) <span class="comment"># 记录每个位置的数字是否使用过</span></span><br><span class="line">        nums.sort() <span class="comment"># 方便去重 </span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">start</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cur) == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="variable language_">self</span>.res.append(<span class="variable language_">self</span>.cur.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt; start <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable language_">self</span>.used[i - <span class="number">1</span>]:<span class="comment">#这里not的意思是当前nums[i]要做第一个数字，但这种情况前面已经排列过了，所以应该去重</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="variable language_">self</span>.used[i] = <span class="literal">True</span></span><br><span class="line">                <span class="variable language_">self</span>.cur.append(nums[i])</span><br><span class="line">                backtracking(<span class="number">0</span>)</span><br><span class="line">                <span class="variable language_">self</span>.cur.pop()</span><br><span class="line">                <span class="variable language_">self</span>.used[i] = <span class="literal">False</span></span><br><span class="line">        backtracking(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.res</span><br></pre></td></tr></table></figure>

<h2 id="8-17-周末总结"><a href="#8-17-周末总结" class="headerlink" title="8.17 周末总结"></a>8.17 周末总结</h2><p><strong>排列问题的不同：</strong></p>
<ul>
<li>每层都是从0开始搜索而不是startIndex</li>
<li>需要used数组记录path里都放了哪些元素了</li>
</ul>
<p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度</strong></p>
<h2 id="8-18-去重问题的另一种写法"><a href="#8-18-去重问题的另一种写法" class="headerlink" title="8.18 去重问题的另一种写法"></a>8.18 去重问题的另一种写法</h2><p>使用set去重的版本相对于used数组的版本效率都要低很多，不仅时间复杂度高了，空间复杂度也高了</p>
<h2 id="8-19-重新安排行程"><a href="#8-19-重新安排行程" class="headerlink" title="8.19 重新安排行程"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">8.19 重新安排行程</a></h2><p>从JFK开始一笔画，经过所有路径的字典排序（返回字典序最小的组合）</p>
<p>每个航线是一条线，最后的行程必须包含每条线</p>
<p>下面的写法有一个用例过不了，原始回溯法每次都要排序和尝试所有邻接节点，时间复杂度较高（接近 O(n!)）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findItinerary</span>(<span class="params">self, tickets: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ticket_dict = defaultdict(<span class="built_in">list</span>) <span class="comment"># key是出发机场，value是到达机场</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tickets:</span><br><span class="line">            ticket_dict[item[<span class="number">0</span>]].append(item[<span class="number">1</span>])</span><br><span class="line">        res = [<span class="string">&#x27;JFK&#x27;</span>]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">cur_from</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="built_in">len</span>(tickets) + <span class="number">1</span>:<span class="comment"># 结束条件是遍历完所有路径</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span><span class="comment"># 第一次到达这里时就是最小的字典序</span></span><br><span class="line">            ticket_dict[cur_from].sort() <span class="comment"># 把当前候选的到达机场按照字典序排序</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> ticket_dict[cur_from]:</span><br><span class="line">                cur_to = ticket_dict[cur_from].pop(<span class="number">0</span>) <span class="comment"># 选择可达的最小字典序机场</span></span><br><span class="line">                res.append(cur_to)</span><br><span class="line">                <span class="keyword">if</span> backtracking(cur_to):<span class="comment">#这样写的原因是第一次返回True时就找到了答案，无需继续遍历</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                res.pop() <span class="comment"># 不一定选最小的机场就能实现一笔画，所以还是要遍历</span></span><br><span class="line">                ticket_dict[cur_from].append(cur_to)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 这里也要写 不然会超时</span></span><br><span class="line">        backtracking(<span class="string">&#x27;JFK&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>使用<strong>Hierholzer算法</strong>来寻找欧拉路径（找到一条路径能够遍历所有的边恰好一次）为什么这样能保证找到欧拉路径？</p>
<ul>
<li><strong>DFS 确保所有边被访问</strong>：由于每次访问一条边后就会“拆掉”这条边（从邻接表中移除），所以不会重复访问。</li>
<li><strong>后序遍历保证路径连通性</strong>：在 DFS 回溯时才记录节点，可以确保路径是连续的（不会遗漏中间节点）。</li>
<li><strong>反转路径得到正确顺序</strong>：因为 DFS 是后序存储的，所以最终需要反转才能得到从起点到终点的路径。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findItinerary</span>(<span class="params">self, tickets: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        graph = defaultdict(<span class="built_in">list</span>) <span class="comment"># 创建默认字典，用于存储机场映射关系</span></span><br><span class="line">        <span class="keyword">for</span> src, dst <span class="keyword">in</span> tickets: <span class="comment"># 构建图</span></span><br><span class="line">            graph[src].append(dst)</span><br><span class="line">        <span class="keyword">for</span> src <span class="keyword">in</span> graph:</span><br><span class="line">            graph[src].sort(reverse=<span class="literal">True</span>) <span class="comment"># 对到达机场列表进行字母逆序排序</span></span><br><span class="line">        </span><br><span class="line">        itinerary = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">while</span> graph[node]:</span><br><span class="line">                next_node = graph[node].pop()</span><br><span class="line">                dfs(next_node)</span><br><span class="line">            itinerary.append(node)</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="string">&quot;JFK&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> itinerary[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="8-20-N-皇后"><a href="#8-20-N-皇后" class="headerlink" title="8.20 N 皇后"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">8.20 N 皇后</a></h2><p>把n个皇后放置在n*n的棋盘上，不在同一行&#x2F;同一列&#x2F;同一斜线，输出所有可能的解法</p>
<p>检查是否不互相攻击：不用同行检查，因为每行只选一个元素；因为后面的行还没选，是从前往后选的，所以检查同一列、45度、135度也只用看前面的行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        chessboard = [<span class="string">&#x27;.&#x27;</span> * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># n*n</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">row: <span class="built_in">int</span>, col: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment">#因为row递增的原因，第row行肯定没有，不用检查</span></span><br><span class="line">            <span class="comment">#1.检查列</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#2.检查45°是否有（当前位置的左上方）</span></span><br><span class="line">            i, j = row - <span class="number">1</span>, col - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment">#3. 检查135°是否有（当前位置的右上方）</span></span><br><span class="line">            i, j = row - <span class="number">1</span>, col + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(chessboard):</span><br><span class="line">                <span class="keyword">if</span> chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">row: <span class="built_in">int</span></span>): <span class="comment"># 表示当前在第几行放置棋子</span></span><br><span class="line">            <span class="keyword">if</span> row == n: <span class="comment"># 表示把n个皇后都放了</span></span><br><span class="line">                res.append(chessboard.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 行已经知道是row了，列是col</span></span><br><span class="line">                <span class="keyword">if</span> isValid(row, col):</span><br><span class="line">                    chessboard[row] = chessboard[row][:col] + <span class="string">&quot;Q&quot;</span> + chessboard[row][col+<span class="number">1</span>:] <span class="comment"># 放在该列</span></span><br><span class="line">                    backtracking(row + <span class="number">1</span>)</span><br><span class="line">                    chessboard[row] = chessboard[row][:col] + <span class="string">&quot;.&quot;</span> + chessboard[row][col+<span class="number">1</span>:] <span class="comment"># 撤销</span></span><br><span class="line">        </span><br><span class="line">        backtracking(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="8-21-解数独"><a href="#8-21-解数独" class="headerlink" title="8.21 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">8.21 解数独</a></h2><p>遍历行和列，遍历1-9，看(i, j)这个位置放k是否合适，如果1-9都不行就说明这个棋盘找不到解决数独问题的解</p>
<p>判断合法：同行、同列是否重复，九宫格里是否重复</p>
<ul>
<li>题目数据 <strong>保证</strong> 输入数独仅有一个解，所以只有一种情况会递归成功直到所有空白格已填充</li>
<li>下面的解法通过空间换时间，用row&#x2F;col&#x2F;palace让判断合法变得相对简单</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 直接在board上改，不要创建新的空间，返回其他的内容</span></span><br><span class="line">        nums = &#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>&#125; <span class="comment"># 用来获取可用数字</span></span><br><span class="line">        row = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="comment"># 每行已使用的数字</span></span><br><span class="line">        col = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="comment"># 每列已使用的数字</span></span><br><span class="line">        palace = [[<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]  <span class="comment"># 每个3x3已使用的数字</span></span><br><span class="line">        blank = [] <span class="comment"># 存储所有空白格的位置，(i, j)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化，按照行、列、宫 分别存入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                ch = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    blank.append((i, j)) <span class="comment"># 加入空白格</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#第(i,j)的值是ch</span></span><br><span class="line">                    row[i].add(ch)</span><br><span class="line">                    col[j].add(ch)</span><br><span class="line">                    palace[i//<span class="number">3</span>][j//<span class="number">3</span>].add(ch) <span class="comment">#如(5,3)存入(1,1)的格子</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">n</span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="built_in">len</span>(blank): <span class="comment"># 如果所有空白格已填充</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i, j = blank[n] <span class="comment"># 获取第n个空白格的位置</span></span><br><span class="line">            rst = nums - row[i] - col[j] - palace[i//<span class="number">3</span>][j//<span class="number">3</span>]  <span class="comment"># 剩余的数字 -是集合的差值运算</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rst: <span class="comment"># 没有可用数字，回溯</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> rst: <span class="comment"># 尝试每个可用数字</span></span><br><span class="line">                board[i][j] = num</span><br><span class="line">                row[i].add(num)</span><br><span class="line">                col[j].add(num)</span><br><span class="line">                palace[i//<span class="number">3</span>][j//<span class="number">3</span>].add(num)</span><br><span class="line">                <span class="keyword">if</span> dfs(n+<span class="number">1</span>): <span class="comment"># 递归尝试下一个空白格</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                row[i].remove(num)</span><br><span class="line">                col[j].remove(num)</span><br><span class="line">                palace[i//<span class="number">3</span>][j//<span class="number">3</span>].remove(num)</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="8-22-回溯总结"><a href="#8-22-回溯总结" class="headerlink" title="8.22 回溯总结"></a>8.22 回溯总结</h2><p>如果是一个集合来求组合的话，就需要startIndex；如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</p>
<p>“树层去重”和“树枝去重”</p>
<p>使用set去重的版本相对于used数组的版本效率都要低很多</p>
<h1 id="9-贪心算法"><a href="#9-贪心算法" class="headerlink" title="9. 贪心算法"></a>9. 贪心算法</h1><h2 id="9-1-贪心算法理论基础"><a href="#9-1-贪心算法理论基础" class="headerlink" title="9.1 贪心算法理论基础"></a>9.1 贪心算法理论基础</h2><p>如何能看出局部最优是否能推出整体最优呢？要手动模拟，如果可行就贪心，不可行可能需要动态规划，举不出反例就可以试试贪心</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h2 id="9-2-分发饼干"><a href="#9-2-分发饼干" class="headerlink" title="9.2 分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">9.2 分发饼干</a></h2><p>尽可能多的满足孩子，就要从胃口值小的分起</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort() <span class="comment"># 用小饼干喂小胃口</span></span><br><span class="line">        g_idx = <span class="number">0</span></span><br><span class="line">        s_idx = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> g_idx &lt; <span class="built_in">len</span>(g) <span class="keyword">and</span> s_idx &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> g[g_idx] &lt;= s[s_idx]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                g_idx += <span class="number">1</span></span><br><span class="line">                s_idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="9-3-摆动序列"><a href="#9-3-摆动序列" class="headerlink" title="9.3 摆动序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">9.3 摆动序列</a></h2><p>可以直接在原始数组上删除一些元素，局部最优：删除单调坡度上的节点（不包含两端）。不需要删除，统计数组的峰值数量即可。</p>
<img src="https://file.kamacoder.com/pics/20201124174327597.png" alt="376.摆动序列" style="zoom:50%;" />

<p>但有一些特殊情况，要考虑平坡！所以只在坡度 摆动变化的时候，更新 prediff，不在单调区间有平坡时变化</p>
<img src="https://file.kamacoder.com/pics/20230108174452.png" alt="img" style="zoom: 33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        curDiff = <span class="number">0</span></span><br><span class="line">        preDiff = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> (curDiff &lt; <span class="number">0</span> <span class="keyword">and</span> preDiff &gt;= <span class="number">0</span>) <span class="keyword">or</span> (curDiff &gt; <span class="number">0</span> <span class="keyword">and</span> preDiff &lt;= <span class="number">0</span>):</span><br><span class="line">                max_len += <span class="number">1</span></span><br><span class="line">                preDiff = curDiff <span class="comment"># 重要，写在这里</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h2 id="9-4-最大子数组和"><a href="#9-4-最大子数组和" class="headerlink" title="9.4 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">9.4 最大子数组和</a></h2><p>负数一定会拉低总和，只要连续和为正就对后面的元素起到增大总和的作用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_res = -inf</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="built_in">sum</span> += n</span><br><span class="line">            max_res = <span class="built_in">max</span>(<span class="built_in">sum</span>, max_res)</span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">return</span> max_res</span><br></pre></td></tr></table></figure>

<p>简洁版dp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#dp[i]=max(dp[i-1],0)+nums[i]</span></span><br><span class="line">        ans = -inf</span><br><span class="line">        dp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            dp = <span class="built_in">max</span>(dp, <span class="number">0</span>) + n</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="9-5-贪心周总结"><a href="#9-5-贪心周总结" class="headerlink" title="9.5 贪心周总结"></a>9.5 贪心周总结</h2><p>局部最优和全局最优两个关键点。</p>
<p><strong>不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数</strong></p>
<h2 id="9-6-买卖股票的最佳时机-II"><a href="#9-6-买卖股票的最佳时机-II" class="headerlink" title="9.6 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">9.6 买卖股票的最佳时机 II</a></h2><p>只要差值为正就可以加上，贪心：只要正利润</p>
<p>最终利润是可以分解的，可以把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑。根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices) - <span class="number">1</span>):</span><br><span class="line">            res += <span class="built_in">max</span>(prices[i + <span class="number">1</span>] - prices[i], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="9-7-跳跃游戏"><a href="#9-7-跳跃游戏" class="headerlink" title="9.7 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">9.7 跳跃游戏</a></h2><p>不太懂怎么跳。其实跳几步无所谓，关键在于可跳的覆盖范围！每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。在移动单位的同时，覆盖的点也都走了，范围也更新了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cover = <span class="number">0</span> <span class="comment"># 表示当前整体的覆盖范围</span></span><br><span class="line">        i = <span class="number">0</span> <span class="comment"># 表示当前看的位置</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= cover: <span class="comment"># 保证i是可达的</span></span><br><span class="line">            cover = <span class="built_in">max</span>(cover, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> cover &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span>: <span class="comment"># 到达最后一个下标</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="9-8-跳跃游戏-II"><a href="#9-8-跳跃游戏-II" class="headerlink" title="9.8 跳跃游戏 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">9.8 跳跃游戏 II</a></h2><p>以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点，用修桥理解</p>
<img src="https://pic.leetcode.cn/1727057167-mGElnQ-45-c.png" alt="45-c.png" style="zoom: 25%;" />

<p>难点是维护cur和next，用i表示目前到的位置，用next收集目前可达的位置的最远距离；然后i&#x3D;&#x3D;cur时说明走不动了，要用next更新，很巧妙</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur_distance = <span class="number">0</span>  <span class="comment"># 当前覆盖的最远距离下标</span></span><br><span class="line">        ans = <span class="number">0</span>  <span class="comment"># 记录走的最大步数</span></span><br><span class="line">        next_distance = <span class="number">0</span>  <span class="comment"># 下一步覆盖的最远距离下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):  <span class="comment"># 注意这里是小于len(nums) - 1，结束时说明达到了nums[n-1]</span></span><br><span class="line">            next_distance = <span class="built_in">max</span>(nums[i] + i, next_distance)  <span class="comment"># 更新下一步覆盖的最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> i == cur_distance:  <span class="comment"># 遇到当前覆盖的最远距离下标，说明当前可达的点的最远距离已经知道了</span></span><br><span class="line">                cur_distance = next_distance  <span class="comment"># 因为本题肯定能到达，所以如果到这里，说明next&gt;cur</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>注意跳跃游戏I和II都要遍历每个i</p>
<h2 id="9-9-K-次取反后最大化的数组和"><a href="#9-9-K-次取反后最大化的数组和" class="headerlink" title="9.9 K 次取反后最大化的数组和 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">9.9 K 次取反后最大化的数组和 </a></h2><p>选择k个数字，替换成相反数（如果有负值就替换为正值，尽量重复替换，如果没有负值就替换最小的正值）</p>
<p>对于[4, 2, 3, -2, 1, -4, -3, -6, -4]，按照绝对值排序后结果是[-6, 4, -4, -4, 3, -3, 2, -2, 1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumAfterKNegations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort(key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x), reverse=<span class="literal">True</span>) <span class="comment"># 按照绝对值降序排序，而不是直接排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">                nums[i] *= -<span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果k还剩次数，那已经把所有负数都变成了正数，此时nums全是正数而且降序排序，所以不可能有还没取反的负值，而是直接把绝对值最小的值取反</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> k % <span class="number">2</span> == <span class="number">1</span>: </span><br><span class="line">            nums[-<span class="number">1</span>] *= -<span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>

<h2 id="9-10-贪心周总结"><a href="#9-10-贪心周总结" class="headerlink" title="9.10 贪心周总结"></a>9.10 贪心周总结</h2><p>其实代码都不难，难的是思路，需要反复练习和观察</p>
<h2 id="9-11-加油站"><a href="#9-11-加油站" class="headerlink" title="9.11 加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">9.11 加油站</a></h2><p>如何获取数组中所有1的下标：list.index(val)只能获取第一个，如果val不在list里还会报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indices = [i <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(lst) <span class="keyword">if</span> x == <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>我的错误做法是找到cost最小的下标，但其实不一定，正确方法如下：i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。这是局部最优的方法，但可以推出全局最优。</p>
<img src="https://file.kamacoder.com/pics/20230117165628.png" alt="img" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        curSum = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(cost) &gt; <span class="built_in">sum</span>(gas):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            curSum += gas[i] - cost[i]</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; <span class="number">0</span>:</span><br><span class="line">                start = i + <span class="number">1</span> <span class="comment"># [0,i]肯定不是，检查后面</span></span><br><span class="line">                curSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>

<h2 id="9-12-分发糖果"><a href="#9-12-分发糖果" class="headerlink" title="9.12 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">9.12 分发糖果</a></h2><p>规则定义： 设学生 A 和学生 B 左右相邻，A 在 B 左边；</p>
<ul>
<li>左规则： 当 ratings B &gt; ratings A 时，B 的糖比 A 的糖数量多。</li>
<li>右规则： 当 ratings A &gt; ratings B 时，A 的糖比 B 的糖数量多。</li>
</ul>
<p>先从左到右遍历ratings得到left，满足左规则；再从右到左遍历得到right，满足右规则，最后取left和right的最大值，这样同时满足左右规则（使用两次贪心，从局部最优推出全局最优，思路还是很巧妙的）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = [<span class="number">1</span>] * <span class="built_in">len</span>(ratings)</span><br><span class="line">        right = left.copy()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>]:</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        res = left[-<span class="number">1</span>] <span class="comment"># 从右到左时right[-1]肯定为1，所以直接赋值left[-1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>]:</span><br><span class="line">                right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            res += <span class="built_in">max</span>(left[i], right[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="9-13-柠檬水找零"><a href="#9-13-柠檬水找零" class="headerlink" title="9.13 柠檬水找零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">9.13 柠檬水找零</a></h2><p>记录5和10的数量即可，然后用规则找零</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lemonadeChange</span>(<span class="params">self, bills: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        num_5 = <span class="number">0</span></span><br><span class="line">        num_10 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">5</span>: </span><br><span class="line">                num_5 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> bill == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> num_5 == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                num_5 -= <span class="number">1</span></span><br><span class="line">                num_10 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> bill == <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> num_10 &gt;= <span class="number">1</span> <span class="keyword">and</span> num_5 &gt;= <span class="number">1</span>:</span><br><span class="line">                    num_5 -= <span class="number">1</span></span><br><span class="line">                    num_10 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> num_5 &gt;= <span class="number">3</span>:</span><br><span class="line">                    num_5 -= <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="9-14-根据身高重建队列"><a href="#9-14-根据身高重建队列" class="headerlink" title="9.14 根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">9.14 根据身高重建队列</a></h2><p>我写的版本：如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># 不适合用dict，因为key为height的话不唯一</span></span><br><span class="line">        heights = [people[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(people))]</span><br><span class="line">        heights.sort() <span class="comment"># 所有身高从小到大排序</span></span><br><span class="line">        <span class="built_in">print</span>(heights)</span><br><span class="line">        res = []</span><br><span class="line">        left_index = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(people))) <span class="comment"># 当前空余的位置</span></span><br><span class="line">        <span class="built_in">print</span>(left_index)</span><br><span class="line">        <span class="keyword">for</span> height <span class="keyword">in</span> heights:</span><br><span class="line">            <span class="comment"># 在people中找当前第一个height对应的排在前面的人</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(people)):</span><br><span class="line">                <span class="keyword">if</span> people[i][<span class="number">0</span>] == height <span class="keyword">and</span> people[i][<span class="number">1</span>] != -<span class="number">1</span>:</span><br><span class="line">                    k = people[i][<span class="number">1</span>] <span class="comment"># 应该放在当前空余的第k位</span></span><br><span class="line">                    res.append([people[i][<span class="number">0</span>], left_index[k]]) <span class="comment"># 这样只考虑了大于没考虑等于</span></span><br><span class="line">                    left_index.remove(left_index[k])</span><br><span class="line">                    people[i][<span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">sol = Solution()</span><br><span class="line">sol.reconstructQueue([[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]])</span><br></pre></td></tr></table></figure>

<p>答案按身高高的来排序，这样后续插入的节点不影响</p>
<img src="https://file.kamacoder.com/pics/20201216201851982.png" alt="406.根据身高重建队列" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>])) <span class="comment"># 先按身高从大到小排序，同一身高k小的排前面</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> hi, ki <span class="keyword">in</span> people:</span><br><span class="line">            res.insert(ki, [hi, ki]) <span class="comment"># 这样可以指定数组中插入的位置，同一位置会后移</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="9-15-贪心周总结"><a href="#9-15-贪心周总结" class="headerlink" title="9.15 贪心周总结"></a>9.15 贪心周总结</h2><h2 id="9-16-vector原理"><a href="#9-16-vector原理" class="headerlink" title="9.16 vector原理"></a>9.16 vector原理</h2><p>避免vector的底层扩容，尽量在原数组修改，但在原数组肯定要细致点</p>
<h2 id="9-17-用最少数量的箭引爆气球"><a href="#9-17-用最少数量的箭引爆气球" class="headerlink" title="9.17 用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">9.17 用最少数量的箭引爆气球</a></h2><p>贪心：局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。</p>
<p>第一个点就放在第一个区间的右端点处，第二个点就放在剩余区间的第一个区间的右端点处。依此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>]) <span class="comment">#按照右端点排序</span></span><br><span class="line">        pre = -inf</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> points:</span><br><span class="line">            <span class="keyword">if</span> start &gt; pre: <span class="comment"># 当前的箭不够覆盖了</span></span><br><span class="line">                pre = end</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="9-18-无重叠区间"><a href="#9-18-无重叠区间" class="headerlink" title="9.18 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">9.18 无重叠区间</a></h2><p>我的写法是移除end大的区间，不断更新end进行比较：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>]) <span class="comment"># 这里我本来想先end小，再start大（优先保留结尾小且短的区间），但start不排也能过</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        pre_end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> start &lt; pre_end:</span><br><span class="line">                ans += <span class="number">1</span> <span class="comment"># 删目前这个区间，留end小的，所以不更新pre_end</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_end = end</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>也可以计算不重叠的区间个数，然后减掉，同样是按end排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        pre_r = -inf</span><br><span class="line">        <span class="keyword">for</span> l, r <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> l &gt;= pre_r:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                pre_r = r</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - ans</span><br></pre></td></tr></table></figure>

<h2 id="9-19-划分字母区间"><a href="#9-19-划分字母区间" class="headerlink" title="9.19 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">9.19 划分字母区间</a></h2><p>为了满足同一字母最多出现在一个片段中，选最长的区间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 记录每个字母的最大索引</span></span><br><span class="line">        <span class="built_in">dict</span> = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="built_in">dict</span>[c] = i</span><br><span class="line">        res = []</span><br><span class="line">        curr_idx = <span class="number">0</span></span><br><span class="line">        pre_idx = <span class="number">0</span> <span class="comment"># 记录字符串开始的下标</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> i &gt; curr_idx:</span><br><span class="line">                res.append(curr_idx - pre_idx + <span class="number">1</span>)</span><br><span class="line">                curr_idx += <span class="number">1</span></span><br><span class="line">                pre_idx = curr_idx</span><br><span class="line">            <span class="keyword">if</span> curr_idx &lt; <span class="built_in">dict</span>[c]:</span><br><span class="line">                curr_idx = <span class="built_in">dict</span>[c]</span><br><span class="line">        res.append(curr_idx - pre_idx + <span class="number">1</span>) <span class="comment"># 跳出循环存最后一个字符串</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>更简洁的写法：用end&#x3D;&#x3D;i来判断区间该合并：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        last = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s)&#125;  <span class="comment"># 每个字母最后出现的下标 建dict</span></span><br><span class="line">        ans = []</span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            end = <span class="built_in">max</span>(end, last[c])  <span class="comment"># 更新当前区间右端点的最大值</span></span><br><span class="line">            <span class="keyword">if</span> end == i:  <span class="comment"># 当前区间合并完毕</span></span><br><span class="line">                ans.append(end - start + <span class="number">1</span>)  <span class="comment"># 区间长度加入答案</span></span><br><span class="line">                start = i + <span class="number">1</span>  <span class="comment"># 下一个区间的左端点</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="9-20-合并区间"><a href="#9-20-合并区间" class="headerlink" title="9.20 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">9.20 合并区间</a></h2><p>不断比较上一个的end和下一个的start即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        pre_start, pre_end = intervals[<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> start, end <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> start &lt;= pre_end:</span><br><span class="line">                pre_end = <span class="built_in">max</span>(end, pre_end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([pre_start, pre_end])</span><br><span class="line">                pre_start, pre_end = start, end</span><br><span class="line">        res.append([pre_start, pre_end])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="9-21-贪心周总结"><a href="#9-21-贪心周总结" class="headerlink" title="9.21 贪心周总结"></a>9.21 贪心周总结</h2><p>区间：画图+排序</p>
<h2 id="9-22-单调递增的数字"><a href="#9-22-单调递增的数字" class="headerlink" title="9.22 单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">9.22 单调递增的数字</a></h2><h1 id="10-动态规划"><a href="#10-动态规划" class="headerlink" title="10. 动态规划"></a>10. 动态规划</h1><h2 id="10-1-动态规划理论基础"><a href="#10-1-动态规划理论基础" class="headerlink" title="10.1 动态规划理论基础"></a>10.1 动态规划理论基础</h2><p>动态规划中每一个状态一定是由上一个状态推导出来的</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="10-2-斐波那契数"><a href="#10-2-斐波那契数" class="headerlink" title="10.2 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">10.2 斐波那契数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="10-3-爬楼梯"><a href="#10-3-爬楼梯" class="headerlink" title="10.3 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">10.3 爬楼梯</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dp[0]</code> 表示“用若干步恰好到达楼顶”的方法数。唯一方法是一步都不走，所以是1。</li>
</ul>
<p> 扩展：每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i - j] </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    </span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) <span class="comment"># map(func, iterable)将列表中的每个字符串转换为整数。</span></span><br><span class="line">sol = Solution()</span><br><span class="line"><span class="built_in">print</span>(sol.climbStairs(n, m))</span><br></pre></td></tr></table></figure>

<h2 id="10-4-使用最小花费爬楼梯"><a href="#10-4-使用最小花费爬楼梯" class="headerlink" title="10.4 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">10.4 使用最小花费爬楼梯</a></h2><p>dp[i] &#x3D; min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) dp表示到达第i个位置支付的最小费用 dp[0] &#x3D; 0 dp[1]&#x3D;0 dp[2]&#x3D;10 dp[3]就是结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(cost) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost) + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>] + cost[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + cost[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(cost)]</span><br></pre></td></tr></table></figure>

<p>还可以优化空间复杂度，用dp0和dp1迭代，不用建数组了</p>
<h2 id="10-5-周总结"><a href="#10-5-周总结" class="headerlink" title="10.5 周总结"></a>10.5 周总结</h2><p>debug技巧：检查递推公式，打印dp数组手动推理检查</p>
<p>完全背包问题：对比0-1背包，物品只能选 1 次</p>
<ul>
<li><strong>物品可以无限次使用</strong>（类比：每次可以爬 1、2、…、m 阶，不限次数）。</li>
<li><strong>求组合数</strong>（类比：爬楼梯的顺序不同，算不同的方法）。</li>
</ul>
<h2 id="10-6-不同路径"><a href="#10-6-不同路径" class="headerlink" title="10.6 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">10.6 不同路径</a></h2><p>dp[m][n]表示到达(m,n)的路径数，dp[m][n]&#x3D;dp[m-1][n]+dp[m][n-1].当m&#x3D;0时,dp[0][n]&#x3D;1；当n&#x3D;0时，dp[m][0]&#x3D;1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="comment"># 创建m*n的数组，m是行数，n是列数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):<span class="comment">#从1开始，防止数组越界</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>] </span><br></pre></td></tr></table></figure>

<p>我看hot100的题解用的是dfs，这里要注意使用@cache</p>
<h2 id="10-7-不同路径-II"><a href="#10-7-不同路径-II" class="headerlink" title="10.7 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">10.7 不同路径 II</a></h2><p>我的错误答案：写了很多判断条件，但还是考虑不周全</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="comment"># 创建m*n的数组，m是行数，n是列数</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):<span class="comment">#从1开始，防止数组越界</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> obstacleGrid[i - <span class="number">1</span>][j] == <span class="number">1</span> <span class="keyword">and</span> obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> obstacleGrid[i - <span class="number">1</span>][j] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>] </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>后来我决定按规则先遍历obstacleGrid，如果上面和左边同时为1，或者在边界遇见1，则标为1，这样在写dp时就简单了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="comment"># 创建m*n的数组，m是行数，n是列数</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                obstacleGrid[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                obstacleGrid[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i - <span class="number">1</span>][j] == <span class="number">1</span> <span class="keyword">and</span> obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] == <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):<span class="comment">#从1开始，防止数组越界</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] != <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>] </span><br></pre></td></tr></table></figure>

<p>简洁版：其实不用遍历更新obstacleGrid，因为如果两边dp为0的话，加起来自然为0</p>
<ul>
<li>关键点是先处理边界时遇到1就停止赋值，剩下的dp均为0，用else break写</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="comment"># 创建m*n的数组，m是行数，n是列数</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):<span class="comment">#从1开始，防止数组越界</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] != <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-8-整数拆分"><a href="#10-8-整数拆分" class="headerlink" title="10.8 整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">10.8 整数拆分</a></h2><p>拆分成两种（j * (i - j)）或者拆分成三种及以上（j * dp[i - j]）所以dp[i] &#x3D; max({dp[i], (i - j) * j, dp[i - j] * j})</p>
<ul>
<li>关注j的取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i // <span class="number">2</span> + <span class="number">1</span>):<span class="comment">#两数之和，只用看前一半就行了，反过来是重复的</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], (i - j) * j, dp[i - j] * j)<span class="comment">#当前看dp[i]，拆出来一个数j，j&lt;=i//2</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="10-9-不同的二叉搜索树"><a href="#10-9-不同的二叉搜索树" class="headerlink" title="10.9 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">10.9 不同的二叉搜索树</a></h2><p>我的状态转移方程推错了，dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<ul>
<li>元素1为头结点搜索树的数量 &#x3D; 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 dp[2]*dp[0]</li>
<li>元素2为头结点搜索树的数量 &#x3D; 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 dp[1]*dp[1]</li>
<li>元素3为头结点搜索树的数量 &#x3D; 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量 dp[0]*dp[2]</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)  <span class="comment"># 创建一个长度为n+1的数组，初始化为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 当n为0时，只有一种情况，即空树，所以dp[0] = 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 遍历从1到n的每个数字</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):  <span class="comment"># 对于每个数字i，计算以i为根节点的二叉搜索树的数量</span></span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]  <span class="comment"># 利用动态规划的思想，累加左子树和右子树的组合数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]  <span class="comment"># 返回以1到n为节点的二叉搜索树的总数量</span></span><br></pre></td></tr></table></figure>

<h2 id="10-10-周总结"><a href="#10-10-周总结" class="headerlink" title="10.10 周总结"></a>10.10 周总结</h2><p>感觉还是trick居多，状态转移方程难，要多练</p>
<h2 id="10-11-0-1背包理论基础（一）"><a href="#10-11-0-1背包理论基础（一）" class="headerlink" title="10.11 0-1背包理论基础（一）"></a>10.11 0-1背包理论基础（一）</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>暴力的解法是取或者不取，回溯搜索</p>
<p>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 不取该物品，取该物品</p>
<p>初始化关注：i&#x3D;0,j&#x3D;0的特殊情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">value = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="comment"># dp[i][j]表示前i个数填满j的背包的最大价值 因为要访问到大小为n，所以要创建n+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(weight[<span class="number">0</span>], n + <span class="number">1</span>): <span class="comment"># 可以选0物品时</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m): <span class="comment"># i = 0时就是0，跟初始化一样，没必要遍历</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> weight[i] &gt; j: <span class="comment">#不可能选</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br><span class="line"><span class="built_in">print</span>(dp[m - <span class="number">1</span>][n])</span><br></pre></td></tr></table></figure>

<p>这里的背包和物品遍历顺序可以交换，以及物品一定要从小到大，但容量j无所谓，可以从小到大或者从大到小，因为不管顺序如何<code>dp[i-1][j]</code> 和 <code>dp[i-1][j - weight[i]]</code> 都已在上一轮计算完成。</p>
<h2 id="10-12-动态规划：01背包理论基础（滚动数组）"><a href="#10-12-动态规划：01背包理论基础（滚动数组）" class="headerlink" title="10.12 动态规划：01背包理论基础（滚动数组）"></a>10.12 动态规划：01背包理论基础（滚动数组）</h2><p>滚动数组：把二维dp降为一维dp，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>注意和二维不同的是：</p>
<ul>
<li>遍历背包要倒序！不然物品会被重复加入！</li>
<li>只能先遍历物品再遍历背包，不然每个dp[j]只会被最后一个物品更新</li>
</ul>
<p>总结：<strong>先物品再背包，背包倒序</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">value = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m): <span class="comment"># i = 0时就是0，跟初始化一样，没必要遍历</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> weight[i] &lt;= j: <span class="comment"># 防止不能选的情况导致的越界</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line"><span class="built_in">print</span>(dp[n])</span><br></pre></td></tr></table></figure>

<h2 id="10-13-分割等和子集"><a href="#10-13-分割等和子集" class="headerlink" title="10.13 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">10.13 分割等和子集</a></h2><p>就是01背包，只是背包值是数组总和的一半</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># dp[i][j] 表示前i个数（不一定全选）可以凑到总和为j 01背包问题</span></span><br><span class="line">        <span class="comment"># dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]</span></span><br><span class="line">        sum_ = <span class="built_in">sum</span>(nums)</span><br><span class="line">        len_ = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        total = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (total + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(total, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= j: <span class="comment"># 注意这里要判断，不然越界了会出错</span></span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j - nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[total]</span><br></pre></td></tr></table></figure>

<h2 id="10-14-最后一块石头的重量-II"><a href="#10-14-最后一块石头的重量-II" class="headerlink" title="10.14 最后一块石头的重量 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">10.14 最后一块石头的重量 II</a></h2><p>我的想法是先排序，然后两两做减法</p>
<p>但这道题其实是01背包的思路，尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。</p>
<p>此时的问题：有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum &#x2F; 2的背包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastStoneWeightII</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]) 大小为j的背包最多装的石头大小</span></span><br><span class="line">        len_ = <span class="built_in">len</span>(stones)</span><br><span class="line">        sum_ = <span class="built_in">sum</span>(stones)</span><br><span class="line">        target = sum_ // <span class="number">2</span> <span class="comment"># 注意这里不用+1，不然有错</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> stone <span class="keyword">in</span> stones:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> stone &lt;= j:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stone] + stone)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sum_ - <span class="number">2</span> * dp[target])</span><br></pre></td></tr></table></figure>

<p>本题其实和<a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">416. 分割等和子集 (opens new window)</a>几乎是一样的，只是最后对dp[target]的处理方式不同。</p>
<p><strong><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">416. 分割等和子集 (opens new window)</a>相当于是求背包是否正好装满，而本题是求背包最多能装多少</strong>。</p>
<h2 id="10-15-周总结"><a href="#10-15-周总结" class="headerlink" title="10.15 周总结"></a>10.15 周总结</h2><p><img src="https://file1.kamacoder.com/i/algo/20210117171307407-20230310133624872.png" alt="416.分割等和子集1"></p>
<h2 id="10-16-目标和"><a href="#10-16-目标和" class="headerlink" title="10.16 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">10.16 目标和</a></h2><p>返回nums可以得到target的表达式数目</p>
<p>dp[i][j]表示前i个数可以得到j的数目，我本来想的是dp[i][j] &#x3D; dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]，但是效率比较低</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(target) &gt; total:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="number">2</span> * total + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="comment"># dp[i][j] 表示前 i 个数字，通过加减运算得到 j - total 的方法数</span></span><br><span class="line">        dp[<span class="number">0</span>][total] = <span class="number">1</span>  <span class="comment"># dp[0][0 + total] = 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># 当前访问的是nums[i-1]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * total + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - nums[i-<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] += dp[i-<span class="number">1</span>][j - nums[i-<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">if</span> j + nums[i-<span class="number">1</span>] &lt;= <span class="number">2</span> * total:</span><br><span class="line">                    dp[i][j] += dp[i-<span class="number">1</span>][j + nums[i-<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[n][target + total]</span><br></pre></td></tr></table></figure>

<p>另一种方法：因为left-right&#x3D;target,left+right&#x3D;sum,所以left&#x3D;(sum+target)&#x2F;&#x2F;2,求总和为这个的表达式的数目</p>
<p>注意在这个场景下，left,right&gt;&#x3D;0，所以要剪枝</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[j] += dp[j - num]</span></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> (total + target) % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">or</span> (total + target) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = (total + target) // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (left + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(left, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> num &lt;= j:</span><br><span class="line">                    dp[j] += dp[j - num]</span><br><span class="line">        <span class="keyword">return</span> dp[left]</span><br></pre></td></tr></table></figure>

<h2 id="10-17-一和零"><a href="#10-17-一和零" class="headerlink" title="10.17 一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">10.17 一和零</a></h2><p>统计strs中元素的0&#x2F;1个数</p>
<p>m和n代表两个背包，dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。创建时还是以m+1,n+1为基础</p>
<p>dp[i][j] &#x3D; max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1) zero&#x2F;one相当于物品的重量，字符串个数1相当于物品的价值</p>
<p>外层是物品，正序遍历；内层是背包，倒序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxForm</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>], m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dp[i][j] = max(dp[i][j], dp[i-zeroNum][j-oneNum] + 1)</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)] <span class="comment"># 还是创建m+1和n+1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs: <span class="comment"># 正序遍历物品</span></span><br><span class="line">            zeroNum, oneNum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>:<span class="comment">#这里有简略写法：ones = s.count(&#x27;1&#x27;)  # 统计字符串中1的个数</span></span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    zeroNum += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    oneNum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= zeroNum <span class="keyword">and</span> j &gt;= oneNum:</span><br><span class="line">                        dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i-zeroNum][j-oneNum] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h2 id="10-18-完全背包理论基础"><a href="#10-18-完全背包理论基础" class="headerlink" title="10.18 完全背包理论基础"></a>10.18 完全背包理论基础</h2><p>每件物品有无数个，dp[i][j] 表示从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。</p>
<p>dp[i][j]&#x3D;max(dp[i][j-weight[i]]+value[i], dp[i-1][j]) 依然是分为不取该物品，取该物品</p>
<p>如果背包容量为0，那总和一定为0</p>
<p>遍历顺序：先遍历物品，或者先遍历背包都可以</p>
<p>往往还是m + 1, n + 1比较好写，不用处理边界条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">totalbeibao</span>(<span class="params">n, v, value, weight</span>):</span><br><span class="line">    dp = [[<span class="number">0</span>] * (v + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, v + <span class="number">1</span>): <span class="comment"># 遍历背包</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= weight[i - <span class="number">1</span>]:</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="comment"># 要写这里！第一次没写，说明选不了i物品</span></span><br><span class="line">    <span class="keyword">return</span> dp[n][v]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">weight = []</span><br><span class="line">value = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    wi, vi = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    weight.append(wi)</span><br><span class="line">    value.append(vi)</span><br><span class="line"><span class="built_in">print</span>(totalbeibao(n, v, value, weight))</span><br></pre></td></tr></table></figure>

<h2 id="10-19-零钱兑换-II"><a href="#10-19-零钱兑换-II" class="headerlink" title="10.19 零钱兑换 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">10.19 零钱兑换 II</a></h2><p>dp[i][j]表示用前i个数组成金额为j的组合数 dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-coins[i]] + 1)</p>
<p>这里我的递推公式列错了！应该是选当前硬币i或者不选，而且需要注意dp[i][0]&#x3D;1，这样j-coin才能表示正好选到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (amount + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 什么都不选，注意这里的初始化重要 </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>): <span class="comment"># 其实dp[i][0]=1，所以这里要从0开始，不然会报错</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m][amount]</span><br></pre></td></tr></table></figure>

<p>压缩成一维dp：dp[j] +&#x3D; dp[j - coins[i]]</p>
<p>装满背包容量为0 的方法是1，即不放任何物品，<code>dp[0] = 1</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 什么都不选，注意这里的初始化重要</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>): <span class="comment"># 注意完全背包这里是正序，倒序是01！</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= coin:</span><br><span class="line">                    dp[j] += dp[j - coin]</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>

<p><strong>组合与排列的区别：</strong></p>
<ul>
<li>组合：硬币的顺序不重要，即 2+2+1 和 2+1+2 是同一种组合。</li>
<li>排列：顺序重要，视为不同的方式。</li>
<li>为了计算组合数，需要将硬币的循环放在外层，金额的循环放在内层。</li>
<li><strong>完全背包：</strong> 每种物品可以选无限次，因此内层循环是正序的，这样在计算 <code>dp[j]</code> 时，<code>dp[j - coin]</code> 已经考虑了当前硬币的多次使用。</li>
<li><strong>0-1背包：</strong> 每种物品只能选一次，因此内层循环是倒序的，这样在计算 <code>dp[j]</code> 时，<code>dp[j - coin]</code> 还没有被当前硬币更新，确保只使用一次。</li>
</ul>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h2 id="10-20-周总结"><a href="#10-20-周总结" class="headerlink" title="10.20 周总结"></a>10.20 周总结</h2><h2 id="10-21-组合总和-Ⅳ"><a href="#10-21-组合总和-Ⅳ" class="headerlink" title="10.21 组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">10.21 组合总和 Ⅳ</a></h2><p>dp[i][j]表示用0-i数表示j的个数，dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-num])</p>
<p>dp[j] +&#x3D; dp[j-num] 顺序不同，说明是排序，要外层是背包内层是数字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 什么都不选，注意这里的初始化重要</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>):  <span class="comment"># 其实dp[i][0]=1，所以这里要从0开始，不然会报错</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> j &gt;= num:</span><br><span class="line">                    dp[j] += dp[j - num]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>

<h2 id="10-22-爬楼梯"><a href="#10-22-爬楼梯" class="headerlink" title="10.22 爬楼梯"></a>10.22 爬楼梯</h2><p>之前斐波拉契的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i - j] </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line">    </span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) <span class="comment"># map(func, iterable)将列表中的每个字符串转换为整数。</span></span><br><span class="line">sol = Solution()</span><br><span class="line"><span class="built_in">print</span>(sol.climbStairs(n, m))</span><br></pre></td></tr></table></figure>

<p>dp[i][j]表示可以爬0-i级台阶，不限次数，到达第j级的方法次数，属于排列（这里我最开始弄错了，12&#x2F;21不同）</p>
<p>dp[i][j]&#x3D; for stair in 0-i级台阶，dp[i][j-stair]的总和，外层是背包，内层是物品0-i</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">m, n</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># 完全背包问题</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>): <span class="comment"># 这里从0开始，从1开始没区别，因为刚到dp[j]时是0</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= i:</span><br><span class="line">                dp[j] += dp[j - i]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(climbStairs(m, n))</span><br></pre></td></tr></table></figure>

<h2 id="10-23-零钱兑换"><a href="#10-23-零钱兑换" class="headerlink" title="10.23 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">10.23 零钱兑换</a></h2><p>dp[i][j]&#x3D;min(dp[i-1][j],dp[i][j-num]+1) # 表示用0-i的硬币组成j需要的最少的硬币个数 <strong>本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓！所以两个for循环先后顺序怎样都可以！</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&quot;+inf&quot;</span>)]*(amount + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m][amount] <span class="keyword">if</span> dp[m][amount] != <span class="built_in">float</span>(<span class="string">&quot;+inf&quot;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里也是可以优化成一维dp的，因为每次更新 <code>dp[j]</code> 用到的 <code>dp[j - coins[i]]</code> 是<strong>上一轮尚未被更新的旧值</strong>。dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</p>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>可否优化为一维</th>
<th>遍历顺序要求</th>
<th>原因说明</th>
</tr>
</thead>
<tbody><tr>
<td>完全背包</td>
<td>✅ 可以</td>
<td><code>j</code> 从小到大</td>
<td>可以重复选，用旧值不会出错</td>
</tr>
<tr>
<td>0-1 背包</td>
<td>✅ 可以</td>
<td><code>j</code> 从大到小</td>
<td>不能重复选，防止用到当前轮新值</td>
</tr>
<tr>
<td>多重背包</td>
<td>✅ 可转为 0-1</td>
<td>类似于 0-1 背包</td>
<td>分解成多个 0-1 背包处理</td>
</tr>
<tr>
<td>依赖两维状态</td>
<td>❌ 一般不能</td>
<td>无法一维表示</td>
<td>如 <code>dp[i][j] = f(dp[i-1][j-1])</code></td>
</tr>
<tr>
<td>子序列类问题</td>
<td>一般可优化</td>
<td>视转移方向决定顺序</td>
<td>如 LCS、LIS 等，可压缩一维</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;+inf&quot;</span>)]*(amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coin:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&quot;+inf&quot;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="10-24-完全平方数"><a href="#10-24-完全平方数" class="headerlink" title="10.24 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">10.24 完全平方数</a></h2><p>物品是每个完全平方数，149…背包是n 完全平方数的最大值是根号n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&quot;+inf&quot;</span>)]*(n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= i ** <span class="number">2</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i ** <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>



<p>这里的遍历顺序依然不重要，可以先物品或者先背包 sqrt也可以用n**0.5代替</p>
<h2 id="10-25-周总结"><a href="#10-25-周总结" class="headerlink" title="10.25 周总结"></a>10.25 周总结</h2><p>求最小数不同于求排列数和求组合数，遍历顺序不重要</p>
<h2 id="10-26-单词拆分"><a href="#10-26-单词拆分" class="headerlink" title="10.26 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">10.26 单词拆分</a></h2><p>单词是物品，可以重复使用，字符串是背包。强调顺序，所以是排列，外层是背包，内层是物品</p>
<p>dp[i][j]表示用0-i个单词可以组成字符串的前j位 dp[i][j]&#x3D;dp[i-1][j] or dp[i][j-len(word)] 且str[j-len(word):j]&#x3D;&#x3D;word</p>
<p>我的思路太复杂了，用一维数组，dp[i]表示s[0:i]的内容是否可以用字典拼出</p>
<p>方程：dp[i] &#x3D; True，如果存在 j &lt; i，使得 dp[j] &#x3D;&#x3D; True 且 s[j:i] 在 wordDict 中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dp = [<span class="literal">False</span>] * (<span class="built_in">len</span>(s) + <span class="number">1</span>) <span class="comment"># dp[i]表示s[0:i]能否被worddict表示</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>): <span class="comment"># 排列，顺序重要，外层是背包</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> wordDict: <span class="comment"># 可以重复使用，顺序遍历</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(word) <span class="keyword">and</span> dp[i - <span class="built_in">len</span>(word)] <span class="keyword">and</span> s[i - <span class="built_in">len</span>(word): i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br></pre></td></tr></table></figure>

<p>更为简洁的写法：就是内层遍历物品时遍历左下标就行，然后看截取的内容是否出现在wordset</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        word_set = <span class="built_in">set</span>(wordDict)  <span class="comment"># 查询更快</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span>  <span class="comment"># 空字符串可以拼出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> word_set:</span><br><span class="line">                    dp[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 提前剪枝</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="10-27-多重背包理论基础"><a href="#10-27-多重背包理论基础" class="headerlink" title="10.27 多重背包理论基础"></a>10.27 多重背包理论基础</h2><p>k[i]个可用，约束了可用的数量上限，和01背包很像，把Mi件摊开，每个物品只能用一次</p>
<p>组合：外层物品，内层背包（01是倒序），dp[c]表示在容量为c的前提下，能获得的最大总价值</p>
<p>0-1的公式dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);多重改写下k即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C, N = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) <span class="comment"># 容量和矿石种类</span></span><br><span class="line">weight = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">values = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">counts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">dp = [<span class="number">0</span>] * (C + <span class="number">1</span>) <span class="comment"># dp[i]表示容量为i的背包的最大总价值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N): <span class="comment"># 无所谓顺序，所以用组合</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C, weight[i] - <span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 当背包容量&lt;weight[i]时，不可能选i，所以可以剪枝</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, counts[i] + <span class="number">1</span>): <span class="comment"># 因为有counts[i]个可用，所以遍历选k个矿石i的可能性</span></span><br><span class="line">            <span class="keyword">if</span> k * weight[i] &gt; j: <span class="comment"># 如果选k个背包装不下，就结束本轮k</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i] * k] + values[i] * k)</span><br><span class="line"><span class="built_in">print</span>(dp[C])</span><br></pre></td></tr></table></figure>

<p>上面这样写会超时，因为使用了三重循环，O(N * C * k)</p>
<p>二进制优化：O(N × C × log(k)) 利用的是任何数字可以被表示成二进制数的和，把1&#x2F;2&#x2F;4丢进包里，就相当于选了7个，只要不超过k就是对的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">C, N = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) </span><br><span class="line">weights = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">values = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">counts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line">dp = [<span class="number">0</span>] * (C + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    w, v, k = weights[i], values[i], counts[i]</span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        take = <span class="built_in">min</span>(num, k)</span><br><span class="line">        k -= take</span><br><span class="line">        weight = take * w</span><br><span class="line">        value = take * v</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C, weight - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight] + value)</span><br><span class="line">        num &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[C])</span><br></pre></td></tr></table></figure>

<h2 id="10-28-背包问题总结"><a href="#10-28-背包问题总结" class="headerlink" title="10.28 背包问题总结**"></a>10.28 背包问题总结**</h2><p><img src="https://file1.kamacoder.com/i/algo/20230310000726.png" alt="416.分割等和子集1"></p>
<p>问能否能装满背包（或者最多装多少）：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);  nums是物品的重量</p>
<p>问装满背包有几种方法：dp[j] +&#x3D; dp[j - nums[i]]  dp[0]&#x3D;1</p>
<ul>
<li>dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-coins[i]] + 1) 就是选和不选的简略版</li>
</ul>
<p>问背包装满最大价值：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>问装满背包所有物品的最小个数：dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);  不同于组合&#x2F;排列，顺序不重要</p>
<p>01背包：</p>
<ul>
<li>二维：先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</li>
<li>一维：只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。因为从小到大的话同一轮的同一物品会被反复使用</li>
</ul>
<p>完全背包：</p>
<p>纯完全背包的一维：先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。组合不看顺序，先遍历物品的话，肯定是1,1,2，不可能出现1,2,1的顺序，顺序是从小到大固定的，先考虑所有用 <code>1</code> 的情况，再在这些基础上加入 <code>2</code>，再加入 <code>3</code></p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。区分顺序，所以先固定容量，再调顺序，这样会出现1,2,1的情况</p>
<h2 id="10-29-打家劫舍"><a href="#10-29-打家劫舍" class="headerlink" title="10.29 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">10.29 打家劫舍</a></h2><p>不能抢劫相邻房屋，问能偷窃到的最大数量</p>
<p>dp[i] 表示0-i-1间能偷窃到的最大数量，dp[i]&#x3D;max(dp[i-1], dp[i -2] + nums[i])</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="10-30-打家劫舍-II"><a href="#10-30-打家劫舍-II" class="headerlink" title="10.30 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">10.30 打家劫舍 II</a></h2><p>房屋围成一个圈，环状排列意味着第一个房子和最后一个房子中 <strong>只能选择一个偷窃</strong></p>
<p>把环拆成两个队列，一个是从0到n-1（不偷窃最后一个房子），另一个是从1到n（不偷窃第一个房子），然后返回两个结果最大的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">robRange</span>(<span class="params">start, end</span>):<span class="comment">#表示[start, end]可偷窃的最大金额</span></span><br><span class="line">            <span class="keyword">if</span> end == start:</span><br><span class="line">                <span class="keyword">return</span> nums[start]</span><br><span class="line">            prev = nums[start] <span class="comment"># 表示dp[i - 2]</span></span><br><span class="line">            curr = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]) <span class="comment"># 表示dp[i - 1]</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">2</span>, end + <span class="number">1</span>):</span><br><span class="line">                tmp = curr</span><br><span class="line">                curr = <span class="built_in">max</span>(curr, prev + nums[i])</span><br><span class="line">                prev = tmp</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(robRange(<span class="number">0</span>, n - <span class="number">2</span>), robRange(<span class="number">1</span>, n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>比较好理解的方法：第一个房间偷或者不偷。偷的话，只能从第一间累积到第n-1间房子；不偷的话，从第二间累积到最后一间。比较两种情况大小即可。</p>
<h2 id="10-31-打家劫舍-III"><a href="#10-31-打家劫舍-III" class="headerlink" title="10.31 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">10.31 打家劫舍 III</a></h2><p>如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子</p>
<p>暴力递归：分为偷父节点和不偷，过程中有重复计算，会超时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 偷该节点：</span></span><br><span class="line">        val1 = root.val</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            val1 += <span class="variable language_">self</span>.rob(root.left.left) + <span class="variable language_">self</span>.rob(root.left.right)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            val1 += <span class="variable language_">self</span>.rob(root.right.left) + <span class="variable language_">self</span>.rob(root.right.right)</span><br><span class="line">        <span class="comment"># 不偷该节点</span></span><br><span class="line">        val2 = <span class="variable language_">self</span>.rob(root.left) + <span class="variable language_">self</span>.rob(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(val1, val2)</span><br></pre></td></tr></table></figure>

<p>记忆化递推：用map把结果保存一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    memory = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.memory.get(root) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.memory[root]</span><br><span class="line">        <span class="comment"># 偷该节点：</span></span><br><span class="line">        val1 = root.val</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            val1 += <span class="variable language_">self</span>.rob(root.left.left) + <span class="variable language_">self</span>.rob(root.left.right)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            val1 += <span class="variable language_">self</span>.rob(root.right.left) + <span class="variable language_">self</span>.rob(root.right.right)</span><br><span class="line">        <span class="comment"># 不偷该节点</span></span><br><span class="line">        val2 = <span class="variable language_">self</span>.rob(root.left) + <span class="variable language_">self</span>.rob(root.right)</span><br><span class="line">        <span class="variable language_">self</span>.memory[root] = <span class="built_in">max</span>(val1, val2)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.memory[root]</span><br></pre></td></tr></table></figure>

<p>在上面两种方法，其实对一个节点 偷与不偷得到的最大金钱都没有做记录，而是需要实时计算。</p>
<p>而动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。</p>
<p>树形DP：</p>
<ol>
<li>确定参数和返回值，每个节点分为偷与不偷，返回值是长度为2的数组，令下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</li>
<li>终止条件：遇到空节点是0</li>
<li>遍历顺序：后序遍历，因为需要子节点的值</li>
<li>递归逻辑：偷当前节点，那左右孩子就不能偷，不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">node</span>): <span class="comment"># 0代表不选，1代表选</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            left = traversal(node.left)</span><br><span class="line">            right = traversal(node.right)</span><br><span class="line">            <span class="comment"># 不偷该节点，子节点也不一定要偷，选大的</span></span><br><span class="line">            val0 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 偷该节点，子节点选不了</span></span><br><span class="line">            val1 = node.val + left[<span class="number">0</span>] + right[<span class="number">0</span>] <span class="comment"># 注意是node.val不是root.val，别写错了</span></span><br><span class="line">            <span class="keyword">return</span> (val0, val1)</span><br><span class="line">        dp = traversal(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp) <span class="comment"># 可以直接选二元组的最大值</span></span><br></pre></td></tr></table></figure>

<h2 id="10-32-买卖股票的最佳时机"><a href="#10-32-买卖股票的最佳时机" class="headerlink" title="10.32 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">10.32 买卖股票的最佳时机</a></h2><p>循环过程用当前节点值与之前记录的股票最小价格作比较，若小于则更新当前值为最小股票价格，若大于则用当前值减去已记录的最小股票价格，结果与记录的最大利润作比较，若大于则更新为最大利润</p>
<p>这是贪心的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        curr_min = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; curr_min:</span><br><span class="line">                curr_min = prices[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(res, prices[i] - curr_min)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>上面的思路也可以用dp解释，可解释性更强，<code>dp[i]</code> 表示 从 第0 到 第i 天，必须进行一轮买卖操作，能获得的最大收益。</p>
<ul>
<li>选择在 前 i-1 天完成一轮买卖操作，则 第 i 天不能做任何操作，问题转化为 <code>dp[i-1]</code>。</li>
<li>选择在 前 i-1 天做买入操作，在第 i 天做卖出操作，即从 第0 到 第i 天，进行一轮买卖操作。在这种情况下，卖出操作的价格一定是 prices[i]，为了使收益最大，买入操作的价格应当是 前i-1天中价格的最小值，<code>low = min(prices[0], prices[1], ..., prices[i-1]) </code>。收益为 <code>prices[i] - low</code>。</li>
</ul>
<p>dp[i][0]代表第i天过后手上有股票时的最大收益，dp[i][1]代表第i天过后手上无股票时的最大收益</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = [-prices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], - prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], + prices[i] + dp[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-33-周总结"><a href="#10-33-周总结" class="headerlink" title="10.33 周总结"></a>10.33 周总结</h2><ul>
<li>dp[i][0] 表示第i天持有股票所得现金。</li>
<li>dp[i][1] 表示第i天不持有股票所得最多现金</li>
</ul>
<h2 id="10-34-买卖股票的最佳时机-II"><a href="#10-34-买卖股票的最佳时机-II" class="headerlink" title="10.34 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">10.34 </a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 贪心，只要有赚就卖</span></span><br><span class="line">        len_ = <span class="built_in">len</span>(prices)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        curr_price = prices[<span class="number">0</span>]</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len_:</span><br><span class="line">            <span class="keyword">if</span> curr_price &lt; prices[i]:</span><br><span class="line">                max_profit += prices[i] - curr_price</span><br><span class="line">            curr_price = prices[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>持有股票（<code>dp[i][0]</code>）</strong>：表示在第 <code>i</code> 天结束时，手中持有一支股票。<ul>
<li>这个状态可以由两种方式达到：<ul>
<li>在第 <code>i-1</code> 天已经持有股票，第 <code>i</code> 天不进行任何操作（即 <code>dp[i-1][0]</code>）。</li>
<li>在第 <code>i-1</code> 天不持有股票，第 <code>i</code> 天买入股票（即 <code>dp[i-1][1] - prices[i]</code>）。</li>
</ul>
</li>
<li>因此，<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])</code>。</li>
</ul>
</li>
<li><strong>不持有股票（<code>dp[i][1]</code>）</strong>：表示在第 <code>i</code> 天结束时，手中不持有股票。<ul>
<li>这个状态也可以由两种方式达到：<ul>
<li>在第 <code>i-1</code> 天已经不持有股票，第 <code>i</code> 天不进行任何操作（即 <code>dp[i-1][1]</code>）。</li>
<li>在第 <code>i-1</code> 天持有股票，第 <code>i</code> 天卖出股票（即 <code>dp[i-1][0] + prices[i]</code>）。</li>
</ul>
</li>
<li>因此，<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = [-prices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], - prices[i] + dp[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], + prices[i] + dp[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>也可以节约空间，只开两个数组：存以前和当前状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="comment">#注意这里只开辟了一个2 * 2大小的二维数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[(i-<span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>], dp[(i-<span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>] - prices[i])</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[(i-<span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], dp[(i-<span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[(length-<span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-35-买卖股票的最佳时机-III"><a href="#10-35-买卖股票的最佳时机-III" class="headerlink" title="10.35 买卖股票的最佳时机 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">10.35 买卖股票的最佳时机 III</a></h2><p>最多进行两笔交易，可以只进行一笔或不进行</p>
<p>dp[i][0]代表第i天过后第一次买股票时的最大收益，dp[i][1]代表第i天过后第一次卖股票时的最大收益，dp[i][2]代表第i天过后第二次买股票时的最大收益，dp[i][3]代表第i天过后第二次卖股票时的最大收益</p>
<p>注意并不是要在第i天买，0-i天都能买</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = [-prices[<span class="number">0</span>], <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span>] <span class="comment"># 在同一天反复买卖都是0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">            <span class="comment"># 只可能是负的</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]) <span class="comment"># 第一次卖的只能是第一次买的</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]) <span class="comment"># 第二次买需要把第一次卖了</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-36-买卖股票的最佳时机-IV"><a href="#10-36-买卖股票的最佳时机-IV" class="headerlink" title="10.36 买卖股票的最佳时机 IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">10.36 买卖股票的最佳时机 IV</a></h2><p>最多可以买k次，卖k次，比如上一道题k&#x3D;2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] * k <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = [-prices[<span class="number">0</span>], <span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k): <span class="comment"># 最多买卖k次</span></span><br><span class="line">                <span class="comment"># 如果是2*j，就是买入，如果是2*j+1，就是卖出</span></span><br><span class="line">                dp[i][j * <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j * <span class="number">2</span>], -prices[i] + (dp[i - <span class="number">1</span>][j * <span class="number">2</span> - <span class="number">1</span>] <span class="keyword">if</span> j != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>))</span><br><span class="line">                dp[i][j * <span class="number">2</span> + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j * <span class="number">2</span> + <span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][j * <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-37-买卖股票的最佳时机含冷冻期"><a href="#10-37-买卖股票的最佳时机含冷冻期" class="headerlink" title="10.37 买卖股票的最佳时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">10.37 买卖股票的最佳时机含冷冻期</a></h2><p>有一天冷冻期，注意卖没有冷冻期，买才有冷冻期！第一次写时把dp[i][1]的也写成i-2了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment">#0表示第i天后持有，1表示第i天后无持有</span></span><br><span class="line">        dp[<span class="number">0</span>] = [-prices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i] + (dp[i - <span class="number">2</span>][<span class="number">1</span>] <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)) <span class="comment">#卖了前面的，买今天的</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]) <span class="comment"># 今天卖掉，卖没有冷冻期，买才有冷冻期！</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-38-周总结"><a href="#10-38-周总结" class="headerlink" title="10.38 周总结"></a>10.38 周总结</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solutions/2199035/yi-tao-mo-ban-ji-xing-dai-ma-bi-zhao-yan-0ap8/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/solutions/2199035/yi-tao-mo-ban-ji-xing-dai-ma-bi-zhao-yan-0ap8/</a> 看这个题解，最好懂，买是花钱要-prices，卖是赚钱+</p>
<h2 id="10-39-买卖股票的最佳时机含手续费"><a href="#10-39-买卖股票的最佳时机含手续费" class="headerlink" title="10.39 买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">10.39 买卖股票的最佳时机含手续费</a></h2><p>注意买入持有并卖出只用付一次手续费，不用重复，统一在卖出时计算即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment">#0表示第i天后持有，1表示第i天后无持有</span></span><br><span class="line">        dp[<span class="number">0</span>] = [-prices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i] + (dp[i - <span class="number">1</span>][<span class="number">1</span>] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)) <span class="comment"># 购买</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>] - fee)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-40-股票总结"><a href="#10-40-股票总结" class="headerlink" title="10.40 股票总结"></a>10.40 股票总结</h2><p>一共六道题</p>
<p>记住除了0以外，偶数是卖出，奇数是买入，为i天构建二维数组</p>
<h2 id="10-41-最长递增子序列"><a href="#10-41-最长递增子序列" class="headerlink" title="10.41 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">10.41 最长递增子序列</a></h2><p>试了一下dp[n]表示0-n的最长递增子序列的长度，但这样不知道现有的子序列的最大值，而且可能有同一长度多种选择，不知道该怎么写</p>
<p>解决方案是定义<strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong>，这里以nums[i]结尾很重要。有了这个定义我就会写了dp[i] &#x3D; max(dp[i], dp[j] + 1);，即对比之前的dp值，如果当前nums大就得到了新的递增子序列。注意最大值不一定是dp[n-1]！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans <span class="comment"># 最大值不一定是dp[n-1]取到，因为限制了结束的数值</span></span><br></pre></td></tr></table></figure>

<h2 id="10-42-最长连续递增序列"><a href="#10-42-最长连续递增序列" class="headerlink" title="10.42 最长连续递增序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">10.42 最长连续递增序列</a></h2><p>不断更新左右区间，因为是连续所以简单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfLCIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 这里保证[l,r]中的子序列都是递增的，不断更新区间</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[r] &lt;= nums[r - <span class="number">1</span>]:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, r - l)</span><br><span class="line">                l = r</span><br><span class="line">                r = l + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 可能一直递增，跳出循环了也没更新，所以这里要更新下</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>如果用dp的定义，仍然是以i结尾的连续递增的子序列长度为dp[i]，即dp[i] &#x3D; dp[i - 1] + 1;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLengthOfLCIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="10-43-最长重复子数组"><a href="#10-43-最长重复子数组" class="headerlink" title="10.43 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">10.43 最长重复子数组</a></h2><p>就是有一小段既要数字相同，也要顺序相同</p>
<p>dp[i][j]中i和j表示结尾都比较奇怪</p>
<p><code>dp[i][j]</code> 表示以 <code>nums1[i-1]</code> 和 <code>nums2[j-1]</code> 结尾的最长公共子数组的长度（是连续的，因为是连续，所以可以-1，而不是要把前面的0-i全部遍历一遍）</p>
<p>如果 <code>nums1[i-1] == nums2[j-1]</code>，那么这两个元素可以接在前一对公共子数组之后： <code>dp[i][j] = dp[i-1][j-1] + 1</code></p>
<p>否则，这两个元素不相等，无法继续相同子数组：<code>dp[i][j] = 0</code></p>
<p><strong>注意dp中一般把0空出来</strong>，也就是定义dp[n + 1]，这样不用处理特殊的0，也不容易出现负下表、</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLength</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)] <span class="comment"># 定义dp[m + 1][n + 1]，表示以 `nums1[i-1]` 和 `nums2[j-1]` 结尾的最长公共子数组的长度</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>这里最难的是状态转移方程，要理解最长公共子数组的表现是连续的，以及和下标的关系</p>
<h2 id="10-44-最长公共子序列"><a href="#10-44-最长公共子序列" class="headerlink" title="10.44 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">10.44 最长公共子序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2) <span class="comment"># m=5,n=3</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]<span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2) <span class="comment"># m=5,n=3</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<p>dp[i][j]是text1[i-1]和text2[j-1]，列举相等和不相等的情况，用归纳法很合适</p>
<h2 id="10-45-不相交的线"><a href="#10-45-不相交的线" class="headerlink" title="10.45 不相交的线"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">10.45 不相交的线</a></h2><p>其实就是最大公共子数组的长度，不一定连续，但要按顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxUncrossedLines</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h2 id="10-46-最大子数组和"><a href="#10-46-最大子数组和" class="headerlink" title="10.46 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">10.46 最大子数组和</a></h2><p>dp[i]表示以nums[i-1]结尾的，一定要选</p>
<p>遇到全是负值的，该如何处理？下面是一种写法，但用了max库函数，增加了O(n)，并不好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(nums) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (m + <span class="number">1</span>)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(<span class="number">0</span>, dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>下面这种更符合题意，因为dp的定义就是必须选nums[i-1]，所以有可能是负值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="comment"># 表示必须选nums[i - 1]</span></span><br><span class="line">        ans = -inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(<span class="number">0</span>, dp[i - <span class="number">1</span>]) + nums[i - <span class="number">1</span>] <span class="comment"># 这个值可能是负值，因为至少包含一个元素</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="10-47-判断子序列"><a href="#10-47-判断子序列" class="headerlink" title="10.47 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">10.47 判断子序列</a></h2><p>我就是用移动下标的方法做这道题：双指针</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == m:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>后续挑战：如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？每个字符串都要遍历t，都需要O(n)，太慢了</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>剩余部分</th>
<th><code>&#39;a&#39;</code></th>
<th><code>&#39;b&#39;</code></th>
<th><code>&#39;c&#39;</code></th>
<th><code>&#39;d&#39;</code></th>
<th><code>&#39;g&#39;</code></th>
<th><code>&#39;h&#39;</code></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>ahbgdc</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>hbgdc</td>
<td>-1</td>
<td>2</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>bgdc</td>
<td>-1</td>
<td>2</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>3</td>
<td>gdc</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>4</td>
<td>dc</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>4</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>5</td>
<td>c</td>
<td>-1</td>
<td>-1</td>
<td>5</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>6</td>
<td>（末尾之后）</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<p>last[t[i] - ‘a’] &#x3D; i这样写会报错，要写成ord，就是把字符写成对应的unicode值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_next</span>(<span class="params">self, t: <span class="built_in">str</span></span>):</span><br><span class="line">        n = <span class="built_in">len</span>(t)</span><br><span class="line">        nxt = [[-<span class="number">1</span>]*<span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="comment"># 位置n默认就是-1了</span></span><br><span class="line">        last = [-<span class="number">1</span>] * <span class="number">26</span> <span class="comment"># 记录当前扫描位置之后，字母 c 最近一次出现的下标</span></span><br><span class="line">        <span class="comment"># 从后往前遍历是为了更新最近一次出现的下标，应对重复出现的场景</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            last[<span class="built_in">ord</span>(t[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] = i <span class="comment"># &#x27;a&#x27;的ascii码是97</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                nxt[i][c] = last[c] <span class="comment"># 把当前位置的情况赋值给next</span></span><br><span class="line">        <span class="keyword">return</span> nxt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nxt = <span class="variable language_">self</span>.build_next(t)</span><br><span class="line">        pos = <span class="number">0</span> <span class="comment"># 当前寻找的下标</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            j = nxt[pos][<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] <span class="comment"># 就是离pos最近的c出现的下标</span></span><br><span class="line">            <span class="keyword">if</span> j == -<span class="number">1</span>: <span class="comment"># 没找到c</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pos = j + <span class="number">1</span> <span class="comment"># 从下一个地方开始找，不用担心越界，因为刚越界时是-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="10-48-不同的子序列"><a href="#10-48-不同的子序列" class="headerlink" title="10.48 不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">10.48 不同的子序列</a></h2><p>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。 t中一定要出现</p>
<p>一个难点是相等的情况，也可以不选当前s[i-1]，另一个难点是初始化的情况，并不是简单的只用设置0,0，这是因为递推公式一开始就涉及[0][1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 需要初始化dp[0][i]或dp[i][0]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>): <span class="comment"># t为空字符串的情况，个数为1，把字符删光即可</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># s没有字符，除了j=0，其他情况都不可能得到t</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># 因为t一定要有，所以j &gt; i时肯定为0</span></span><br><span class="line">                <span class="keyword">if</span> s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] <span class="comment"># 分为选当前s或者不选</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h2 id="10-49-两个字符串的删除操作"><a href="#10-49-两个字符串的删除操作" class="headerlink" title="10.49 两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">10.49 两个字符串的删除操作</a></h2><p>dp[i][j]：以word1[i-1]结尾的字符串和以word2[j-1]结尾的字符串相同所需的最小步数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span> <span class="comment"># 删了当前的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h2 id="10-50-编辑距离"><a href="#10-50-编辑距离" class="headerlink" title="10.50 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">10.50 编辑距离</a></h2><p>dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h2 id="10-51-回文子串"><a href="#10-51-回文子串" class="headerlink" title="10.51 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">10.51 回文子串</a></h2><p>虽然看提示，说xax是回文，那bxaxb也是回文，但不知道怎么写状态转移方程</p>
<p>还停留在dp[i][j]表示s[i][j]是回文串，不过这个定义是对的，不是定义dp[i]为结尾的字符串有几个回文子串，那就完全写不出来了</p>
<p>虽然这个定义是对的，但不知道i&#x2F;j该从中间开始遍历吗？感觉很奇怪</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a>中，找到s中最长的回文子串，就是分别找奇数串和偶数串，以s[i]为中心，i不断变化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        len_ = <span class="built_in">len</span>(s)</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 记录最长回文子串的起点和终点，左闭右闭</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*len_ - <span class="number">1</span>):<span class="comment">#0-9</span></span><br><span class="line">            left, right = i // <span class="number">2</span>, (i + <span class="number">1</span>) // <span class="number">2</span> </span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; len_ <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 循环结束后，s[left + 1]到s[right - 1]是回文串，是闭区间，注意这个细节</span></span><br><span class="line">            <span class="keyword">if</span> right - left - <span class="number">1</span> &gt; max_len:</span><br><span class="line">                max_len = right - left - <span class="number">1</span></span><br><span class="line">                start, end = left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start: end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>简洁的写法是把两个循环合并成一个</p>
<p>在这道题中，也可以用中心扩展法（双指针），来统计回文串的个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span> * n - <span class="number">1</span>):</span><br><span class="line">            l, r = i // <span class="number">2</span>, (i + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>动态规划：布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li>
</ul>
<p>初始化和遍历顺序：由于依赖i+1,j-1，所以i从大到小，j从小到大（当然本身&gt;&#x3D;i），i和j的顺序倒无所谓</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt;= <span class="number">1</span>: </span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="10-52-最长回文子序列"><a href="#10-52-最长回文子序列" class="headerlink" title="10.52 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">10.52 最长回文子序列</a></h2><p>本来想用上面的回文子串做的，然后发现这里的回文子序列可以不连续，所以要用动态规划</p>
<p>dp[i][j]表示s的i-j范围内的最长回文子序列长度</p>
<p>如果s[i]&#x3D;&#x3D;s[j]，则如果i&#x3D;&#x3D;j，dp&#x3D;1；j-i&#x3D;1，dp&#x3D;2，j - i&gt;1，dp&#x3D;dp[i + 1][j - 1] + 2</p>
<p>若不等，则dp&#x3D;max(dp[i + 1][j], dp[i][j - 1])</p>
<p>同样，i从大到小，j从小到大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j == i:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> j - i == <span class="number">1</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-53-总结"><a href="#10-53-总结" class="headerlink" title="10.53 总结"></a>10.53 总结</h2><p>背包问题：遍历顺序很重要</p>
<p>打家劫舍</p>
<p>股票</p>
<p>子序列</p>
<p>关于动规，还有 树形DP（打家劫舍系列里有一道），数位DP，区间DP ，概率型DP，博弈型DP，状态压缩dp等等等，这些我就不去做讲解了，面试中出现的概率非常低。</p>
<h1 id="11-单调栈"><a href="#11-单调栈" class="headerlink" title="11. 单调栈"></a>11. 单调栈</h1><h2 id="11-1-每日温度"><a href="#11-1-每日温度" class="headerlink" title="11.1 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">11.1 每日温度</a></h2><p>只知道该存索引，但不知道该怎么存，从前往后从后往前的话该存什么</p>
<p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p>
<ol>
<li>存下标i即可，因为元素可以通过t[i]访问获得</li>
<li>本质是空间换时间</li>
</ol>
<p>从右到左的写法：栈中记录的是下一个更大元素的候选项的下标，发现索引更小、数值更大的元素就开除现有的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        answer = [<span class="number">0</span>] * n</span><br><span class="line">        st = [] <span class="comment"># 从栈底到栈顶是递减的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            t = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt;= temperatures[st[-<span class="number">1</span>]]:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">if</span> st: <span class="comment"># 现在st里的数都大于t</span></span><br><span class="line">                answer[i] = st[-<span class="number">1</span>] - i</span><br><span class="line">            st.append(i) <span class="comment"># 变成新的栈顶，最小的</span></span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>

<p>从左到右的写法：存的是目前还没找到比自己更大的元素的下标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        answer = [<span class="number">0</span>] * n</span><br><span class="line">        st = [] <span class="comment"># 从栈底到栈顶是递减的，存还没遇到最大值的下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            t = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt; temperatures[st[-<span class="number">1</span>]]: <span class="comment"># 栈</span></span><br><span class="line">                j = st.pop()</span><br><span class="line">                answer[j] = i - j</span><br><span class="line">            <span class="comment"># 即使还有st，大于t，也不可能得到answer，因为下标小，当前的数肯定是直接加入的</span></span><br><span class="line">            st.append(i)</span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>

<h2 id="11-2-下一个更大元素-I"><a href="#11-2-下一个更大元素-I" class="headerlink" title="11.2 下一个更大元素 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">11.2 下一个更大元素 I</a></h2><p>其实就是用单调栈得到nums2每个数字的下一个更大元素</p>
<p>我感觉必须得用一个dict建立nums2中数值和索引的映射，才能让nums1映射上。重点就是这里，直接建立数字-&gt;下一个更大元素的映射</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        ans = [-<span class="number">1</span>] * m </span><br><span class="line">        dict_ = &#123;&#125;</span><br><span class="line">        st = [] <span class="comment"># 从栈顶到栈底是递减的，存的是数值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            num = nums2[i]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> num &gt;= st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                dict_[num] = st[-<span class="number">1</span>] <span class="comment"># 建立数字-&gt;下一个更大元素的映射</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict_[num] = -<span class="number">1</span> <span class="comment"># 说明没有下一个更大元素</span></span><br><span class="line">            st.append(num)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            num = nums1[i]</span><br><span class="line">            ans[i] = dict_[num]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>用于列表</th>
<th>用于字符串</th>
<th>是否原地修改</th>
<th>返回结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>list.reverse()</code></td>
<td>✅ 可以</td>
<td>❌ 不可用</td>
<td>✅ 是（原地修改）</td>
<td>返回 <code>None</code></td>
</tr>
<tr>
<td><code>reversed(x)</code></td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>❌ 否</td>
<td>返回一个反转迭代器</td>
</tr>
<tr>
<td><code>x[::-1]</code></td>
<td>✅ 可以</td>
<td>✅ 可以</td>
<td>❌ 否</td>
<td>返回反转后的新对象</td>
</tr>
</tbody></table>
<p>字符串的反转可以写：<code>&#39;&#39;.join(reversed(s))</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        next_greater = &#123;&#125;   <span class="comment"># num -&gt; 右侧第一个更大值（没有则 -1）</span></span><br><span class="line">        st = []             <span class="comment"># 单调递减栈，存数值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(nums2): <span class="comment"># 这里是反转数组，但不会原地修改nums2</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> st[-<span class="number">1</span>] &lt;= x:</span><br><span class="line">                st.pop()</span><br><span class="line">            next_greater[x] = st[-<span class="number">1</span>] <span class="keyword">if</span> st <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            st.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [next_greater[x] <span class="keyword">for</span> x <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure>

<h2 id="11-3-下一个更大元素-II"><a href="#11-3-下一个更大元素-II" class="headerlink" title="11.3 下一个更大元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">11.3 下一个更大元素 II</a></h2><p>就是这里的更大是循环的，也就是除了最大值没有更大的元素，其他值都是有更大的元素的</p>
<p>除了nums最后一个数，其他都是和前面的单调栈一样的，最后一个数又需要从nums[0]开始找</p>
<ul>
<li>这种写法不对，比如[5,4,3,2,1]的结果是[-1,5,5,5,5]，而不是[-1,-1,-1,-1,5]</li>
</ul>
<p>真正的方法就是把数组拼接起来，把数组看两遍，从右往左扫下标 <code>i = 2n-1…0</code>，实际位置用idx &#x3D; i % n</p>
<p>[5,4,3,2,1,5,4,3,2,1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        st = [] <span class="comment"># 单调递减的</span></span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            idx = i % n</span><br><span class="line">            x = nums[idx]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> x &gt;= st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="comment"># 剩下的数是比x大的</span></span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                ans[idx] = st[-<span class="number">1</span>]</span><br><span class="line">            st.append(x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="11-4-接雨水"><a href="#11-4-接雨水" class="headerlink" title="11.4 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">11.4 接雨水</a></h2><p>也可以用单调栈，但反而比较复杂，所以我没看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 从左到右存出现过的最大值，从右到左也是，然后用两个较大值中小的一个减去自己</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        l, r = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">        curr_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, h <span class="keyword">in</span> <span class="built_in">enumerate</span>(height):</span><br><span class="line">            curr_max = <span class="built_in">max</span>(curr_max, h)</span><br><span class="line">            l[i] = curr_max</span><br><span class="line">        curr_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            curr_max = <span class="built_in">max</span>(curr_max, height[i])</span><br><span class="line">            r[i] = curr_max</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += <span class="built_in">min</span>(l[i], r[i]) - height[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="11-5-柱状图中最大的矩形"><a href="#11-5-柱状图中最大的矩形" class="headerlink" title="11.5 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">11.5 柱状图中最大的矩形</a></h2><p>以每根柱子作为<strong>矩形的最低高度</strong>来扩展其<strong>左右可延伸的宽度</strong>，就能得到以这根柱子为“短板”的最大矩形面积。</p>
<p>如果我们知道每根柱子<strong>向左</strong>和<strong>向右</strong>第一个<strong>严格小于</strong>它的柱子位置，就能立刻算出这根柱子能撑起的最大矩形面积：</p>
<p>areai&#x3D;heighti×(rightLessi−leftLessi−1)</p>
<p>单调栈正是用来<strong>一次遍历</strong>就找出每根柱子的“左&#x2F;右第一个更小”。</p>
<p>和接雨水的区别就在于，接雨水是找大的，这里是找小的，利用现在的高度，然后接雨水不需要第一个大的，但这里需要第一个小的，所以这里要使用单调栈得到l和r数组</p>
<p>这里单调栈是找左右第一个更小的，所以要维护单调递增的栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(heights)</span><br><span class="line">        l, r = [-<span class="number">1</span>] * n, [n] * n</span><br><span class="line">        st = [] <span class="comment"># 递增，存的是下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先找左边的第一个更小元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            h = heights[i]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> heights[st[-<span class="number">1</span>]] &gt;= h:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                l[i] = st[-<span class="number">1</span>]</span><br><span class="line">            st.append(i)</span><br><span class="line">        </span><br><span class="line">        st = []</span><br><span class="line">        <span class="comment"># 再找右边的第一个更小元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            h = heights[i]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> heights[st[-<span class="number">1</span>]] &gt;= h:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                r[i] = st[-<span class="number">1</span>]</span><br><span class="line">            st.append(i)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            width = r[i] - l[i] - <span class="number">1</span></span><br><span class="line">            area = heights[i] * width</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, area)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>当然也有一种简单的写法，只需要遍历一次：这种写法是因为k就是当前高度stack[-1]的right下标，而把stack[-1]pop出来后，剩下的stack[-1]就是left的下标，这样就无需记录left和right数组了，在一次遍历O(n)的过程中可以得到res</p>
<p>为什么这里没有&gt;&#x3D;呢，因为上面是要找第一个严格小于的元素，不能让相等的柱子互当边界，而下面也是为了合并相同高度的矩形，其实都是处理相等的情况，是一个意思</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        stack = [-<span class="number">1</span>]</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> k, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(heights):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &gt; num: <span class="comment">#破坏了栈的单调递增性</span></span><br><span class="line">                index = stack.pop() <span class="comment">#以该元素作为高度</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, heights[index] * (k - stack[-<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">            stack.append(k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="12-图论"><a href="#12-图论" class="headerlink" title="12. 图论"></a>12. 图论</h1><h2 id="12-1-图论基础"><a href="#12-1-图论基础" class="headerlink" title="12.1 图论基础"></a>12.1 图论基础</h2><p>度：无向图中有几条边连接该节点</p>
<p>连通图：在无向图中，任何两个节点都是可以到达的</p>
<p>在无向图中的极大连通子图称之为该图的一个连通分量。</p>
<p>在有向图中极大强连通子图称之为该图的强连通分量。</p>
<p>邻接矩阵：对于无向图，就是双向边grid[2][5] &#x3D; 6，grid[5][2] &#x3D; 6。缺点是图很稀疏</p>
<img src="https://file1.kamacoder.com/i/algo/20240222110025.png" alt="img" style="zoom:50%;" />

<p>邻接表：使用数组存节点，使用链表存节点指向的每个点。遍历节点连接的情况容易，但检查任意两个节点之间是否存在边，效率就很低</p>
<img src="https://file1.kamacoder.com/i/algo/20240223103713.png" alt="img" style="zoom:50%;" />

<p>图论，就是在图（邻接表或邻接矩阵）上进行搜索（BFS或DFS）</p>
<h2 id="12-2-DFS"><a href="#12-2-DFS" class="headerlink" title="12.2 DFS"></a>12.2 DFS</h2><p>DFS：找到目标后再回头，回头就是回溯</p>
<p>用递归是最方便的，回溯就在递归函数的下面一步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    处理节点</span><br><span class="line">    <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯和dfs差不多：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123; <span class="comment">//确定参数</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-3-可达路径"><a href="#12-3-可达路径" class="headerlink" title="12.3 可达路径"></a>12.3 可达路径</h2><h2 id="12-4-BFS"><a href="#12-4-BFS" class="headerlink" title="12.4 BFS"></a>12.4 BFS</h2><p>适合于解决两个点之间的最短路径问题，一旦遇到终点，就是最短路</p>
<p>岛屿问题是BFS和DFS都可以解决，因为只要能把相邻且相同属性的节点标记上就行</p>
<p>这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。</p>
<p>其实，我们仅仅需要一个容器，能<strong>保存我们要遍历过的元素</strong>就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p>
<p><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。</p>
<ul>
<li>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</li>
</ul>
<p><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。</p>
<ul>
<li>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</li>
</ul>
<p> BFS本身不需要注意 转圈搜索的顺序，但大家都习惯用队列了，因为搜索顺序不会变</p>
<h1 id="13-额外题目"><a href="#13-额外题目" class="headerlink" title="13. 额外题目"></a>13. 额外题目</h1><h2 id="13-1-有多少小于当前数字的数字"><a href="#13-1-有多少小于当前数字的数字" class="headerlink" title="13.1 有多少小于当前数字的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/">13.1 有多少小于当前数字的数字</a></h2><p>想的是先排序，然后找每个数字在正序数组中的位置</p>
<p>排序之后，每个数值的下标就代表有几个比它小的了，用哈希表记录每个数字的下标</p>
<p>如果用nums.sort()，是直接对原数组进行排序，如果用sorted(nums)，是产生新对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallerNumbersThanCurrent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        d = &#123;&#125; <span class="comment"># 映射数值-&gt;下标</span></span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 如果有多个相同的数值，只需要存第一个出现的，后面出现的跟的第一个出现的一样，所以倒序遍历</span></span><br><span class="line">            d[sorted_nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> [d[n] <span class="keyword">for</span> n <span class="keyword">in</span> nums]</span><br></pre></td></tr></table></figure>

<p>O(nlogn)</p>
<h2 id="13-2-有效的山脉数组"><a href="#13-2-有效的山脉数组" class="headerlink" title="13.2 有效的山脉数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-mountain-array/">13.2 有效的山脉数组</a></h2><p>就是有且只有一个最大值，不能出现在开头或结尾，要寻找这个变化点</p>
<p> 我没想出来，应该用双指针的方法，保证左边到中间，和右边到中间是递增的</p>
<p>我又犯了一个错误，while中l和r不应该一起移动</p>
<p>还要注意一个细节，递增和递减序列，这样也会得到l&#x3D;&#x3D;r，要把这种情况排除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validMountainArray</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        l, r = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; n - <span class="number">1</span> <span class="keyword">and</span> arr[l] &lt; arr[l + <span class="number">1</span>]:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &gt;= <span class="number">1</span> <span class="keyword">and</span> arr[r] &lt; arr[r - <span class="number">1</span>]:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l == r <span class="keyword">and</span> l != <span class="number">0</span> <span class="keyword">and</span> r != n</span><br></pre></td></tr></table></figure>

<h2 id="13-3-独一无二的出现次数"><a href="#13-3-独一无二的出现次数" class="headerlink" title="13.3 独一无二的出现次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-number-of-occurrences/">13.3 独一无二的出现次数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniqueOccurrences</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> d: <span class="comment"># 或者写d.count(num, 0) + 1</span></span><br><span class="line">                d[n] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[n] += <span class="number">1</span></span><br><span class="line">        times = d.values() <span class="comment"># 这里返回的是一个对象，可以用set和len，但如果想转为list就是加一个转换；如果想取keys，就是keys()</span></span><br><span class="line">        s = <span class="built_in">set</span>(times)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="built_in">len</span>(times) </span><br></pre></td></tr></table></figure>

<p>注意是出现次数这个数，要独一无二，所以先统计每个数的出现次数，再取set</p>
<p>用Counter库的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniqueOccurrences</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        freq = Counter(arr)  <span class="comment"># 统计出现次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(freq.values()) == <span class="built_in">len</span>(<span class="built_in">set</span>(freq.values()))</span><br></pre></td></tr></table></figure>

<h2 id="13-4-移动零"><a href="#13-4-移动零" class="headerlink" title="13.4 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">13.4 移动零</a></h2><p>我的想法就是遇到0后找第一个非0的数交换，其实就是暴力</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>: <span class="comment"># 从末尾找第一个不是0的数字进行交换</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, i, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> nums[j] != <span class="number">0</span>:</span><br><span class="line">                        nums[i], nums[j] = nums[j], nums[i] <span class="comment"># 使用python原生进行交换</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<p>但是这种暴力方法效率低，用双指针，slow指向下一个应该放置非零元素的位置，fast用于扫描数组，注意并不是每次交换后0就在最后了（fast是正序的，不能倒序！不然会覆盖还没有扫描到的元素）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != <span class="number">0</span>:</span><br><span class="line">                nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<p>另一种直观理解的方法是先把所有非零元素填到前面，剩下的都改为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">                nums[pos] = num</span><br><span class="line">                pos += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 剩余部分填 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="13-5-轮转数组"><a href="#13-5-轮转数组" class="headerlink" title="13.5 轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">13.5 轮转数组</a></h2><p>先把[0,n-k)和[n-k, n)分别进行翻转，再把[0,n)进行翻转</p>
<p>总之记得左旋转、右旋转数组可以分段翻转即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>): <span class="comment"># 这里是翻转[start,end)的数组</span></span><br><span class="line">            l, r = start, end - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k = k % n <span class="comment"># 注意存在k&gt;n的情况，要加这一步</span></span><br><span class="line">        reverse(<span class="number">0</span>, n - k)</span><br><span class="line">        reverse(n - k, n)</span><br><span class="line">        reverse(<span class="number">0</span>, n)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="13-6-寻找数组的中心下标"><a href="#13-6-寻找数组的中心下标" class="headerlink" title="13.6 寻找数组的中心下标"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-pivot-index/">13.6 寻找数组的中心下标</a></h2><p>注意左侧和和右侧和是不包括自己的</p>
<p>感觉要记录前缀和数组，这样后缀和可以通过total-前缀-自己得到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        total = <span class="built_in">sum</span>(nums) <span class="comment"># 这里多此一举了，没必要存储，一次遍历即可</span></span><br><span class="line">        pre = [<span class="number">0</span>] * n <span class="comment"># 存的是左侧元素的和，不包括自己</span></span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            pre[i] = curr</span><br><span class="line">            curr += num</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> pre[i] == total - pre[i] - nums[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> curr == total - curr - num:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            curr += num</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="13-7-在排序数组中查找元素的第一个和最后一个位置"><a href="#13-7-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="13.7 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">13.7 在排序数组中查找元素的第一个和最后一个位置</a></h2><p>递增排列，用二分法，说建议写左闭右开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            idx = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[idx] &lt; target:</span><br><span class="line">                l = idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[idx] &gt; target:</span><br><span class="line">                r = idx - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 说明找到了一个target的，就以它中心扩张</span></span><br><span class="line">                start, end = idx, idx</span><br><span class="line">                <span class="keyword">while</span> start &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[start] == target:</span><br><span class="line">                    start -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> end &lt;= <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="keyword">and</span> nums[end] == target:</span><br><span class="line">                    end += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [start + <span class="number">1</span>, end - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="13-8-按奇偶排序数组-II"><a href="#13-8-按奇偶排序数组-II" class="headerlink" title="13.8 按奇偶排序数组 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-array-by-parity-ii/">13.8 按奇偶排序数组 II</a></h2><p>就是把奇数都移动到奇数的下标上，偶数移动到偶数的下标上</p>
<p>不适用额外空间，就是用双指针，一个指向奇数下标，一个指向偶数下标</p>
<p>我下面的写法效率很低，这是因为没有提前判断<code>nums[j]</code> &#x2F; <code>nums[i]</code> 本身是否已经是正确奇偶，可能会做多余交换，最好把两个错误的奇偶拿来交换，这样就节约交换次数了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArrayByParityII</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): <span class="comment"># 原来写enumerate的问题是，交换后n变了，但没有及时更新</span></span><br><span class="line">            <span class="keyword">while</span> idx % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> nums[idx] % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(nums): <span class="comment"># 移动到奇数下标，但j指向的数可能也是奇，所以循环</span></span><br><span class="line">                nums[idx], nums[j] = nums[j], nums[idx]</span><br><span class="line">                j += <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> idx % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> nums[idx] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">                nums[idx], nums[i] = nums[i], nums[idx]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"><span class="comment"># 改进时是在交换前加if判断奇偶性</span></span><br></pre></td></tr></table></figure>

<p>更简洁的写法：就是用i和j代表需要交换的位置，不需要另外用for+while的形式，肯定是能交换完的，因为数组特点是一半一半：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArrayByParityII</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">1</span>  <span class="comment"># i 指向偶数位，j 指向奇数位</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> nums[j] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                j += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">                j += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="13-9-搜索插入位置"><a href="#13-9-搜索插入位置" class="headerlink" title="13.9 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">13.9 搜索插入位置</a></h2><p>如果出现，就是返回下标，如果没出现，就是插入到升序排列的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            idx = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[idx]:</span><br><span class="line">                <span class="keyword">if</span> idx == <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> idx + <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> target &lt; nums[idx + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> idx + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[idx]:</span><br><span class="line">                <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> target &gt; nums[idx - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> idx</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = idx <span class="comment"># 因为左闭右开</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure>

<p>简洁版的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            idx = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[idx]:</span><br><span class="line">                l = idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[idx]:</span><br><span class="line">                r = idx <span class="comment"># 因为左闭右开</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<h2 id="13-10-两两交换链表中的节点"><a href="#13-10-两两交换链表中的节点" class="headerlink" title="13.10 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">13.10 两两交换链表中的节点</a></h2><p>我没想出来的地方是1. 创建dummy 2. 移动一步（这个想过，但在移动两步中徘徊）3. 返回dummy.next</p>
<p>0 1 2 3 变成 0 2 1 3  1 3 4变成 1 4 3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, cur = dummy, head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            tmp = nxt.<span class="built_in">next</span></span><br><span class="line">            nxt.<span class="built_in">next</span> = cur</span><br><span class="line">            pre.<span class="built_in">next</span> = nxt</span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            pre, cur = cur, cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h1 id="Hot100"><a href="#Hot100" class="headerlink" title="Hot100"></a>Hot100</h1><h2 id="1：160-相交链表"><a href="#1：160-相交链表" class="headerlink" title="1：160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">1：160. 相交链表</a></h2><p>我本来的想法是倒序看两个链表，但链表又只能从头开始。看来还是要用数学技巧</p>
<p>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：<br>a+(b−c)<br>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：<br>b+(a−c)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A != B:</span><br><span class="line">            A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br><span class="line">            B = B.<span class="built_in">next</span> <span class="keyword">if</span> B <span class="keyword">else</span> headA</span><br><span class="line">            <span class="comment">#就是进行了切换，等价于下面，这里的跳跃是技巧</span></span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A = A.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = headB</span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                B = B.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = headA</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>

<h2 id="2：236-二叉树的最近公共祖先"><a href="#2：236-二叉树的最近公共祖先" class="headerlink" title="2：236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">2：236. 二叉树的最近公共祖先</a></h2><p>深度就是第几层，从根节点到该节点，从上往下</p>
<p>高度是倒数第几层，就像楼层一样从下往上</p>
<p>两个节点 <code>p</code>,<code>q</code> 分为两种情况：</p>
<ul>
<li><code>p</code> 和 <code>q</code> 在相同子树中</li>
<li><code>p</code> 和 <code>q</code> 在不同子树中</li>
</ul>
<p>从根节点遍历，递归向左右子树查询节点信息</p>
<p>递归终止条件：如果当前节点为空或等于 p 或 q，则返回当前节点</p>
<p>递归遍历左右子树，如果左右子树查到节点都不为空，则表明 p 和 q 分别在左右子树中，在root的两侧，因此，当前节点root即为最近公共祖先；</p>
<p>如果左右子树其中一个不为空，则返回非空节点。</p>
<ul>
<li>如果left不为空，说明p,q在左子树。</li>
<li>如果right不为空，说明p,q在右子树。</li>
<li>left和right都为空，说明找不到。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="comment">#深度是指第几层，尽可能大说明如果在同侧要尽量往下（就是本身）</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == q <span class="keyword">or</span> root == p:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)<span class="comment">#注意自己调自己要写self</span></span><br><span class="line">        right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:<span class="comment">#说明在同侧的一棵子树上，p/q只能搜到一个</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> <span class="comment">#这题场景中应该不存在找不到</span></span><br></pre></td></tr></table></figure>

<h2 id="3：234-回文链表"><a href="#3：234-回文链表" class="headerlink" title="3：234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">3：234. 回文链表</a></h2><ol>
<li>找中间节点：快慢指针</li>
<li>反转链表：中间到最后的反转了</li>
<li>对比两个链表</li>
</ol>
<p>为什么反转中间而不是一开始就反转全部，当然是为了O(n)节约复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#回文链表是中间对称的</span></span><br><span class="line">        mid = <span class="variable language_">self</span>.middleNode(head)</span><br><span class="line">        head2 = <span class="variable language_">self</span>.reverse(mid)<span class="comment">#注意是mid，不是head</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head2:</span><br><span class="line">            <span class="keyword">if</span> head.val != head2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            head2 = head2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="4：739-每日温度-stack"><a href="#4：739-每日温度-stack" class="headerlink" title="4：739. 每日温度 stack"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">4：739. 每日温度</a> stack</h2><p>单调栈（Monotonic Stack）是一种特殊的栈结构，其元素按照<strong>严格递增或严格递减</strong>的顺序排列。它的核心思想是<strong>利用栈的单调性快速找到元素的前后边界</strong>，常用于解决数组中与“相邻元素大小关系”相关的问题。</p>
<ul>
<li><p>下一次更高的温度出现在几天后，相当于我要把温度排序，得到它的序号作为名次，或者看作折线图（我的想法没有单调栈简单）</p>
</li>
<li><p>从左到右, 更新为主, 去除为辅, 元素可重复。</p>
<p>从右到左, 去除为主, 更新为辅, 元素无重复。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        st = []<span class="comment">#栈内元素在该题中保持递减，存的是下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):<span class="comment">#倒序</span></span><br><span class="line">            t = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt;= temperatures[st[-<span class="number">1</span>]]:<span class="comment">#st的最后一个存的是离自己最近的最高温度 自己比未来&gt;=不算数</span></span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                res[i] = st[-<span class="number">1</span>] - i<span class="comment">#看下标的距离</span></span><br><span class="line">            st.append(i) <span class="comment">#会把当前的加进去</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>从左到右的方法是TODO list</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        st = []<span class="comment">#栈内元素在该题中保持递减，存的是下标</span></span><br><span class="line">        <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):<span class="comment">#从左到右，todo</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt; temperatures[st[-<span class="number">1</span>]]:<span class="comment">#现在比之前的大，则前面的可以解决（注意不是&gt;=号！）</span></span><br><span class="line">                j = st.pop()</span><br><span class="line">                res[j] = i - j<span class="comment">#看下标的距离</span></span><br><span class="line">            st.append(i) <span class="comment">#会把当前的加进去</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="5：226-翻转二叉树"><a href="#5：226-翻转二叉树" class="headerlink" title="5：226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">5：226. 翻转二叉树</a></h2><p>普通递推，注意不用定义tmp，直接用&#x3D;即可进行交换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.left)</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="6：221-最大正方形-dp"><a href="#6：221-最大正方形-dp" class="headerlink" title="6：221. 最大正方形 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">6：221. 最大正方形</a> dp</h2><p>状态转移方程根据不等式来的</p>
<p>&#x3D;别手误写成&#x3D;&#x3D;</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329271.png" alt="image-20250401130758479"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxSide = <span class="number">0</span> <span class="comment">#记录整个图形中出现过最大的边长</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):   <span class="comment">#从左上开始</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:   <span class="comment">#如果为0那dp也为0</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:   <span class="comment">#在边界上</span></span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j])</span><br><span class="line">        maxSquare = maxSide * maxSide</span><br><span class="line">        <span class="keyword">return</span> maxSquare</span><br></pre></td></tr></table></figure>

<h2 id="7：215-数组中的第K个最大元素"><a href="#7：215-数组中的第K个最大元素" class="headerlink" title="7：215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">7：215. 数组中的第K个最大元素</a></h2><p>快速排序：</p>
<ul>
<li><p>哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p>
</li>
<li><p>递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。</p>
</li>
</ul>
<p>这里并没有排序好完整的序列，只是把k所在的地方排序了，节约了时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_select</span>(<span class="params">nums, k</span>):</span><br><span class="line">            pivot = random.choice(nums)</span><br><span class="line">            big, equal, small = [], [], []</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &gt; pivot:</span><br><span class="line">                    big.append(num)</span><br><span class="line">                <span class="keyword">elif</span> num &lt; pivot:</span><br><span class="line">                    small.append(num)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    equal.append(num)</span><br><span class="line">            <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(big):</span><br><span class="line">                <span class="keyword">return</span> quick_select(big, k)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) - <span class="built_in">len</span>(small) &lt; k:<span class="comment">#比如第9大，有10个元素，small有3，就是找small中的第二大</span></span><br><span class="line">                <span class="keyword">return</span> quick_select(small, k - <span class="built_in">len</span>(nums) + <span class="built_in">len</span>(small))</span><br><span class="line">            <span class="keyword">return</span> pivot</span><br><span class="line">        <span class="keyword">return</span> quick_select(nums, k)</span><br></pre></td></tr></table></figure>

<h2 id="8：208-实现-Trie-前缀树-模板题"><a href="#8：208-实现-Trie-前缀树-模板题" class="headerlink" title="8：208. 实现 Trie (前缀树)模板题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">8：208. 实现 Trie (前缀树)</a>模板题</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329395.png" alt="前缀树"></p>
<p>插入单词，检索是否存在，看前缀是否存在</p>
<p> 创建26叉树，像桶排序一样方便查找；然后用bool表示是否结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    __slots__ = <span class="string">&#x27;son&#x27;</span>, <span class="string">&#x27;end&#x27;</span> <span class="comment">#限制属性以节省内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.son = [<span class="literal">None</span>] * <span class="number">26</span></span><br><span class="line">        <span class="variable language_">self</span>.end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur = <span class="variable language_">self</span>.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            c = <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.son[c] <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#目前没有这个</span></span><br><span class="line">                cur.son[c] = Node()</span><br><span class="line">            cur = cur.son[c] <span class="comment">#变成子节点，深度搜索</span></span><br><span class="line">        cur.end = <span class="literal">True</span> <span class="comment">#最后一个字符的end设置为true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur = <span class="variable language_">self</span>.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            c = <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.son[c] <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#有一个字符不一样就返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            cur = cur.son[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="keyword">if</span> cur.end <span class="keyword">else</span> <span class="number">1</span> <span class="comment">#如果是end，说明是search</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:<span class="comment">#每个字符都一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.find(word) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:<span class="comment">#包括search和开头两种情况，所以返回1/2都行，但不能返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.find(prefix) != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>

<h2 id="9：207-课程表-拓扑"><a href="#9：207-课程表-拓扑" class="headerlink" title="9：207. 课程表 拓扑"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">9：207. 课程表</a> 拓扑</h2><p>拓扑排序：给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。如果有有向无环图即可</p>
<ul>
<li><p>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canFinish</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)] <span class="comment">#记录每个课程的入度（即有多少先修课程）</span></span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)] <span class="comment">#邻接表，用于存储每个课程的后继课程</span></span><br><span class="line">        queue = collections.deque() <span class="comment">#先进先出 进行BFS 存储学了的课程方便遍历后继</span></span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:<span class="comment">#[0,1]0是1的后继，1是0的先修</span></span><br><span class="line">            indegrees[cur] += <span class="number">1</span></span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="comment">#把所有入度为0的课程加入队列，没有先修课程可以立即开始学习</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(indegrees)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: </span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="comment"># BFS TopSort. numCourses记录仍待学习的课程总数</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = queue.popleft()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjacency[pre]:<span class="comment">#pre的后继课程如果只有pre一个先修，就学了</span></span><br><span class="line">                indegrees[cur] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[cur]: </span><br><span class="line">                    queue.append(cur)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> numCourses</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10：206-反转链表"><a href="#10：206-反转链表" class="headerlink" title="10：206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">10：206. 反转链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h2 id="11：200-岛屿数量-dfs"><a href="#11：200-岛屿数量-dfs" class="headerlink" title="11：200. 岛屿数量 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">11：200. 岛屿数量 dfs</a></h2><p>一旦我们发现 (i,j) 是 1，就从 (i,j) 开始，DFS 这个岛。</p>
<p>每一步可以往左右上下四个方向走，也就是</p>
<p>(i,j−1),(i,j+1),(i−1,j),(i+1,j)<br>这四个格子。</p>
<p>每次到达一个新的格子，就插上旗子🚩，把 grid[i][j] 改成 2。</p>
<p>如果 (i,j) 出界，或者 (i,j) 是水，或者 (i,j) 已经插上了旗子🚩，就不再继续往下递归。</p>
<p>⚠注意：DFS 的过程中，最重要的是不能重复访问之前访问过的格子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:<span class="comment">#子函数可以访问外部函数的参数，外部函数调用也可以直接写</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> grid[i][j] != <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">#不在往下递归的条件</span></span><br><span class="line">            grid[i][j] = <span class="string">&#x27;2&#x27;</span><span class="comment">#插旗子</span></span><br><span class="line">            dfs(i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(i, j + <span class="number">1</span>)</span><br><span class="line">            dfs(i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(i + <span class="number">1</span>, j)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dfs(i, j)</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="12：198-打家劫舍-dp"><a href="#12：198-打家劫舍-dp" class="headerlink" title="12：198. 打家劫舍  dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">12：198. 打家劫舍</a>  dp</h2><p>1.子问题：从k个房子能偷到的最大金额</p>
<p>2.递推关系：<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329529.jpeg" alt="子问题的递推关系" style="zoom:33%;" /></p>
<p>3.计算顺序：k依赖K-1和k-2，所以从左到右算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="comment">#注意要设置n+1个数，这样i-2才不会越界，保证可以不选第一个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], nums[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<p>空间优化：其实只用两个值迭代，不需要一整个dp，就能推出最后的最大值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        pre, cur = <span class="number">0</span>, <span class="number">0</span> <span class="comment">#分别代表i-2和i-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            pre, cur = cur, <span class="built_in">max</span>(cur, i + pre)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h2 id="13：169-多数元素-投票"><a href="#13：169-多数元素-投票" class="headerlink" title="13：169. 多数元素  投票"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">13：169. 多数元素</a>  投票</h2><p>暴力：排序返回中间数字；哈希表统计</p>
<p>最佳方法：摩尔投票（就是抵消原则，一一配对，最后剩下来至少一个该元素）</p>
<ul>
<li>推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 &gt;0 。</li>
<li>推论二： 若数组的前 a 个数字的 票数和 &#x3D;0 ，则 数组剩余 (n−a) 个数字的 票数和一定仍 &gt;0 ，即后 (n−a) 个数字的 众数仍为 x 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        votes, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>: x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 验证 x 是否为众数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == x: count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; <span class="built_in">len</span>(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 当无众数时返回 0</span></span><br></pre></td></tr></table></figure>

<h2 id="14：238-除自身以外数组的乘积"><a href="#14：238-除自身以外数组的乘积" class="headerlink" title="14：238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">14：238. 除自身以外数组的乘积</a></h2><p>分别<strong>迭代计算</strong>上三角和下三角的乘积即可。前缀积和后缀积</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329526.png" alt="Picture1.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans, tmp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] * nums[i -<span class="number">1</span>] <span class="comment">#下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp *= nums[i + <span class="number">1</span>]</span><br><span class="line">            ans[i] *= tmp <span class="comment">#上三角</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="15：155-最小栈"><a href="#15：155-最小栈" class="headerlink" title="15：155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">15：155. 最小栈</a></h2><p>为什么不能用一个stack，因为min是O(n)，不是常数时间</p>
<p>用额外的空间辅助存最小值，用list的原因是最小值可能不止一个，可以保证数量的正确性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line">        <span class="variable language_">self</span>.min_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.min_stack <span class="keyword">or</span> val &lt;= <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>]: <span class="comment">#更新栈顶的最小值，重复值也重复入（保证pop的正确性，不然数量对不上）</span></span><br><span class="line">            <span class="variable language_">self</span>.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack.pop() == <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>]:<span class="comment">#这里stack是一定会pop的，如果和最小值相等把mini_stack也pop了</span></span><br><span class="line">            <span class="variable language_">self</span>.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>

<h2 id="16：152-乘积最大子数组"><a href="#16：152-乘积最大子数组" class="headerlink" title="16：152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">16：152. 乘积最大子数组</a></h2><p>要有连续的非空子数组</p>
<p>如果当前的数是正数，要与前面最大的乘积相乘；如果当前的数是负数，要与前面最小的乘积相乘。这样才有可能最大（这是最关键的思路，一般题只考虑最大值，但因为连续，这里要考虑最小值）</p>
<p>可以合并在一起写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f_max = [<span class="number">0</span>] * n</span><br><span class="line">        f_min = [<span class="number">0</span>] * n</span><br><span class="line">        f_max[<span class="number">0</span>] = f_min[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            x = nums[i]</span><br><span class="line">            f_max[i] = <span class="built_in">max</span>(f_max[i - <span class="number">1</span>] * x, f_min[i - <span class="number">1</span>] * x, x)</span><br><span class="line">            f_min[i] = <span class="built_in">min</span>(f_max[i - <span class="number">1</span>] * x, f_min[i - <span class="number">1</span>] * x, x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f_max)</span><br></pre></td></tr></table></figure>

<p>注意最后返回的是过程中的最大值</p>
<p>空间优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -inf  <span class="comment"># 注意答案可能是负数</span></span><br><span class="line">        f_max = f_min = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            f_max, f_min = <span class="built_in">max</span>(f_max * x, f_min * x, x), <span class="built_in">min</span>(f_max * x, f_min * x, x)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f_max)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="17：148-排序链表-难！"><a href="#17：148-排序链表-难！" class="headerlink" title="17：148. 排序链表 难！"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">17：148. 排序链表 </a>难！</h2><p>归并排序：</p>
<ul>
<li>分割：不断用快慢指针找到mid，然后mid.next&#x3D;None把链表切断<ul>
<li>终止条件非常重要！当head.next为空时说明只有一个节点，返回该节点即可</li>
</ul>
</li>
<li>合并：把两个有序链表合并，不断比较头节点即可，用dummy更简单</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        mid, slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">        left, right = <span class="variable language_">self</span>.sortList(head), <span class="variable language_">self</span>.sortList(mid)</span><br><span class="line">        res = ListNode(<span class="number">0</span>)<span class="comment">#dummy节点，不变用于返回</span></span><br><span class="line">        h = res <span class="comment">#存储合并后的链表</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                h.<span class="built_in">next</span> = left</span><br><span class="line">                left = left.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h.<span class="built_in">next</span> = right</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">            h = h.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            h.<span class="built_in">next</span> = left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            h.<span class="built_in">next</span> = right</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="18：146-LRU-缓存模板题"><a href="#18：146-LRU-缓存模板题" class="headerlink" title="18：146. LRU 缓存模板题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">18：146. LRU 缓存</a>模板题</h2><p>最近最久未使用的缓存会被移除</p>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p>看到题目要我们实现一个可以存储 key-value 形式数据的数据结构，并且可以记录最近访问的 key 值。首先想到的就是用字典来存储 key-value 结构，这样对于查找操作时间复杂度就是 O(1)。</p>
<p>但是因为字典本身是无序的，所以我们还需要一个类似于队列的结构来记录访问的先后顺序，这个队列需要支持如下几种操作：</p>
<ul>
<li><p>在末尾加入一项</p>
</li>
<li><p>去除最前端一项</p>
</li>
<li><p>将队列中某一项移到末尾</p>
</li>
</ul>
<p>链表末尾就是最新访问的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="literal">None</span>, value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.key = key</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line">        <span class="variable language_">self</span>.prev = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.capacity = capacity <span class="comment">#LRU的大小</span></span><br><span class="line">        <span class="variable language_">self</span>.hashmap = &#123;&#125; <span class="comment">#缓存，存储key和listnode节点！而不仅仅是value！</span></span><br><span class="line">        <span class="comment">#定义双向链表用于更新最新访问的key</span></span><br><span class="line">        <span class="variable language_">self</span>.head = ListNode()</span><br><span class="line">        <span class="variable language_">self</span>.tail = ListNode()</span><br><span class="line">        <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">        <span class="variable language_">self</span>.tail.prev = <span class="variable language_">self</span>.head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move_node_to_tail</span>(<span class="params">self, key</span>):</span><br><span class="line">            node = <span class="variable language_">self</span>.hashmap[key] <span class="comment">#先从现有链表中删除key指向的节点</span></span><br><span class="line">            node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line"></span><br><span class="line">            node.prev = <span class="variable language_">self</span>.tail.prev <span class="comment"># 之后将node插入到尾节点前</span></span><br><span class="line">            node.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:<span class="comment">#不在缓存中就返回-1</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.hashmap:</span><br><span class="line">            <span class="variable language_">self</span>.move_node_to_tail(key)<span class="comment"># 如果已经在链表中了久把它移到末尾（变成最新访问的）</span></span><br><span class="line">        res = <span class="variable language_">self</span>.hashmap.get(key, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> res == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res.value <span class="comment">#因为找到的是listnode，返回value</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.hashmap:</span><br><span class="line">            <span class="variable language_">self</span>.hashmap[key].value = value <span class="comment"># 更新值</span></span><br><span class="line">            <span class="variable language_">self</span>.move_node_to_tail(key)  <span class="comment"># 随后将该节点移到末尾</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#key不在里面，要逐出一个</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.hashmap) == <span class="variable language_">self</span>.capacity:</span><br><span class="line">                <span class="variable language_">self</span>.hashmap.pop(<span class="variable language_">self</span>.head.<span class="built_in">next</span>.key)</span><br><span class="line">                <span class="comment"># 去掉最久没有被访问过的节点，即头节点之后的节点</span></span><br><span class="line">                <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="variable language_">self</span>.head.<span class="built_in">next</span>.prev = <span class="variable language_">self</span>.head</span><br><span class="line">           </span><br><span class="line">            <span class="comment">#现在容量够了，作为最新访问的节点插到tail之前即可</span></span><br><span class="line">            new = ListNode(key, value)</span><br><span class="line">            <span class="variable language_">self</span>.hashmap[key] = new</span><br><span class="line">            new.prev = <span class="variable language_">self</span>.tail.prev</span><br><span class="line">            new.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev.<span class="built_in">next</span> = new</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev = new</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>

<h2 id="19：142-环形链表-II"><a href="#19：142-环形链表-II" class="headerlink" title="19：142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">19：142. 环形链表 II</a></h2><p>第一次相遇后，令fast重新指向头节点</p>
<p><em>f</em>&#x3D;2<em>nb</em>，<em>s</em>&#x3D;<em>nb</em>，n是环的周长（根据<em>f</em>&#x3D;2<em>s</em>和<em>f</em>&#x3D;<em>s</em>+<em>nb</em>求出）</p>
<p>此指针和 <code>slow</code> 一起向前走 <code>a</code> 步后，两者在入口节点重合。那么从哪里走到入口节点需要 <em>a</em> 步？答案是链表头节点<code>head</code>。这样可以求出a</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                ptr = head</span><br><span class="line">                <span class="keyword">while</span> head != slow:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    head = head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="20：141-环形链表-双指针"><a href="#20：141-环形链表-双指针" class="headerlink" title="20：141. 环形链表 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">20：141. 环形链表 双指针</a></h2><p>这题简单些，不必用求出环的入口，用快慢指针证明有环即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow = fast = head  <span class="comment"># 乌龟和兔子同时从起点出发</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span>  <span class="comment"># 乌龟走一步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 兔子走两步</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:  <span class="comment"># 兔子追上乌龟（套圈），说明有环 这里也可以写isSlow</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 访问到了链表末尾，无环</span></span><br></pre></td></tr></table></figure>

<h2 id="21：139-单词拆分-dp"><a href="#21：139-单词拆分-dp" class="headerlink" title="21：139. 单词拆分 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">21：139. 单词拆分 </a>dp</h2><p>动态规划（回溯暂时没看懂）</p>
<p>dp表示前i位是否可用wordDict表示，返回dp[-1]</p>
<p>trick是如果dp[i]为True，s[i:j]又在worddict中，则dp[j]为true。ij都需要枚举</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:       </span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        dp=[<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span>(dp[i] <span class="keyword">and</span> (s[i:j] <span class="keyword">in</span> wordDict)):</span><br><span class="line">                    dp[j]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="22：136-只出现一次的数字"><a href="#22：136-只出现一次的数字" class="headerlink" title="22：136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">22：136. 只出现一次的数字</a></h2><p>异或：n^n&#x3D;0, n^0&#x3D;n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ans ^= n</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="23：647-回文子串-dp"><a href="#23：647-回文子串-dp" class="headerlink" title="23：647. 回文子串 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">23：647. 回文子串</a> dp</h2><p>返回数目</p>
<p>用dp[i][j]表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。该定义j一定&gt;&#x3D;i，所以dp只填充右上部分</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li><p>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</p>
</li>
<li><p>情况二：下标i 与 j相差为1，例如aa，也是回文子串</p>
</li>
<li><p>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</p>
</li>
<li><p>根据递推关系的下标，需要从下到上，从左到右遍历</p>
</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329612.png" alt="image.png" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="literal">False</span>] * <span class="built_in">len</span>(s) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment">#注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt;= <span class="number">1</span>: <span class="comment">#情况一 和 情况二</span></span><br><span class="line">                        result += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]: <span class="comment">#情况三</span></span><br><span class="line">                        result += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>双指针法：一个元素可以作为中心点，两个元素也可以作为中心点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            res += <span class="variable language_">self</span>.extend(s, i, i, <span class="built_in">len</span>(s))</span><br><span class="line">            res += <span class="variable language_">self</span>.extend(s, i, i + <span class="number">1</span>, <span class="built_in">len</span>(s))<span class="comment">#这里最后会越界，但下面有边界校验了</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self, s, i, j, n</span>):<span class="comment">#ij是下标</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> s[i] == s[j]: <span class="comment">#先看作为中心的点相不相等</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="24：128-最长连续序列"><a href="#24：128-最长连续序列" class="headerlink" title="24：128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">24：128. 最长连续序列</a></h2><p>这里连续的意思是下一个数字要+1</p>
<p>O(n)所以不能排序</p>
<p>把nums放进集合（去除重复元素，因为重复元素不连续）</p>
<p>如果 x−1 在哈希集合中，则不以 x 为起点。为什么？因为以 x−1 为起点计算出的序列长度，一定比以 x 为起点计算出的序列长度要长！这样可以避免大量重复计算。比如 nums&#x3D;[3,2,4,5]，从 3 开始，我们可以找到 3,4,5 这个连续序列；而从 2 开始，我们可以找到 2,3,4,5 这个连续序列，一定比从 3 开始的序列更长。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        st = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> st:</span><br><span class="line">            <span class="keyword">if</span> x - <span class="number">1</span> <span class="keyword">in</span> st: <span class="comment">#这里剪枝了，注意不是while，只看前一个数</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            y = x + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> y <span class="keyword">in</span> st:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="comment">#退出循环时是没找到的值y+1，与x的距离就是序列 的长度</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, y - x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="25：124-二叉树中的最大路径和-dfs"><a href="#25：124-二叉树中的最大路径和-dfs" class="headerlink" title="25：124. 二叉树中的最大路径和 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">25：124. 二叉树中的最大路径和 </a>dfs</h2><p>各值和，不一定经过根节点</p>
<ul>
<li><p>链：从下面的某个节点（不一定是叶子）到当前节点的路径。把这条链的节点值之和，作为 dfs 的返回值。如果节点值之和是负数，则返回 0。</p>
</li>
<li><p>直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的某个节点（不一定是叶子）到 node 的链的节点值之和，去更新答案的最大值</p>
</li>
</ul>
<p>这里dfs算的是链！</p>
<p>注意一定要写nonlocal，如果只是读取外层变量，不用nonlocal，但这里要修改，加入nonlocal用于在嵌套函数中修改外层函数的变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -inf <span class="comment">#在这里定义了子函数也能访问到</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l_val = dfs(node.left)</span><br><span class="line">            r_val = dfs(node.right)</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = <span class="built_in">max</span>(l_val + r_val + node.val, ans)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(l_val, r_val) + node.val, <span class="number">0</span>) <span class="comment">#这里返回的是链，并不是一定要经过node两侧的直径</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="26：322-零钱兑换-dp"><a href="#26：322-零钱兑换-dp" class="headerlink" title="26：322. 零钱兑换 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">26：322. 零钱兑换 </a>dp</h2><p>背包问题</p>
<p>因为求最小值所以用inf初始化dp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] + [inf] * amount</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> coins:<span class="comment">#n是当前硬币的值</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n, amount + <span class="number">1</span>):<span class="comment">#这里的范围是重点，相当于选中硬币n了，金额不可能小于n</span></span><br><span class="line">                dp[c] = <span class="built_in">min</span>(dp[c], dp[c - n] + <span class="number">1</span>)</span><br><span class="line">        ans = dp[amount]</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="27：494-目标和-dfs背包"><a href="#27：494-目标和-dfs背包" class="headerlink" title="27：494. 目标和 dfs背包"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">27：494. 目标和</a> dfs背包</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329657.png" alt="image-20250401200536138"></p>
<p>当s-|target|是奇数时直接返回0即可</p>
<p>dfs(i, c)表示用i个数字凑出背包容量的方案数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">sum</span>(nums) - <span class="built_in">abs</span>(target)</span><br><span class="line">        <span class="keyword">if</span> s &lt; <span class="number">0</span> <span class="keyword">or</span> s % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = s // <span class="number">2</span>  <span class="comment"># 背包容量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache  </span><span class="comment"># 缓存装饰器，避免重复计算</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 如果已经遍历完所有数字（i &lt; 0），检查是否恰好凑出 c</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> c &lt; nums[i]: <span class="comment">#选不了c</span></span><br><span class="line">                <span class="keyword">return</span> dfs(i - <span class="number">1</span>, c)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># - 不选：直接递归到 i-1，容量 c 不变</span></span><br><span class="line">            <span class="comment"># - 选：递归到 i-1，容量 c 减少 nums[i]</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i - <span class="number">1</span>, c) + dfs(i - <span class="number">1</span>, c - nums[i])</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="built_in">len</span>(nums) - <span class="number">1</span>, m)</span><br></pre></td></tr></table></figure>

<h2 id="28：461-汉明距离"><a href="#28：461-汉明距离" class="headerlink" title="28：461. 汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hamming-distance/">28：461. 汉明距离</a></h2><p>异或剩下不为1的数字就对应二进制位不同的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (x ^ y).bit_count()</span><br><span class="line">    <span class="comment">#或者写return bin(x ^ y).count(&#x27;1&#x27;) bin把整数转为二进制</span></span><br></pre></td></tr></table></figure>

<h2 id="29：448-找到所有数组中消失的数字"><a href="#29：448-找到所有数组中消失的数字" class="headerlink" title="29：448. 找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">29：448. 找到所有数组中消失的数字</a></h2><p>列表查询的时间为on，集合只用o1，因为list是连续内存存储，set是哈希表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums = <span class="built_in">set</span>(nums)<span class="comment">#注意不加这句会超时，加了就保证数量小于N了</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="30：438-找到字符串中所有字母异位词-双指针"><a href="#30：438-找到字符串中所有字母异位词-双指针" class="headerlink" title="30：438. 找到字符串中所有字母异位词 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">30：438. 找到字符串中所有字母异位词</a> 双指针</h2><p>异位词：字母相同顺序不同</p>
<p>暴力法：以右侧下标做对比可以保证左侧数据早已加入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        cnt_p = Counter(p)  <span class="comment"># 统计 p 的每种字母的出现次数</span></span><br><span class="line">        cnt_s = Counter()  <span class="comment"># 统计 s 的长为 len(p) 的子串 s&#x27; 的每种字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            cnt_s[c] += <span class="number">1</span>  <span class="comment"># 右端点字母进入窗口</span></span><br><span class="line">            left = right - <span class="built_in">len</span>(p) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="number">0</span>:  <span class="comment"># 窗口长度不足 len(p)</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> cnt_s == cnt_p:  <span class="comment"># s&#x27; 和 p 的每种字母的出现次数都相同</span></span><br><span class="line">                ans.append(left)  <span class="comment"># s&#x27; 左端点下标加入答案</span></span><br><span class="line">            cnt_s[s[left]] -= <span class="number">1</span>  <span class="comment"># 左端点字母离开窗口</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>下面的方法是通过比较右侧值保证[left,right]内有cnt的内容</p>
<p> 1.维护一个有条件的滑动窗口； 2.右端点右移，导致窗口扩大，是不满足条件的罪魁祸首； 3.左端点右移目的是为了缩小窗口，重新满足条件</p>
<p>如果出现一个非p的字符，cnt[c]就为-1，left会移到right+1的位置，right下一个循环也是right+1。只有字符和次数都和p正好相同，left才不会移动，right进行右移扩大范围到长度为p</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        cnt = Counter(p)  <span class="comment"># 统计 p 的每种字母的出现次数</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            cnt[c] -= <span class="number">1</span>  <span class="comment"># 右端点字母进入窗口</span></span><br><span class="line">            <span class="keyword">while</span> cnt[c] &lt; <span class="number">0</span>:  <span class="comment"># 字母 c 太多了</span></span><br><span class="line">                cnt[s[left]] += <span class="number">1</span>  <span class="comment"># 左端点字母离开窗口</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> == <span class="built_in">len</span>(p):  <span class="comment"># s&#x27; 和 p 的每种字母的出现次数都相同</span></span><br><span class="line">                ans.append(left)  <span class="comment"># s&#x27; 左端点下标加入答案</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="31：437-路径总和-III-dfs"><a href="#31：437-路径总和-III-dfs" class="headerlink" title="31：437. 路径总和 III dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">31：437. 路径总和 III</a> dfs</h2><p>路径必须从父节点到子节点</p>
<p>前缀和+回溯&#x2F;DFS</p>
<p>dfs(node, presum)以node为最后节点的，节点和等于目标和的路径数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], presum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span>          <span class="comment"># 空节点，满足条件路径数为0</span></span><br><span class="line">            presum += node.val             <span class="comment"># 更新节点和</span></span><br><span class="line">            </span><br><span class="line">            path_cnt = presum_counts.get(presum - targetSum, <span class="number">0</span>)             <span class="comment"># 从哈希表中获取能和presum配对的前缀和个数</span></span><br><span class="line">            presum_counts[presum] = presum_counts.get(presum, <span class="number">0</span>) + <span class="number">1</span>        <span class="comment"># 将当前前缀和加入哈希表</span></span><br><span class="line">            path_cnt += dfs(node.left, presum) + dfs(node.right, presum)    <span class="comment"># 递归处理左右子树</span></span><br><span class="line">            presum_counts[presum] -= <span class="number">1</span>                                      <span class="comment"># 选择这个节点组成target的情况已经遍历完了，回溯方便下一个节点选择</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> path_cnt                                                 <span class="comment"># 返回总路径数</span></span><br><span class="line"></span><br><span class="line">        presum_counts = &#123;<span class="number">0</span> : <span class="number">1</span>&#125; <span class="comment"># 记录当前路径上出现的前缀和以及数量, 有一个默认的前缀和0</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)     <span class="comment"># 从根节点开始搜索</span></span><br></pre></td></tr></table></figure>

<h2 id="32：416-分割等和子集-dp"><a href="#32：416-分割等和子集-dp" class="headerlink" title="32：416. 分割等和子集 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">32：416. 分割等和子集</a> dp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#dp[i][j]选择前i个数组成j的方案数，dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]</span></span><br><span class="line">        s = <span class="built_in">sum</span>(nums) </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> s % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = s // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (num + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="comment">#一般把0空出来比较好，避免下标越界问题</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> dp[n][num] == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="33：406-根据身高重建队列-sort"><a href="#33：406-根据身高重建队列-sort" class="headerlink" title="33：406. 根据身高重建队列 sort"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">33：406. 根据身高重建队列</a> sort</h2><p><code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>要把乱序的数组排列成实际身高的队形</p>
<p><strong>一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</strong></p>
<p>这里首先按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。保证身高高的在前面，以及同样身高的排在前面的在前面（因为&gt;&#x3D;的人少），这样也保证在插队时不会有数量错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))<span class="comment">#key可以指定字符串排序的方式</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= p[<span class="number">1</span>]:<span class="comment">#在最后加入，前面的人的个数是符合记录的</span></span><br><span class="line">                res.append(p)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(res) &gt; p[<span class="number">1</span>]:</span><br><span class="line">                res.insert(p[<span class="number">1</span>], p) <span class="comment">#插队，在p[1]的位置插入p</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="34：399-除法求值-dfs"><a href="#34：399-除法求值-dfs" class="headerlink" title="34：399. 除法求值 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/">34：399. 除法求值 dfs</a></h2><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>
<p>建立过渡变量，用图的形式构造双向边（dict:{}），值作为权重</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcEquation</span>(<span class="params">self, equations: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], values: <span class="type">List</span>[<span class="built_in">float</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]: </span><br><span class="line">        <span class="comment"># 构造图，equations的第一项除以第二项等于value里的对应值，第二项除以第一项等于其倒数（构造双向边）</span></span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (x, y), v <span class="keyword">in</span> <span class="built_in">zip</span>(equations, values):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> graph:</span><br><span class="line">                graph[x][y] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[x] = &#123;y: v&#125;</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> graph:</span><br><span class="line">                graph[y][x] = <span class="number">1</span>/v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[y] = &#123;x: <span class="number">1</span>/v&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs找寻从s到t的路径并返回结果叠乘后的边权重即结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, t</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t == s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[s].keys():</span><br><span class="line">                <span class="keyword">if</span> node == t:<span class="comment">#直接连接</span></span><br><span class="line">                    <span class="keyword">return</span> graph[s][node]</span><br><span class="line">                <span class="keyword">elif</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(node)  <span class="comment"># 添加到已访问避免重复遍历</span></span><br><span class="line">                    v = dfs(node, t)</span><br><span class="line">                    <span class="keyword">if</span> v != -<span class="number">1</span>:<span class="comment">#说明走通了，该场景并没有多路</span></span><br><span class="line">                        <span class="keyword">return</span> graph[s][node]*v</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逐个计算query的值</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> qs, qt <span class="keyword">in</span> queries:</span><br><span class="line">            visited = <span class="built_in">set</span>()<span class="comment">#记录遍历过的节点</span></span><br><span class="line">            res.append(dfs(qs, qt))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="35：394-字符串解码-stack"><a href="#35：394-字符串解码-stack" class="headerlink" title="35：394. 字符串解码 stack"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">35：394. 字符串解码</a> stack</h2><p>难点在于嵌套括号，以及数字可能也是多位数，用栈！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack, res, multi = [], <span class="string">&quot;&quot;</span>, <span class="number">0</span> <span class="comment">#stack存</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append([multi, res])<span class="comment">#存的是数字之前的字符串，不会变</span></span><br><span class="line">                res, multi = <span class="string">&quot;&quot;</span>, <span class="number">0</span> <span class="comment">#res开始存需要重复的字符串，同时可能继续遇到multi</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                cur_multi, last_res = stack.pop()</span><br><span class="line">                res = last_res + cur_multi * res</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:<span class="comment">#数字不一定是个位数，所以*10</span></span><br><span class="line">                multi = multi * <span class="number">10</span> + <span class="built_in">int</span>(c)            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="36：347-前-K-个高频元素-heap"><a href="#36：347-前-K-个高频元素-heap" class="headerlink" title="36：347. 前 K 个高频元素 heap"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">36：347. 前 K 个高频元素</a> heap</h2><p>先获得频率，再创建小顶堆。如果比k个数的最小值大，就更换数据</p>
<p>heapq会自动把最小的frequency放在开头，因为封装了最小堆，从小到大排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        map_ = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            map_[num] = map_.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heap = []  <span class="comment">#从小到大排前k高的元素，是模块提供的小顶堆（大顶堆用负数模拟）</span></span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> map_.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k:</span><br><span class="line">                heapq.heappush(heap, (freq, num))</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#比较当前值和堆顶的频率最小值哪个大</span></span><br><span class="line">                <span class="keyword">if</span> freq &gt; heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappushpop(heap, (freq, num))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            res.append(heapq.heappop(heap)[<span class="number">1</span>])<span class="comment">#注意加入的是值不是频率</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="37：338-比特位计数-dp"><a href="#37：338-比特位计数-dp" class="headerlink" title="37：338. 比特位计数 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/">37：338. 比特位计数</a> dp</h2><p>内置函数就是bin和count(‘1’)</p>
<p>动态规划：某个偶数肯定能由前面的某个数左移一位得到，如十进制6对应的二进制为110，由十进制3对应二进制11左移一位得到。<br>某个奇数肯定能由前面的某个数左移一位并加上1得到，如十进制7对应的二进制为111，是由十进制3对应二进制11左移一位为110并加一得到。利用位运算的性质</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dp=[<span class="number">0</span>]*(num+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            dp[i*<span class="number">2</span>]=dp[i]</span><br><span class="line">            <span class="keyword">if</span> i*<span class="number">2</span>+<span class="number">1</span>&lt;=num:</span><br><span class="line">                dp[i*<span class="number">2</span>+<span class="number">1</span>]=dp[i]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>

<h2 id="38：337-打家劫舍-III-dp-dfs"><a href="#38：337-打家劫舍-III-dp-dfs" class="headerlink" title="38：337. 打家劫舍 III dp+dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">38：337. 打家劫舍 III</a> dp+dfs</h2><p>对于选择了根,那么我们就不能选它的儿子了<br>如果没有选根，我们就可以任意选了(即选最大的那一个)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]   <span class="comment">#列表[0]代表当前节点不偷带来的钱，列表[1]代表当前节点偷带来的钱</span></span><br><span class="line">        l=<span class="variable language_">self</span>.dp(root.left)   <span class="comment">#root的左节点[不偷][偷]带来的钱</span></span><br><span class="line">        r=<span class="variable language_">self</span>.dp(root.right)   <span class="comment">#root的右节点[不偷][偷]带来的钱</span></span><br><span class="line">        <span class="comment">#root节点不偷，则可以偷左右儿子节点，但不是一定要偷。取左儿子偷或不偷的最大值和右儿子偷或不偷的最大值；</span></span><br><span class="line">        <span class="comment">#root节点偷，则root节点值+左儿子不偷+右儿子不偷。</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(l)+<span class="built_in">max</span>(r), root.val+l[<span class="number">0</span>]+r[<span class="number">0</span>]]  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.dp(root))  <span class="comment">#取root节点偷或不偷的最大值</span></span><br></pre></td></tr></table></figure>

<h2 id="39：121-买卖股票的最佳时机-trick"><a href="#39：121-买卖股票的最佳时机-trick" class="headerlink" title="39：121. 买卖股票的最佳时机 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">39：121. 买卖股票的最佳时机</a> trick</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span> <span class="comment">#存最大利润</span></span><br><span class="line">        minPrice = prices[<span class="number">0</span>]<span class="comment">#需要知道第i天之前，股票价格的最小值，作为买入价格</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - minPrice)</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, p)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="40：312-戳气球"><a href="#40：312-戳气球" class="headerlink" title="40：312. 戳气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/burst-balloons/">40：312. 戳气球</a></h2><p><em>f</em>[<em>i</em>][<em>j</em>] 表示戳破区间 (<em>i</em>,<em>j</em>) 内的所有气球能得到的最多硬币数，开区间</p>
<p>如果k是最后一个戳破的气球，那得到的硬币数量是确定的</p>
<p>f[<em>i</em>][<em>j</em>]&#x3D;max(f[i][j],f[i][k]+f[k][j]+arr[i]×arr[k]×arr[j]) k∈(i,j) 引入k，非常巧妙</p>
<p>确定ij的遍历顺序：f[i][j]依赖于f[k][j],k&gt;i，所以i要从大到小；f[i][k]&lt;f[i][j]，j要从从小到大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxCoins</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        arr = [<span class="number">1</span>] + nums + [<span class="number">1</span>] <span class="comment">#方便处理边界情况</span></span><br><span class="line">        f = [[<span class="number">0</span>] * (n + <span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment">#i要倒序</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">2</span>, n + <span class="number">2</span>):<span class="comment">#因为要有k的位置，所以j至少是i+2</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, j): <span class="comment">#i&lt;k&lt;j</span></span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][k] + f[k][j] + arr[i] * arr[k] * arr[j])</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][-<span class="number">1</span>] <span class="comment">#答案是f[0][n+1]</span></span><br></pre></td></tr></table></figure>

<h2 id="41：309-买卖股票的最佳时机含冷冻期-dp"><a href="#41：309-买卖股票的最佳时机含冷冻期-dp" class="headerlink" title="41：309. 买卖股票的最佳时机含冷冻期 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">41：309. 买卖股票的最佳时机含冷冻期</a> dp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp0 = <span class="number">0</span> <span class="comment"># 手里没股票，没有处于冷冻期</span></span><br><span class="line">        dp1 = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>) <span class="comment"># 手里没股票，并且处于冷冻期</span></span><br><span class="line">        dp2 = - prices[<span class="number">0</span>] <span class="comment"># 手里有股票</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            new_dp0 = <span class="built_in">max</span>(dp0, dp1)<span class="comment">#可能解冻了</span></span><br><span class="line">            new_dp1 = dp2 + prices[i] <span class="comment">#必然是昨天卖出了</span></span><br><span class="line">            new_dp2 = <span class="built_in">max</span>(dp2, dp0 - prices[i])<span class="comment">#可能0状态买入了</span></span><br><span class="line">            dp0, dp1, dp2 = new_dp0, new_dp1, new_dp2</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp0, dp1)<span class="comment">#一定是手里没有股票赚的钱最多，因此最后返回dp0和dp1的最大值</span></span><br></pre></td></tr></table></figure>

<h2 id="42：301-删除无效的括号-DFS"><a href="#42：301-删除无效的括号-DFS" class="headerlink" title="42：301. 删除无效的括号 DFS"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-invalid-parentheses/">42：301. 删除无效的括号 </a>DFS</h2><p>为什么判断cr&gt;cl？如果右比左多，无论后面怎么添加字符，都无法形成有效的括号组合（因为 <code>&#39;)&#39;</code> 必须在 <code>&#39;(&#39;</code> 之后出现）。</p>
<p>但是在遍历过程中，<code>&#39;(&#39;</code> 可以暂时多于 <code>&#39;)&#39;</code>（例如 <code>&quot;(()&quot;</code> 是部分有效的，后面可能补上 <code>&#39;)&#39;</code>）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeInvalidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        l = r = <span class="number">0</span> <span class="comment">#l是多余的左括号，r是多余的右括号</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> l:</span><br><span class="line">                    l -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache </span><span class="comment">#idx是当前处理的字符索引，cl/cr是当前路径中的()</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">idx, cl, cr, dl, dr, path</span>):<span class="comment">#dl/dr：剩余需要删除的()</span></span><br><span class="line">            <span class="keyword">if</span> idx == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dl <span class="keyword">and</span> <span class="keyword">not</span> dr:</span><br><span class="line">                    ans.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> cr &gt; cl <span class="keyword">or</span> dl &lt; <span class="number">0</span> <span class="keyword">or</span> dr &lt; <span class="number">0</span>:<span class="comment">#删多了</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            c = s[idx]<span class="comment">#当前处理的字符</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:<span class="comment">#可以选择删除它或保留它</span></span><br><span class="line">                dfs(idx+<span class="number">1</span>,cl,cr,dl-<span class="number">1</span>,dr, path)<span class="comment">#删除</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:<span class="comment">#可以选择删除它或保留它</span></span><br><span class="line">                dfs(idx+<span class="number">1</span>,cl,cr,dl,dr-<span class="number">1</span>, path)<span class="comment">#删除</span></span><br><span class="line">            dfs(idx+<span class="number">1</span>,cl+(c==<span class="string">&#x27;(&#x27;</span>),cr+(c==<span class="string">&#x27;)&#x27;</span>),dl,dr, path+c)<span class="comment">#保留</span></span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, l, r, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>为什么可以保证删除最小数量的无效括号？由于 <code>dl</code> 和 <code>dr</code> 的限制，DFS 只会探索<strong>恰好删除 <code>l</code> 个 <code>&#39;(&#39;</code> 和 <code>r</code> 个 <code>&#39;)&#39;</code></strong> 的路径。如果有更少的删除的话，最终字符串一定有多余的括号。其实我们是通过合法字符串的规则进行了约束。</p>
<h2 id="43：300-最长递增子序列-dp"><a href="#43：300-最长递增子序列-dp" class="headerlink" title="43：300. 最长递增子序列 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">43：300. 最长递增子序列</a> dp</h2><p>dp表示以 <em>nums</em>[<em>i</em>] 结尾的最长子序列长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)<span class="comment">#注意返回的是数组的最大值，并不是要以最后一个字符结尾</span></span><br></pre></td></tr></table></figure>

<h2 id="44：297-二叉树的序列化与反序列化"><a href="#44：297-二叉树的序列化与反序列化" class="headerlink" title="44：297. 二叉树的序列化与反序列化"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">44：297. 二叉树的序列化与反序列化</a></h2><p>将转换后的数据存储在一个文件或者内存中</p>
<ul>
<li><strong>序列化</strong>：将二叉树转换为一个字符串（或比特位序列），以便可以存储在文件中或通过网络传输。</li>
<li><strong>反序列化</strong>：将序列化后的字符串重新构造成原始的二叉树。</li>
</ul>
<p>用层序遍历的话还是挺直观的 空也没有引发复杂的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span></span><br><span class="line">        queue = deque([root]) <span class="comment">#用层序遍历</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">&quot;null&quot;</span>) <span class="comment">#如果为空也会输出</span></span><br><span class="line">        <span class="keyword">while</span> res <span class="keyword">and</span> res[-<span class="number">1</span>] == <span class="string">&quot;null&quot;</span>: <span class="comment">#但是最后的空要被删除</span></span><br><span class="line">            res.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="string">&quot;,&quot;</span>.join(res) + <span class="string">&quot;]&quot;</span> <span class="comment">#要返回字符串，所以不能直接返回res</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;[]&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        values = data[<span class="number">1</span>:-<span class="number">1</span>].split(<span class="string">&quot;,&quot;</span>)<span class="comment">#把字符串变成list</span></span><br><span class="line">        root = TreeNode(<span class="built_in">int</span>(values[<span class="number">0</span>]))<span class="comment">#第一个数是根节点</span></span><br><span class="line">        queue = deque([root])<span class="comment">#这里的queue存的是树节点</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(values):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(values) <span class="keyword">and</span> values[i] != <span class="string">&quot;null&quot;</span>:<span class="comment">#左节点 如果非空可以添加（空的不添加自动为空）</span></span><br><span class="line">                node.left = TreeNode(<span class="built_in">int</span>(values[i]))</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(values) <span class="keyword">and</span> values[i] != <span class="string">&quot;null&quot;</span>:</span><br><span class="line">                node.right = TreeNode(<span class="built_in">int</span>(values[i]))</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="45：87-寻找重复数-二分"><a href="#45：87-寻找重复数-二分" class="headerlink" title="45：87. 寻找重复数 二分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">45：87. 寻找重复数 </a>二分</h2><p>已知数字都在[1, n]范围内，有n+1个整数，根据抽屉原理至少存在一个重复的整数</p>
<p>用二分法（知道最大最小界），数在范围里的数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_val = <span class="number">1</span> <span class="comment"># 所查找数字范围的最小值</span></span><br><span class="line">        max_val = <span class="built_in">len</span>(nums) <span class="comment"># 所查找数字范围的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> min_val &lt; max_val:</span><br><span class="line">            mid = (min_val + max_val) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 计数</span></span><br><span class="line">            cnt = <span class="built_in">sum</span>(min_val &lt;= num &lt;= mid <span class="keyword">for</span> num <span class="keyword">in</span> nums)<span class="comment">#数在这个区间里的数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cnt &gt; mid - min_val + <span class="number">1</span>: <span class="comment"># 个数超出范围长度，即存在重复数</span></span><br><span class="line">                max_val = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                min_val = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_val</span><br></pre></td></tr></table></figure>

<h2 id="46：283-移动零-双指针"><a href="#46：283-移动零-双指针" class="headerlink" title="46：283. 移动零 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">46：283. 移动零</a> 双指针</h2><p>因为要保持原数组非零元素的顺序，用双指针</p>
<p>将 <em>l</em> 移动到自身右侧第一个元素为 0 的位置，将 <em>r</em> 移动到 <em>l</em> 右侧第一个元素非 0 的位置，然后交换元素</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329699.png" alt="283_3.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> r == l <span class="keyword">or</span> nums[r] == <span class="number">0</span>: <span class="comment"># 优先检测 r，确保 r 在 l 右侧， 让 r 指向非0</span></span><br><span class="line">                r += <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">elif</span> nums[l] != <span class="number">0</span>: <span class="comment">#让l指向0</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[l] = nums[r]<span class="comment">#把0赋值为非0</span></span><br><span class="line">                nums[r] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="47：279-完全平方数-dp"><a href="#47：279-完全平方数-dp" class="headerlink" title="47：279. 完全平方数 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">47：279. 完全平方数 </a>dp</h2><p>完全平方数满足n^2，用最少的完全平方数使和为n，也是DP</p>
<p>DFS都可以1：1翻译成递推，往往再进行空间优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">10000</span></span><br><span class="line">f = [<span class="number">0</span>] + [inf] * N</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, isqrt(N) + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i * i, N + <span class="number">1</span>):</span><br><span class="line">        f[j] = <span class="built_in">min</span>(f[j], f[j - i * i] + <span class="number">1</span>)  <span class="comment"># 不选 vs 选</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>

<p>为什么f写在类的外面而不是函数内就不会超时：作为全局变量不用重复计算</p>
<p>在程序启动时，<code>f</code> 数组被计算一次（时间复杂度 <code>O(N√N)</code>），之后所有测试用例的 <code>numSquares(n)</code> 查询都是 <code>O(1)</code>。</p>
<h2 id="48：253-会议室II-堆"><a href="#48：253-会议室II-堆" class="headerlink" title="48：253.会议室II 堆"></a>48：253.会议室II 堆</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329810.jpeg" alt="img">时间间隔问题，按照会议的开始时间进行排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minMeetingRooms</span>(<span class="params">intervals</span>):</span><br><span class="line">    <span class="comment"># 如果会议安排列表为空，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化一个空的最小堆</span></span><br><span class="line">    free_rooms = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先根据会议的开始时间对会议进行排序</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将第一个会议的结束时间加入到最小堆中</span></span><br><span class="line">    <span class="comment"># 这表示目前我们有一个会议室被占用，直到这个时间点</span></span><br><span class="line">    heapq.heappush(free_rooms, intervals[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从第二个会议开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果当前会议的开始时间大于等于最小堆中的最早结束时间</span></span><br><span class="line">        <span class="comment"># 说明这个会议室可以被重复使用</span></span><br><span class="line">        <span class="comment"># 因此我们可以移除堆顶元素（最早结束的会议室）</span></span><br><span class="line">        <span class="keyword">if</span> i[<span class="number">0</span>] &gt;= free_rooms[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(free_rooms)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将当前会议的结束时间加入最小堆</span></span><br><span class="line">        <span class="comment"># 表示新增一个会议室，或是延续使用原会议室</span></span><br><span class="line">        heapq.heappush(free_rooms, i[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 堆中元素的数量，就是我们需要的会议室数量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(free_rooms)</span><br></pre></td></tr></table></figure>

<h2 id="49：240-搜索二维矩阵-II-trick"><a href="#49：240-搜索二维矩阵-II-trick" class="headerlink" title="49：240. 搜索二维矩阵 II trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">49：240. 搜索二维矩阵 II</a> trick</h2><p>类似二叉搜索树，3&#x2F;7这种左下角、右上角元素称为标志数flag，每次比较可以消除一行或一列</p>
<ul>
<li>若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。</li>
<li>若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329889.png" alt="Picture1.png" style="zoom:33%;" />

<p>我们从左下角开始找：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        i, j = <span class="built_in">len</span>(matrix) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &gt; target: </span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="50：239-滑动窗口最大值"><a href="#50：239-滑动窗口最大值" class="headerlink" title="50：239. 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">50：239. 滑动窗口最大值</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = deque()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 移除不在窗口内的队首元素 保证q中的每个下标都没有超越窗口的左边界</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt; i - k + <span class="number">1</span>:</span><br><span class="line">                q.popleft()</span><br><span class="line">            <span class="comment"># 维护队列递减性质 如果当前元素大于队尾元素 则队尾元素出队 有可能把队列全清空</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)<span class="comment">#我不懂为啥当前的数字非得存进去，只和队尾比较一次不好吗（仔细想和维护top1/2的复杂性是一样的，这样写单调性更简单灵活，不是说非要有2个数）</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:<span class="comment">#其实除了最开始窗口小于k，后面每次都会有一个最大值</span></span><br><span class="line">                result.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>



<h2 id="51：22-括号生成-回溯"><a href="#51：22-括号生成-回溯" class="headerlink" title="51：22. 括号生成 回溯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">51：22. 括号生成</a> 回溯</h2><p>n为生成括号的对数</p>
<p>先左括号+让右小于左是为了保证括号组合有效</p>
<p>回溯模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足终止条件:</span><br><span class="line">        结果.append(路径.copy())  # 注意深拷贝</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        if 剪枝条件:  # 可选，提前跳过无效选择</span><br><span class="line">            continue</span><br><span class="line">        </span><br><span class="line">        做选择  # 将当前选择加入路径</span><br><span class="line">        backtrack(路径, 新选择列表)  # 递归</span><br><span class="line">        撤销选择  # 从路径中移除当前选择</span><br></pre></td></tr></table></figure>

<p>本题注意不等式的细节</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">S, left, right</span>):<span class="comment">#left,right指已使用的括号数量</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(S) == <span class="number">2</span> * n:<span class="comment">#总数量达到要求</span></span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(S))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:<span class="comment">#left表示左括号的数量</span></span><br><span class="line">                S.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                backtrack(S, left+<span class="number">1</span>, right)</span><br><span class="line">                S.pop()</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:<span class="comment">#保证括号有效</span></span><br><span class="line">                S.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                backtrack(S, left, right+<span class="number">1</span>)</span><br><span class="line">                S.pop()</span><br><span class="line"></span><br><span class="line">        backtrack([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="52：49-字母异位词分组dict"><a href="#52：49-字母异位词分组dict" class="headerlink" title="52：49. 字母异位词分组dict"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">52：49. 字母异位词分组</a>dict</h2><p>把输入数组中的字母异位词组合到一起</p>
<p>把字符串排序后字母异位词应该一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        d = defaultdict(<span class="built_in">list</span>) <span class="comment">#当访问不存在的key时，会创建空list作为该key的value。适用于分组</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))].append(s)  <span class="comment"># sorted(s) 相同的字符串分到同一组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(d.values())</span><br></pre></td></tr></table></figure>

<h2 id="53：48-旋转图像-trick"><a href="#53：48-旋转图像-trick" class="headerlink" title="53：48. 旋转图像 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">53：48. 旋转图像</a> trick</h2><p>原地旋转二维矩阵，不采用额外的空间</p>
<p>如果用拷贝，记得用深拷贝！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 深拷贝 matrix -&gt; tmp，若是普通赋值，matrix变化了tmp也会变</span></span><br><span class="line">        tmp = copy.deepcopy(matrix)</span><br><span class="line">        <span class="comment"># 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp[i][j]</span><br></pre></td></tr></table></figure>

<p>原地修改时只用看左上角1&#x2F;4的部分，就可以实现全局修改</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504052329910.png" alt="image-20250402121910315"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">                tmp = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i]</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j]</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i]</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp</span><br></pre></td></tr></table></figure>

<h2 id="54：46-全排列dfs"><a href="#54：46-全排列dfs" class="headerlink" title="54：46. 全排列dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">54：46. 全排列</a>dfs</h2><p>回溯算法：</p>
<p>终止条件：长度为len-1</p>
<p>递推参数：当前固定位x</p>
<p>递推工作：固定nums[i]作为当前位元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x == <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="built_in">list</span>(nums))   <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x, <span class="built_in">len</span>(nums)):</span><br><span class="line">                nums[i], nums[x] = nums[x], nums[i]  <span class="comment"># 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>)                           <span class="comment"># 开启固定第 x + 1 位元素</span></span><br><span class="line">                nums[i], nums[x] = nums[x], nums[i]  <span class="comment"># 恢复交换</span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="55：42-接雨水-trick"><a href="#55：42-接雨水-trick" class="headerlink" title="55：42. 接雨水 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">55：42. 接雨水 </a>trick</h2><p>res[i] &#x3D; min(l_max[i], r_max[i]) - height[i]：min是木桶效应，决定当前柱子i能承载的最高水位；减去height是因为柱子本身会占据一定高度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        l_max = [<span class="number">0</span>] * n</span><br><span class="line">        r_max = [<span class="number">0</span>] * n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算 l_max</span></span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            l_max[i] = <span class="built_in">max</span>(l_max[i-<span class="number">1</span>], height[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算 r_max</span></span><br><span class="line">        r_max[-<span class="number">1</span>] = height[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            r_max[i] = <span class="built_in">max</span>(r_max[i+<span class="number">1</span>], height[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算总雨水量</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res += <span class="built_in">min</span>(l_max[i], r_max[i]) - height[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="56：39-组合总和-回溯"><a href="#56：39-组合总和-回溯" class="headerlink" title="56：39. 组合总和 回溯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">56：39. 组合总和</a> 回溯</h2><p>dfs(i, left) i是当前选择的下标，left是剩余的数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, left: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 找到一个合法组合</span></span><br><span class="line">                ans.append(path.copy())<span class="comment">#必须写copy，不然ans所有组合都指向同一个path，这个path最终会被清空为[]</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(candidates) <span class="keyword">or</span> left &lt; candidates[i]:<span class="comment">#剪枝：下标不越界+left不能太小</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 不选candidates[i]</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 选candidates[i]</span></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            dfs(i, left - candidates[i])</span><br><span class="line">            path.pop()  <span class="comment"># 恢复现场</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="57：543-二叉树的直径-dfs"><a href="#57：543-二叉树的直径-dfs" class="headerlink" title="57：543. 二叉树的直径 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">57：543. 二叉树的直径</a> dfs</h2><p>求左右子树深度值的最大值</p>
<p>注意返回的是子树的链长</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            l_len = dfs(node.left) + <span class="number">1</span>  <span class="comment"># 左子树最大链长+1</span></span><br><span class="line">            r_len = dfs(node.right) + <span class="number">1</span>  <span class="comment"># 右子树最大链长+1</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans <span class="comment">#让外层函数的变量可以修改</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, l_len + r_len)  <span class="comment"># 两条链拼成路径</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l_len, r_len)  <span class="comment"># 当前子树最大链长</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="58：34-在排序数组中查找元素的第一个和最后一个位置-二分"><a href="#58：34-在排序数组中查找元素的第一个和最后一个位置-二分" class="headerlink" title="58：34. 在排序数组中查找元素的第一个和最后一个位置 二分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">58：34. 在排序数组中查找元素的第一个和最后一个位置 </a>二分</h2><p>递增的数组</p>
<p>开始位置和结束位置</p>
<p>闭区间的二分写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:   </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  </span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:<span class="comment">#这里等于也不能直接return，因为要找最左的target</span></span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 范围缩小到 [left, mid-1]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 范围缩小到 [mid+1, right]</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = <span class="variable language_">self</span>.lower_bound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]  <span class="comment"># nums 中没有 target</span></span><br><span class="line">        <span class="comment"># 如果 start 存在，那么 end 必定存在</span></span><br><span class="line">        end = <span class="variable language_">self</span>.lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span> <span class="comment">#非常巧妙，因为是递增数列</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>

<h2 id="59：33-搜索旋转排序数组-二分"><a href="#59：33-搜索旋转排序数组-二分" class="headerlink" title="59：33. 搜索旋转排序数组 二分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">59：33. 搜索旋转排序数组</a> 二分</h2><p>排序数组被旋转了，要找目标值</p>
<ul>
<li>思路：先找排序数组的最小值，知道目标值在哪一段，然后在那一段进行二分查找</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 153. 寻找旋转排序数组中的最小值（返回的是下标）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = -<span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 开区间 (-1, n-1)</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 开区间不为空</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[-<span class="number">1</span>]:<span class="comment">#和最后的值比</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有序数组中找 target 的下标</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 开区间不为空</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid  <span class="comment"># 范围缩小到 (left, mid)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid  <span class="comment"># 范围缩小到 (mid, right)</span></span><br><span class="line">        <span class="keyword">return</span> right <span class="keyword">if</span> nums[right] == target <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="variable language_">self</span>.findMin(nums)</span><br><span class="line">        <span class="keyword">if</span> target &gt; nums[-<span class="number">1</span>]:  <span class="comment"># target 在第一段</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lower_bound(nums, -<span class="number">1</span>, i, target)  <span class="comment"># 开区间 (-1, i)</span></span><br><span class="line">        <span class="comment"># target 在第二段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.lower_bound(nums, i - <span class="number">1</span>, <span class="built_in">len</span>(nums), target)  <span class="comment"># 开区间 (i-1, n)</span></span><br></pre></td></tr></table></figure>

<h2 id="60：32-最长有效括号-标记-dp"><a href="#60：32-最长有效括号-标记-dp" class="headerlink" title="60：32. 最长有效括号 标记+dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">60：32. 最长有效括号</a> 标记+dp</h2><p>只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p>先遍历一遍字符串，用栈把左右括号进行匹配，然后计算连续1出现的最大次数即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = [] <span class="comment">#用于匹配括号</span></span><br><span class="line">        maxL = <span class="number">0</span> <span class="comment">#记录答案，最长有效括号子串</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        tmp = [<span class="number">0</span>] * n         <span class="comment">#标记字符串s</span></span><br><span class="line">        cur = <span class="number">0</span> <span class="comment">#中间变量，记录1出现次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    tmp[i], tmp[j] = <span class="number">1</span>,<span class="number">1</span>      <span class="comment">#匹配成功时标记    </span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> tmp:    <span class="comment">#计算连续1出现的最大次数</span></span><br><span class="line">            <span class="keyword">if</span> num:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:          <span class="comment">#遇到0时中断，进行对比，并重置</span></span><br><span class="line">                maxL = <span class="built_in">max</span>(cur, maxL)  </span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">        maxL = <span class="built_in">max</span>(cur,maxL) <span class="comment">#最后一次统计可能未终断，多做一次对比</span></span><br><span class="line">        <span class="keyword">return</span> maxL</span><br></pre></td></tr></table></figure>

<h2 id="61：31-下一个排列-trick"><a href="#61：31-下一个排列-trick" class="headerlink" title="61：31. 下一个排列 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">61：31. 下一个排列 trick</a></h2><p>下一个排列是字典序更大的排列</p>
<p>最大的字典序是从左到右依次递减的，下一个是最小字典序</p>
<p>否则从右向左寻找第一个严格递减的位置i；然后从右向左寻找第一个严格小于该位置值的位置j；</p>
<p>将i右侧的所有值翻转：</p>
<p>1 2 1 4 2 i &#x3D; 2,j&#x3D;4 1 2 1 2 4 1 然后翻转 得到2 1 2 1 4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> nums == <span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">return</span> nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i, j = n - <span class="number">2</span>, n - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> nums[i] &lt; nums[i + <span class="number">1</span>]:<span class="comment">#从右到左找第一个递减的位置i</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> nums[j] &gt; nums[i]:<span class="comment">#从右向左寻找第一个严格小于该位置值的位置j；</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]<span class="comment">#交换</span></span><br><span class="line"></span><br><span class="line">        left, right = i + <span class="number">1</span>, n - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="62：538-把二叉搜索树转换为累加树"><a href="#62：538-把二叉搜索树转换为累加树" class="headerlink" title="62：538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">62：538. 把二叉搜索树转换为累加树</a></h2><p>看不太懂题，但是先递归右边，再赋给中间，再递归左边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.right)  <span class="comment"># 递归右子树</span></span><br><span class="line">            <span class="comment"># 递归结束后，s 就等于右子树的所有节点值之和</span></span><br><span class="line">            <span class="keyword">nonlocal</span> s</span><br><span class="line">            s += node.val</span><br><span class="line">            node.val = s  <span class="comment"># 此时 s 就是 &gt;= node.val 的所有数之和</span></span><br><span class="line">            dfs(node.left)  <span class="comment"># 递归左子树</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="63：23-合并-K-个升序链表-堆"><a href="#63：23-合并-K-个升序链表-堆" class="headerlink" title="63：23. 合并 K 个升序链表 堆"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">63：23. 合并 K 个升序链表</a> 堆</h2><p>最小堆：这可以用最小堆实现。初始把所有链表的头节点入堆，然后不断弹出堆中最小节点 x，如果 x.next 不为空就加入堆中。循环直到堆为空。把弹出的节点按顺序拼接起来，就得到了答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode.__lt__ = <span class="keyword">lambda</span> a, b: a.val &lt; b.val  <span class="comment"># 让堆可以比较节点大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        cur = dummy = ListNode()  <span class="comment"># 哨兵节点，作为合并后链表头节点的前一个节点</span></span><br><span class="line">        h = [head <span class="keyword">for</span> head <span class="keyword">in</span> lists <span class="keyword">if</span> head]  <span class="comment"># 把所有非空链表的头节点入堆</span></span><br><span class="line">        heapify(h)  <span class="comment"># 堆化</span></span><br><span class="line">        <span class="keyword">while</span> h:  <span class="comment"># 循环直到堆为空</span></span><br><span class="line">            node = heappop(h)  <span class="comment"># 剩余节点中的最小节点</span></span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span>:  <span class="comment"># 下一个节点不为空</span></span><br><span class="line">                heappush(h, node.<span class="built_in">next</span>)  <span class="comment"># 下一个节点有可能是最小节点，入堆</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node  <span class="comment"># 把 node 添加到新链表的末尾</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>  <span class="comment"># 准备合并下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>  <span class="comment"># 哨兵节点的下一个节点就是新链表的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="64：560-和为-K-的子数组-前缀和"><a href="#64：560-和为-K-的子数组-前缀和" class="headerlink" title="64：560. 和为 K 的子数组 前缀和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">64：560. 和为 K 的子数组 </a>前缀和</h2><p>注意要求子数组是数组中连续的非空序列，所以要用前缀和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = s = <span class="number">0</span></span><br><span class="line">        cnt = defaultdict(<span class="built_in">int</span>)<span class="comment">#对于没有的key默认value为0</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># s[0]=0 单独统计</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            s += x <span class="comment">#s是前缀和</span></span><br><span class="line">            ans += cnt[s - k] <span class="comment">#ans+=cnt[-1]</span></span><br><span class="line">            cnt[s] += <span class="number">1</span> <span class="comment">#说明有一种方案达到和为s</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="65：21-合并两个有序链表-递推"><a href="#65：21-合并两个有序链表-递推" class="headerlink" title="65：21. 合并两个有序链表 递推"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">65：21. 合并两个有序链表</a> 递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1: <span class="keyword">return</span> list2  <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt;= list2.val:  <span class="comment"># 递归调用</span></span><br><span class="line">            list1.<span class="built_in">next</span> = <span class="variable language_">self</span>.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = <span class="variable language_">self</span>.mergeTwoLists(list1, list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>

<h2 id="66：20-有效的括号"><a href="#66：20-有效的括号" class="headerlink" title="66：20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">66：20. 有效的括号</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;]&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;&#125;&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> st <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="67：19-删除链表的倒数第-N-个结点-快慢指针"><a href="#67：19-删除链表的倒数第-N-个结点-快慢指针" class="headerlink" title="67：19.删除链表的倒数第 N 个结点 快慢指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">67：19.删除链表的倒数第 N 个结点</a> 快慢指针</h2><p>注意是倒数第n个，而不是正数第n个，所以slow才能找到倒数第一个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        fast = slow = dummy <span class="comment">#注意可以写连等</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="68：17-电话号码的字母组合-回溯"><a href="#68：17-电话号码的字母组合-回溯" class="headerlink" title="68：17. 电话号码的字母组合 回溯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">68：17. 电话号码的字母组合</a> 回溯</h2><p>符合回溯模板，for遍历选择，+letter写在参数里面了所以没有+ -的添加和移除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        phone = &#123;<span class="string">&#x27;2&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;3&#x27;</span>:[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;4&#x27;</span>:[<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;5&#x27;</span>:[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;6&#x27;</span>:[<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;7&#x27;</span>:[<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;8&#x27;</span>:[<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;9&#x27;</span>:[<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]&#125;<span class="comment">#创建dict</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">conbination, nextdigit</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nextdigit) == <span class="number">0</span>:</span><br><span class="line">                res.append(conbination)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phone[nextdigit[<span class="number">0</span>]]:</span><br><span class="line">                    backtrack(conbination + letter,nextdigit[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="string">&#x27;&#x27;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="69：15-三数之和-排序-双指针"><a href="#69：15-三数之和-排序-双指针" class="headerlink" title="69：15. 三数之和 排序+双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">69：15. 三数之和</a> 排序+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                sum_ = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:<span class="comment">#关键是去除重复解</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="70：11-盛最多水的容器-双指针"><a href="#70：11-盛最多水的容器-双指针" class="headerlink" title="70：11. 盛最多水的容器 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">70：11. 盛最多水的容器</a> 双指针</h2><p><em>S</em>(<em>i</em>,<em>j</em>)&#x3D;<em>min</em>(<em>h</em>[<em>i</em>],<em>h</em>[<em>j</em>])×(<em>j</em>−<em>i</em>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[i] * (j - i))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[j] * (j - i))</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="71：10-正则表达式匹配-没懂"><a href="#71：10-正则表达式匹配-没懂" class="headerlink" title="71：10. 正则表达式匹配 没懂"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/regular-expression-matching/">71：10. 正则表达式匹配 没懂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(s) + <span class="number">1</span>, <span class="built_in">len</span>(p) + <span class="number">1</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n, <span class="number">2</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">2</span>] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) \</span><br><span class="line">                           <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> <span class="keyword">else</span> \</span><br><span class="line">                           dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="72：5-最长回文子串"><a href="#72：5-最长回文子串" class="headerlink" title="72：5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">72：5. 最长回文子串</a></h2><p>使用双指针从中心往两边扩展</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">         <span class="comment"># 首先检查输入的字符串是否为空，如果为空则直接返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        start = end = <span class="number">0</span> <span class="comment">#记录最长的子串的节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">             <span class="comment"># 处理奇数长度的回文子串</span></span><br><span class="line">            left = right = i    <span class="comment">#以 s[i] 为中心，向两边扩展，直至左右字符不相等。</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            cur_len = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; end - start + <span class="number">1</span>:</span><br><span class="line">                start = left + <span class="number">1</span></span><br><span class="line">                end = right - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理偶数长度的回文子串</span></span><br><span class="line">            left, right = i, i+<span class="number">1</span>    <span class="comment">#以 s[i] 和 s[i+1] 为中心，向两边扩展，直至左右字符不相等。</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            cur_len = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; end - start + <span class="number">1</span>:</span><br><span class="line">                start = left + <span class="number">1</span></span><br><span class="line">                end = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="73：4-寻找两个正序数组的中位数"><a href="#73：4-寻找两个正序数组的中位数" class="headerlink" title="73：4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">73：4. 寻找两个正序数组的中位数</a></h2><p>逻辑是第k小的数，要么在nums1的前k个数，要么在nums2的前k个数。利用二分思想，每次可以删k&#x2F;2个不可能的数，对比当前n1[k&#x2F;2]和n2[k&#x2F;2]（减去删除过的数index）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;找到两个已排序数组中的第 k 小的元素&quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        index1, index2 = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 记录当前数组的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 边界情况（数组已经删光了或者求最小的数）</span></span><br><span class="line">            <span class="keyword">if</span> index1 == m:<span class="comment">#说明Nums1已经检查完了，第k小值在nums2里面</span></span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> index2 == n:</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:<span class="comment">#减到最小值了，比较当前开头的值即可</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 正常情况</span></span><br><span class="line">            newIndex1 = <span class="built_in">min</span>(index1 + k // <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>)  <span class="comment"># 记得用 min</span></span><br><span class="line">            newIndex2 = <span class="built_in">min</span>(index2 + k // <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">            pivot1 = nums1[newIndex1]</span><br><span class="line">            pivot2 = nums2[newIndex2]</span><br><span class="line">            <span class="keyword">if</span> pivot1 &lt;= pivot2:<span class="comment">#说明nums1的前k/2个不可能是，要移动指针到没检查过的部分</span></span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span></span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span></span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算两个已排序数组的中位数&quot;&quot;&quot;</span></span><br><span class="line">        totalLength = <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">if</span> totalLength % <span class="number">2</span> == <span class="number">1</span>: <span class="comment">#奇数，中位数就是第n+1//2小的数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.getKthElement(nums1, nums2, (totalLength + <span class="number">1</span>) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#偶数，中位数就是第n//2小和第n//2+1的数</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">self</span>.getKthElement(nums1, nums2, totalLength // <span class="number">2</span>) + </span><br><span class="line">                    <span class="variable language_">self</span>.getKthElement(nums1, nums2, totalLength // <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<h2 id="74：3-无重复字符的最长子串"><a href="#74：3-无重复字符的最长子串" class="headerlink" title="74：3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">74：3. 无重复字符的最长子串</a></h2><p>子串是连续的</p>
<p>滑动窗口+哈希表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        res = <span class="number">0</span> </span><br><span class="line">        i = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> dic:</span><br><span class="line">                i = <span class="built_in">max</span>(dic[s[j]], i) <span class="comment"># 更新左指针 i 保证指针不会往左跳</span></span><br><span class="line">            dic[s[j]] = j <span class="comment"># 更新哈希表记录，最新的值为s[j]的下标j</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i) <span class="comment"># 更新结果</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="75：2-两数相加-递推"><a href="#75：2-两数相加-递推" class="headerlink" title="75：2. 两数相加 递推"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">75：2. 两数相加</a> 递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry=<span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">return</span> ListNode(carry) <span class="keyword">if</span> carry <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 如果进位了，就额外创建一个节点</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            l1, l2 = l2, l1  </span><br><span class="line">        s = carry + l1.val + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># 节点值和进位加在一起</span></span><br><span class="line">        l1.val = s % <span class="number">10</span>  <span class="comment"># 直接修改原链表</span></span><br><span class="line">        l1.<span class="built_in">next</span> = <span class="variable language_">self</span>.addTwoNumbers(l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span>, s // <span class="number">10</span>)  <span class="comment"># 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1 <span class="comment">#把答案保存在l1中</span></span><br></pre></td></tr></table></figure>

<h2 id="76：79-单词搜索"><a href="#76：79-单词搜索" class="headerlink" title="76：79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">76：79. 单词搜索</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j, k</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; <span class="built_in">len</span>(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="built_in">len</span>(word) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            board[i][j] = <span class="string">&#x27;&#x27;</span> <span class="comment">#修改为空字符，表示元素已经访问过，防止搜索时重复访问</span></span><br><span class="line">            <span class="comment">#上下左右找下一个字符</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = word[k] <span class="comment">#回溯，恢复</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="77：114-二叉树展开为链表"><a href="#77：114-二叉树展开为链表" class="headerlink" title="77：114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">77：114. 二叉树展开为链表</a></h2><p>链表应该是先序遍历</p>
<p>头插法反过来了：右左中，倒着在插</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.flatten(root.right)</span><br><span class="line">        <span class="variable language_">self</span>.flatten(root.left)</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        root.right = <span class="variable language_">self</span>.head  <span class="comment"># 头插法，相当于链表的 root.next = head</span></span><br><span class="line">        <span class="variable language_">self</span>.head = root  <span class="comment"># 现在链表头节点是 root</span></span><br></pre></td></tr></table></figure>

<h2 id="78：621-任务调度器"><a href="#78：621-任务调度器" class="headerlink" title="78：621. 任务调度器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/task-scheduler/">78：621. 任务调度器</a></h2><p>假如 <strong>只有</strong> 任务 <code>A</code> 且出现了 <code>freq_A</code> 次，那么执行这些任务的最少时间是：<code>(freq_A - 1) * (n+1) + 1</code>.</p>
<p>假设有多种任务，且需要填充空闲，<code>A</code> 还是出现次数最多的任务。此时 <code>ans = (freq_A-1) * (n+1) + 1 + p</code> p 等于和 A 出现次数一致的数目。</p>
<p>first_freq就是出现次数最多的任务的执行次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leastInterval</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="built_in">str</span>], need: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, c = <span class="built_in">len</span>(tasks), Counter(tasks)</span><br><span class="line">        most = c.most_common() <span class="comment">#出现次数最多的任务</span></span><br><span class="line">        first_freq, cnt = most[<span class="number">0</span>][<span class="number">1</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(most)):</span><br><span class="line">            <span class="keyword">if</span> most[i][<span class="number">1</span>] == first_freq: cnt += <span class="number">1</span> <span class="comment">#因为most[i][1]只会&lt;=first_freq，&lt;时直接填补冻结，=时在最后加一步</span></span><br><span class="line">        res = (first_freq - <span class="number">1</span>) * (need+<span class="number">1</span>) + cnt </span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &gt;= n <span class="keyword">else</span> n <span class="comment">#这里也是有必要的，因为上面主要在处理有冻结的情况，如果res&lt;n说明其他任务不够填补冻结</span></span><br></pre></td></tr></table></figure>

<h2 id="79：617-合并二叉树"><a href="#79：617-合并二叉树" class="headerlink" title="79：617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">79：617. 合并二叉树</a></h2><p>合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">return</span> TreeNode(root1.val + root2.val, <span class="comment">#合并后的新节点</span></span><br><span class="line">            <span class="variable language_">self</span>.mergeTrees(root1.left, root2.left),    <span class="comment"># 合并左子树</span></span><br><span class="line">            <span class="variable language_">self</span>.mergeTrees(root1.right, root2.right))  <span class="comment"># 合并右子树</span></span><br></pre></td></tr></table></figure>

<h2 id="80：105-从前序与中序遍历序列构造二叉树"><a href="#80：105-从前序与中序遍历序列构造二叉树" class="headerlink" title="80：105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">80：105. 从前序与中序遍历序列构造二叉树</a></h2><p>知道前序（中左右）和中序（左中右），然后递推</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:  <span class="comment"># 空节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left_size = inorder.index(preorder[<span class="number">0</span>])  <span class="comment"># 左子树的大小</span></span><br><span class="line">        left = <span class="variable language_">self</span>.buildTree(preorder[<span class="number">1</span>: <span class="number">1</span> + left_size], inorder[:left_size])</span><br><span class="line">        right = <span class="variable language_">self</span>.buildTree(preorder[<span class="number">1</span> + left_size:], inorder[<span class="number">1</span> + left_size:])</span><br><span class="line">        <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>], left, right)</span><br></pre></td></tr></table></figure>

<h2 id="81：104-二叉树的最大深度"><a href="#81：104-二叉树的最大深度" class="headerlink" title="81：104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">81：104. 二叉树的最大深度</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l, r = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            l = <span class="variable language_">self</span>.maxDepth(root.left) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            r = <span class="variable language_">self</span>.maxDepth(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r)</span><br></pre></td></tr></table></figure>

<h2 id="82：102-二叉树的层序遍历"><a href="#82：102-二叉树的层序遍历" class="headerlink" title="82：102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">82：102. 二叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []<span class="comment">#当前层的内容，可看作子数组</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="83：101-对称二叉树"><a href="#83：101-对称二叉树" class="headerlink" title="83：101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">83：101. 对称二叉树</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.compare(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#两个节点都不为空时</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#当前两个节点相等，就比较子节点的外侧和内侧</span></span><br><span class="line">        outside = <span class="variable language_">self</span>.compare(left.left, right.right)</span><br><span class="line">        inside = <span class="variable language_">self</span>.compare(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure>

<h2 id="84：98-验证二叉搜索树"><a href="#84：98-验证二叉搜索树" class="headerlink" title="84：98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">84：98. 验证二叉搜索树</a></h2><p>前序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], left=-inf, right=inf</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        x = root.val</span><br><span class="line">        <span class="keyword">return</span> left &lt; x &lt; right <span class="keyword">and</span> \</span><br><span class="line">               <span class="variable language_">self</span>.isValidBST(root.left, left, x) <span class="keyword">and</span> \</span><br><span class="line">               <span class="variable language_">self</span>.isValidBST(root.right, x, right)</span><br></pre></td></tr></table></figure>

<h2 id="85：96-不同的二叉搜索树"><a href="#85：96-不同的二叉搜索树" class="headerlink" title="85：96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">85：96. 不同的二叉搜索树</a></h2><p>f(3) &#x3D; f(0)*f(2) + f(1)*f(1) + f(2)*f(0)</p>
<p>f(n) &#x3D; Σf(i)*f(n-1-i)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        store = [<span class="number">1</span>,<span class="number">1</span>] <span class="comment">#f(0),f(1)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> store[n]</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            s = m-<span class="number">1</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                count += store[i]*store[s-i]</span><br><span class="line">            store.append(count)</span><br><span class="line">        <span class="keyword">return</span> store[n]</span><br></pre></td></tr></table></figure>

<h2 id="86：94-二叉树的中序遍历"><a href="#86：94-二叉树的中序遍历" class="headerlink" title="86：94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">86：94. 二叉树的中序遍历</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="87：85-最大矩形"><a href="#87：85-最大矩形" class="headerlink" title="87：85. 最大矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/">87：85. 最大矩形</a></h2><p>前缀和：<strong>预处理数组</strong>的技术，用于快速计算数组中任意区间的和。使得后续的区间和查询可以在 <strong>O(1)</strong> 时间内完成。</p>
<p>单调栈：满足栈内元素<strong>单调递增或单调递减</strong>的性质，通常用于解决<strong>“下一个更大&#x2F;更小元素”</strong>问题</p>
<p>这里栈中存储的索引对应的值是单调递增的</p>
<p>注意为什么是求完一层j的前缀和就分析最大面积？以某一层为底，并不是最后一层为底面积就最大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])  <span class="comment">#矩阵的行列</span></span><br><span class="line">        pre = [<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="comment">#记录每个位置上方（包含当前位置）连续1的个数，前缀和</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 前缀和 要连续才行 获得每列的连续1的长度</span></span><br><span class="line">                pre[j] = pre[j] + <span class="number">1</span> <span class="keyword">if</span> matrix[i][j] == <span class="string">&quot;1&quot;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 单调栈</span></span><br><span class="line">            stack = [-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> k, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(pre):</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> pre[stack[-<span class="number">1</span>]] &gt; num:<span class="comment">#破坏了栈的单调递增性</span></span><br><span class="line">                    index = stack.pop()<span class="comment">#以该元素作为高度</span></span><br><span class="line">                    res = <span class="built_in">max</span>(res, pre[index] * (k - stack[-<span class="number">1</span>] - <span class="number">1</span>))<span class="comment">#宽度为[stack[-1],k-1]</span></span><br><span class="line">                stack.append(k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="88：84-柱状图中最大的矩形"><a href="#88：84-柱状图中最大的矩形" class="headerlink" title="88：84. 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">88：84. 柱状图中最大的矩形</a></h2><p>就是没有上一步的前缀和了，直接用单调栈（还是补个0防止下标越界）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        stack = [-<span class="number">1</span>]</span><br><span class="line">        heights.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> k, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(heights):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[-<span class="number">1</span>]] &gt; num:<span class="comment">#破坏了栈的单调递增性</span></span><br><span class="line">                index = stack.pop()<span class="comment">#以该元素作为高度</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, heights[index] * (k - stack[-<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">            stack.append(k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="89：1-两数之和"><a href="#89：1-两数之和" class="headerlink" title="89：1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">89：1. 两数之和</a></h2><p>只返回一种答案</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = <span class="built_in">dict</span>() <span class="comment">#python中map就是dict</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  </span><br><span class="line">            <span class="keyword">if</span> target - value <span class="keyword">in</span> record:<span class="comment">#寻找匹配的key</span></span><br><span class="line">                <span class="keyword">return</span> [index, record[target - value]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                record[value] = index <span class="comment">#key不重复</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h2 id="90：78-子集"><a href="#90：78-子集" class="headerlink" title="90：78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">90：78. 子集</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">i, tmp</span>):</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):<span class="comment">#回溯的for选择</span></span><br><span class="line">                helper(j + <span class="number">1</span>,tmp + [nums[j]] )</span><br><span class="line">        helper(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>

<h2 id="91：76-最小覆盖子串"><a href="#91：76-最小覆盖子串" class="headerlink" title="91：76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">91：76. 最小覆盖子串</a></h2><p>滑动窗口：把右指针从左到右移动，当涵盖时while移动左指针，找到更短的子串。计数器可以比较，很方便判断是否涵盖（注意不要求连续）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans_left, ans_right = -<span class="number">1</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        cnt_s = Counter()  <span class="comment"># s 子串字母的出现次数</span></span><br><span class="line">        cnt_t = Counter(t)  <span class="comment"># t 中字母的出现次数</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):  <span class="comment"># 移动子串右端点</span></span><br><span class="line">            cnt_s[c] += <span class="number">1</span>  <span class="comment"># 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">while</span> cnt_s &gt;= cnt_t:  <span class="comment"># 涵盖</span></span><br><span class="line">                <span class="keyword">if</span> right - left &lt; ans_right - ans_left:  <span class="comment"># 找到更短的子串</span></span><br><span class="line">                    ans_left, ans_right = left, right  <span class="comment"># 记录此时的左右端点</span></span><br><span class="line">                cnt_s[s[left]] -= <span class="number">1</span>  <span class="comment"># 左端点字母移出子串</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> ans_left &lt; <span class="number">0</span> <span class="keyword">else</span> s[ans_left: ans_right + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<ol>
<li>用defaultdict比Counter速度更快</li>
<li><code>less</code> 初始化为 <code>len(cnt)</code>，即 <code>t</code> 中<strong>不同字符的个数</strong>。例如，<code>t = &quot;AABC&quot;</code> 有 3 个不同字符（<code>A</code>、<code>B</code>、<code>C</code>），所以 <code>less = 3</code>。表示当前窗口中<strong>还有多少种字符没有满足 <code>t</code> 中的要求</strong>（即窗口中该字符的出现次数 <strong>小于</strong> <code>t</code> 中的出现次数）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        ans_left, ans_right = -<span class="number">1</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        cnt = defaultdict(<span class="built_in">int</span>)  <span class="comment"># 比 Counter 更快</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            cnt[c] += <span class="number">1</span></span><br><span class="line">        less = <span class="built_in">len</span>(cnt)  <span class="comment">#t中不同字符的数目</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):  <span class="comment"># 移动子串右端点</span></span><br><span class="line">            cnt[c] -= <span class="number">1</span>  <span class="comment"># 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">if</span> cnt[c] == <span class="number">0</span>:</span><br><span class="line">                less -= <span class="number">1</span> <span class="comment">#说明字符c满足了t中的要求</span></span><br><span class="line">            <span class="keyword">while</span> less == <span class="number">0</span>:  <span class="comment"># 涵盖：字符串t都在s中出现了 尝试找更短的子串</span></span><br><span class="line">                <span class="keyword">if</span> right - left &lt; ans_right - ans_left:  <span class="comment"># 找到更短的子串</span></span><br><span class="line">                    ans_left, ans_right = left, right  <span class="comment"># 记录此时的左右端点</span></span><br><span class="line">                x = s[left]  <span class="comment"># 左端点字母</span></span><br><span class="line">                <span class="keyword">if</span> cnt[x] == <span class="number">0</span>:</span><br><span class="line">                    less += <span class="number">1</span> <span class="comment">#因为我们想移除字母x，如果不移除时x满足了t的要求，less在前面会-1，这里移除就要+1</span></span><br><span class="line">                cnt[x] += <span class="number">1</span>  <span class="comment"># 左端点字母移出子串</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> <span class="keyword">if</span> ans_left &lt; <span class="number">0</span> <span class="keyword">else</span> s[ans_left: ans_right + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="92：75-颜色分类三指针"><a href="#92：75-颜色分类三指针" class="headerlink" title="92：75. 颜色分类三指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">92：75. 颜色分类</a>三指针</h2><p>维护三个指针 p0：指向 0 应该放置的位置；p0左边全是0, p0本身并不包括0</p>
<p>p2：指向 2 应该放置的位置；p2右边全是2, p2本身并不包括2</p>
<p>i：当前遍历位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        p0, i , p2 = <span class="number">0</span>,<span class="number">0</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= p2:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span> <span class="comment">#这里可以增加，因为p0和i都是从左边开始，nums[p0]一定是0/1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i], nums[p2] = nums[p2], nums[i]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 注意：i 不增加，因为换过来的 nums[i] 还要检查</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="93：72-编辑距离"><a href="#93：72-编辑距离" class="headerlink" title="93：72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">93：72. 编辑距离</a></h2><p><code>dp[i][j]</code> 代表 <code>word1</code> 到 <code>i</code> 位置转换成 <code>word2</code> 到 <code>j</code> 位置需要最少步数</p>
<p>当 word1[i] &#x3D;&#x3D; word2[j]，dp[i][j] &#x3D; dp[i-1][j-1]；</p>
<p>当 word1[i] !&#x3D; word2[j]，dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1 + <span class="number">1</span>)] <span class="comment">#dp[0][0]为0，不用额外赋值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="94：70-爬楼梯"><a href="#94：70-爬楼梯" class="headerlink" title="94：70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">94：70. 爬楼梯</a></h2><p>#dp[n] &#x3D; dp[n - 1] + dp[n - 2]</p>
<p>​    #dp[1] &#x3D; 1</p>
<p>​    #dp[2] &#x3D; 2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>

<h2 id="95：581-最短无序连续子数组-双指针"><a href="#95：581-最短无序连续子数组-双指针" class="headerlink" title="95：581. 最短无序连续子数组 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">95：581. 最短无序连续子数组</a> 双指针</h2><p>单调性：右边的数永远大于左边的所有数，左边的数永远小于右边的所有数。</p>
<p>找到的是连续子数组，所以left&#x2F;right找到存在比左边数小的right和存在比右边数大的left</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findUnsortedSubarray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        left, right, min_num, max_num = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): <span class="comment">#正序遍历</span></span><br><span class="line">            <span class="keyword">if</span> n &lt; max_num:</span><br><span class="line">                right = i <span class="comment">#在右边的数小于自己左边的数时会得到right，不一定相邻</span></span><br><span class="line">            max_num = <span class="built_in">max</span>(max_num, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment">#倒序遍历</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; min_num: <span class="comment">#在左边的数大于自己右边的数时会得到right，不一定相邻</span></span><br><span class="line">                left = i</span><br><span class="line">            min_num = <span class="built_in">min</span>(min_num, nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> left == right <span class="keyword">else</span> right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="96：64-最小路径和"><a href="#96：64-最小路径和" class="headerlink" title="96：64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">96：64. 最小路径和</a></h2><p>找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self, grid: [[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j] <span class="comment">#朝右走</span></span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j] <span class="comment">#朝下走</span></span><br><span class="line">                <span class="keyword">else</span>: grid[i][j] = <span class="built_in">min</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j] <span class="comment">#朝右和朝下走</span></span><br><span class="line">        <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="97：62-不同路径"><a href="#97：62-不同路径" class="headerlink" title="97：62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">97：62. 不同路径</a></h2><p>dfs(i,j)表示从起点 (0,0) 走到 (<em>i</em>,<em>j</em>) 的路径数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache  </span><span class="comment"># 缓存装饰器，避免重复计算 dfs 的结果（一行代码实现记忆化）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: <span class="comment">#这是因为呆在原地也算一种</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i - <span class="number">1</span>, j) + dfs(i, j - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs(m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="98：56-合并区间"><a href="#98：56-合并区间" class="headerlink" title="98：56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">98：56. 合并区间</a></h2><p>按照左端点排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> p: p[<span class="number">0</span>])  <span class="comment"># 按照左端点从小到大排序</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">and</span> p[<span class="number">0</span>] &lt;= ans[-<span class="number">1</span>][<span class="number">1</span>]:  <span class="comment"># 可以合并</span></span><br><span class="line">                ans[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ans[-<span class="number">1</span>][<span class="number">1</span>], p[<span class="number">1</span>])  <span class="comment"># 更新右端点最大值</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 不相交，无法合并</span></span><br><span class="line">                ans.append(p)  <span class="comment"># 新的合并区间</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="99：55-跳跃游戏"><a href="#99：55-跳跃游戏" class="headerlink" title="99：55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">99：55. 跳跃游戏</a></h2><p>思路：尽可能到达最远的位置。最远能到达某个位置，就一定能到达它前面的任何位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        max_i = <span class="number">0</span>       <span class="comment">#初始化当前能到达最远的位置</span></span><br><span class="line">        <span class="keyword">for</span> i, jump <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):   <span class="comment">#i为当前位置，jump是当前位置的跳数</span></span><br><span class="line">            <span class="keyword">if</span> max_i &gt;= i <span class="keyword">and</span> i + jump &gt; max_i:  <span class="comment">#如果当前位置能到达，并且当前位置+跳数&gt;最远位置  </span></span><br><span class="line">                max_i = i + jump  <span class="comment">#更新最远能到达位置</span></span><br><span class="line">            <span class="comment"># 提前结束</span></span><br><span class="line">            <span class="keyword">if</span> max_i&lt; i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#i是最后一个下标</span></span><br></pre></td></tr></table></figure>

<h2 id="100：53-最大子数组和"><a href="#100：53-最大子数组和" class="headerlink" title="100：53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">100：53. 最大子数组和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#dp[i]=max(dp[i-1],0)+nums[i]</span></span><br><span class="line">        ans = -inf</span><br><span class="line">        dp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            dp = <span class="built_in">max</span>(dp, <span class="number">0</span>) + n</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>




        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E8%BD%AF%E4%BB%B6/"># 软件</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/03/15/%E7%8E%8B%E6%A0%91%E6%A3%AE%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0/">王树森推荐系统公开课笔记</a>
            
        </section>


    </article>
</div>


    <div id="gitalk-container"></div>
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'blog_comment',
        owner: 'lyxx2535',
        admin: 'lyxx2535',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Annie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | 2020 - 2025
            <br>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    Total visitors:
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;|&nbsp;


<span class="site-pv">
    Total views:
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

          </span>
    </div>
</footer>

    </div>
</body>

</html>