<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Annie">





<title>力扣刷题（hot100、代码随想录等） | Annie&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Annie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Annie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">力扣刷题（hot100、代码随想录等）</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Annie</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">April 2, 2025&nbsp;&nbsp;22:58:59</a>
                        </span>
                    
                    
                        <span class="post-category">
                        分类:
                            
                                <a href="/categories/%E8%BD%AF%E4%BB%B6/">软件</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>代码随想录使用Java和Python3刷题</p>
<ul>
<li>从4.2节开始，只用python做，节约时间</li>
</ul>
<p>hot100完成简单与中等题，没研究多种方法，选择我认为最好懂的</p>
<p>TODO:</p>
<ol>
<li>代码随想录中的相关题目推荐我没做，回头再巩固</li>
<li>labuladong</li>
<li>hot150</li>
<li>剑指offer</li>
<li>力扣75</li>
</ol>
<h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-数组理论基础"><a href="#1-1-数组理论基础" class="headerlink" title="1.1 数组理论基础"></a>1.1 数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<p>因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要<strong>移动</strong>其他元素的地址。</p>
<ul>
<li><code>vector</code>的底层实现是<code>array</code><ul>
<li>在 C++ 中，<code>vector</code>是一种动态数组，它的底层是基于普通数组（<code>array</code>）来实现的。这意味着<code>vector</code>在内存中是以连续的存储单元来存放元素的，就像普通数组一样。这种底层实现方式使得<code>vector</code>能够像数组一样快速地随机访问元素，即可以通过索引快速获取到任意位置的元素。</li>
</ul>
</li>
<li><code>vector</code>是容器，不是数组<ul>
<li><strong>容器的概念</strong>：<code>vector</code>是 C++ 标准模板库（STL）中的一种容器类。容器是一种能够存储和管理其他对象的对象，它提供了一系列的成员函数和操作符，用于方便地对存储的元素进行各种操作，如插入、删除、遍历等。<code>vector</code>作为容器，具有很多方便的功能和特性，比如它可以自动管理内存，根据元素的添加和删除自动调整自身的大小。</li>
<li><strong>与数组的区别</strong>：虽然<code>vector</code>在底层利用了数组的存储方式，但它和普通的 C 风格数组有很多不同之处。普通数组的大小是固定的，在定义时就需要指定其大小，而且在程序运行期间大小不能改变。而<code>vector</code>的大小是可以动态变化的，可以在运行时根据需要添加或删除元素，它会自动分配和释放内存来适应元素数量的变化。</li>
</ul>
</li>
</ul>
<p>在C++中二维数组是连续分布的，对于int型数组，两个相邻数组元素地址差4个字节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//0x7ffee4065820 0x7ffee4065824 0x7ffee4065828</span></span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//0x7ffee406582c 0x7ffee4065830 0x7ffee4065834</span></span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_arr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机，所以看不到每个元素的地址情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_arr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//[I@7852e922 [I@4e25154f [I@70dea4e [I@5c647e05</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arr[0]</code> 实际上是一个一维数组对象的引用</li>
<li>输出一个类似 <code>[I@hashcode</code> 的字符串，其中 <code>[I</code> 表示这是一个一维整数数组，<code>@hashcode</code> 是该数组对象在内存中的哈希码，它可以在一定程度上被认为是该数组对象的地址码（但不是真正的物理地址，而是处理过后的数值）</li>
<li>行指针数组在内存中是连续存储的，而每个行所指向的一维数组（即二维数组的每一行）在内存中的存储位置是不连续的<ul>
<li>这样可以使每行的长度不同，实现不规则的二维数组</li>
</ul>
</li>
</ul>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201214111631844.png" alt="算法通关数组3" style="zoom: 25%;" />

<h2 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>二分法的前提条件：有序数组+无重复元素</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)<ul>
<li>这是因为search只使用left、right、middle，在执行过程中额外占用的空间是固定的，与输入数据的规模n无关</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//先在开头判断下可以提升效率，避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//注意可以写成并排，int left = 0, right = nums.length - 1;</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;<span class="comment">//当left和right都很大时可能会溢出，</span></span><br><span class="line">            <span class="comment">// int mid = left + ((right - left) &gt;&gt; 1);写成位运算可以提升效率，改为减法的形式也可以避免溢出。注意要写括号，不然+的优先级大于&gt;&gt;有符号右移</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] == target)&#123; <span class="comment">//看target是否在[left, right]区间内</span></span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:<span class="comment">#-&gt; int是返回值类型提示，List[int]是参数类型提示，self 会自动指向调用该方法的对象</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; target <span class="keyword">or</span> nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>] &lt; target: <span class="comment">#注意逻辑或</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-移除元素"><a href="#1-3-移除元素" class="headerlink" title="1.3 移除元素"></a>1.3 移除元素</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。不需要考虑数组中超出新长度后面的元素。</p>
<p>可以使用暴力解法，发现需要移除的元素，就将数组集体向前移动一位</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p>定义快慢指针：时间复杂度：O(n)、空间复杂度：O(1)。并不改变元素的相对位置。</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新新数组下标的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//fast指向新数组的元素，slow表示新数组的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        fast, slow = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> fast <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):<span class="comment">#fast会遍历现有数组的每一个值，等于val的被覆盖</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h4 id="相向双指针法"><a href="#相向双指针法" class="headerlink" title="相向双指针法"></a>相向双指针法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br></pre></td></tr></table></figure>

<p>题目描述中的示例告诉我们不一定要按照顺序得到新数组，所以可以另一个指针从后往前</p>
<p>可以让右指针不断地指向不为val的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;<span class="comment">//fast指向新数组的元素，slow表示新数组的下标</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == val)&#123;</span><br><span class="line">            right--;<span class="comment">//先把右指针移到第一个不是val的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; left &lt;= right; left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == val)&#123;</span><br><span class="line">                    right--;<span class="comment">//先把右指针移到第一个不是val的值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以不判断右指针是否为val，先用右侧覆盖左侧再说，后面再检查左指针（最简洁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;<span class="comment">//fast指向新数组的元素，slow表示新数组的下标</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == val)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;<span class="comment">//不管right指向的是不是val，先覆盖，反正马上left又会检查</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[left] == val:</span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h2 id="1-4-有序数组的平方"><a href="#1-4-有序数组的平方" class="headerlink" title="1.4 有序数组的平方"></a>1.4 有序数组的平方</h2><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p>暴力法： O(n + nlogn)</p>
<p>双指针法：两侧的数字绝对值大，所以平方也大，所以可以用两侧到中间，不断比较大小。O(n)</p>
<ul>
<li>注意这道题得创建个新数组，如果在原数组上改的话两个指针不够<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202501222049301.png" alt="image-20250122204856186"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] * nums[left] &gt;= nums[right] * nums[right])&#123;</span><br><span class="line">                result[i--] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[i--] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(nums[l]) &gt;= <span class="built_in">abs</span>(nums[r]):</span><br><span class="line">                res.append(nums[l] ** <span class="number">2</span>)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(nums[r] ** <span class="number">2</span>)</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="1-5-长度最小的子数组"><a href="#1-5-长度最小的子数组" class="headerlink" title="1.5 长度最小的子数组"></a>1.5 长度最小的子数组</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><p>找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度</p>
<p>暴力法：两层循环，看每个起点连续多少能超过s，比较哪个最短</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>滑动窗口</strong>：不断调节子序列的起始位置和终止位置，从而得出我们要想的结果</p>
<p>只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。（不然还要一个循环表示起始位置：暴力）</p>
<p>滑动窗口也可以理解为双指针法的一种：主要确定如下三点：</p>
<ul>
<li>窗口内是什么？就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li>
<li>如何移动窗口的起始位置？如果当前窗口的值大于等于s了，窗口就要向前移动了。（此时已获得一个子序列）</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p><strong>精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置</strong></p>
<ul>
<li>时间复杂度：O(n)：因为每个元素在滑动窗后进来操作一次，出去操作一次，其实是O(2n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录当前子序列的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录序列的左指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++)&#123;<span class="comment">//记录序列的右指针</span></span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;<span class="comment">//因为每次移动i都会产生新的子序列，所以每次都要检查</span></span><br><span class="line">                res = Math.min(j - i + <span class="number">1</span> , res);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE? <span class="number">0</span> : res;<span class="comment">//Java才有的条件表达式，python没有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, <span class="built_in">sum</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span> += nums[r]</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">sum</span> &gt;= target:</span><br><span class="line">                res = <span class="built_in">min</span>(res, r - l + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">sum</span> -= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-螺旋矩阵II"><a href="#1-6-螺旋矩阵II" class="headerlink" title="1.6 螺旋矩阵II"></a>1.6 螺旋矩阵II</h2><h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><p><strong>模拟行为</strong>：如何坚持循环不变量？确定1-4每次循环的数目为n-loop，然后用左闭右开的区间约束</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img" style="zoom:33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//没必要专门记录起始点，因为每轮循环的起始点就是(loop - 1, loop - 1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(loop &lt;= n / <span class="number">2</span>)&#123;<span class="comment">//采用左闭右开的写法，每次只循环n-loop个数字 注意n/2是整数</span></span><br><span class="line">            <span class="keyword">for</span>(; j &lt; n - loop; j++)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &lt; n - loop; i++)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt; loop - <span class="number">1</span>; j--)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt; loop - <span class="number">1</span>; i--)&#123;</span><br><span class="line">                nums[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            nums[i][j] = count;<span class="comment">//最后存中间的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment">#这里是创建n*n的数组，其中_表示占位符，因为不需要知道此时循环到第几层，无需写for i in range(n)</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        loop = <span class="number">1</span> </span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> loop &lt;= n // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">while</span> j &lt; n - loop:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n - loop:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; loop - <span class="number">1</span>:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt; loop - <span class="number">1</span>:</span><br><span class="line">                nums[i][j] = count</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            nums[i][j] = count</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="1-7-区间和"><a href="#1-7-区间和" class="headerlink" title="1.7 区间和"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1070">1.7 区间和</a></h2><p>输出每个指定区间内元素的总和。</p>
<p>前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20240627110604.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Scanner 对象，用于从标准输入读取数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//跳过前面的空白字符（包括空格、制表符、换行符等），直到找到一个有效的整数输入</span></span><br><span class="line">        <span class="type">int</span>[] vec = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//存储数组</span></span><br><span class="line">        <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//存储前缀和</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            vec[i] = scanner.nextInt();</span><br><span class="line">            presum += vec[i];</span><br><span class="line">            p[i] = presum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;<span class="comment">//判断是否还有输入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">0</span>)&#123;<span class="comment">//注意这里防止下标越界</span></span><br><span class="line">                res = p[b];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = p[b] - p[a - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 Scanner 对象，释放资源</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.read</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = <span class="built_in">input</span>() <span class="comment">#输入为&#x27;5\n1\n2\n3\n4\n5\n0 1\n1 3&#x27; 可以打印了解格式</span></span><br><span class="line">    data = data.split()<span class="comment">#[&#x27;5&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;3&#x27;]</span></span><br><span class="line">    index = <span class="number">0</span> <span class="comment">#表示当前遍历到的data下标</span></span><br><span class="line">    n = <span class="built_in">int</span>(data[index])</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    vec = []</span><br><span class="line">    p = []</span><br><span class="line">    presum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        num = <span class="built_in">int</span>(data[index])</span><br><span class="line">        presum += num</span><br><span class="line">        vec.append(num)</span><br><span class="line">        p.append(presum)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(data):</span><br><span class="line">        a, b = <span class="built_in">int</span>(data[index]), <span class="built_in">int</span>(data[index + <span class="number">1</span>])</span><br><span class="line">        index += <span class="number">2</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">            res = p[b]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = p[b] - p[a - <span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="1-8-开发商购买土地"><a href="#1-8-开发商购买土地" class="headerlink" title="1.8 开发商购买土地"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1044">1.8 开发商购买土地</a></h2><p>注意只能按行分或按列分：二维前缀和枚举按行分和按列分的所有情况，然后取最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">// 前缀和,row[i]表示前i行（包括第i行）的数据之和</span></span><br><span class="line">        <span class="type">int</span>[] col = <span class="keyword">new</span> <span class="title class_">int</span>[m];<span class="comment">// 前缀和,col[i]表示前i列（包括第i列）的数据之和</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                array[i][j] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求row[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rowSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                rowSum += array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            row[i] = rowSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求col[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">colSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                colSum += array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            col[j] = colSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowResult</span> <span class="operator">=</span> Main.result(row);<span class="comment">//按行分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">colResult</span> <span class="operator">=</span> Main.result(col);<span class="comment">//按列分</span></span><br><span class="line">        System.out.println(Math.min(rowResult, colResult));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">result</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;<span class="comment">//求该前缀和划分如何最小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> array[array.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)&#123;<span class="comment">//注意total不用于划分，所以要-1</span></span><br><span class="line">            res = Math.min(res, Math.abs(total - <span class="number">2</span> * array[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.read</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">result</span>(<span class="params">arr</span>):<span class="comment">#这里没有class，所以不用写self</span></span><br><span class="line">    total = arr[<span class="built_in">len</span>(arr) - <span class="number">1</span>]</span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>):</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">abs</span>(total - <span class="number">2</span> * arr[i]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = <span class="built_in">input</span>().split()</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    n, m = <span class="built_in">int</span>(data[index]), <span class="built_in">int</span>(data[index + <span class="number">1</span>])</span><br><span class="line">    index += <span class="number">2</span></span><br><span class="line">    array = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    row = [<span class="number">0</span>] * n</span><br><span class="line">    col = [<span class="number">0</span>] * m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            array[i][j] = <span class="built_in">int</span>(data[index])</span><br><span class="line">            index += <span class="number">1</span><span class="comment">#注意这里别忘了写</span></span><br><span class="line">            </span><br><span class="line">    rowsum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            rowsum += array[i][j]</span><br><span class="line">        row[i] = rowsum</span><br><span class="line">        </span><br><span class="line">    colsum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            colsum += array[i][j]</span><br><span class="line">        col[j] = colsum</span><br><span class="line"></span><br><span class="line">    rowresult = result(row)</span><br><span class="line">    colresult = result(col)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">min</span>(rowresult, colresult))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="1-9-总结篇"><a href="#1-9-总结篇" class="headerlink" title="1.9 总结篇"></a>1.9 总结篇</h2><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"></p>
<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><h2 id="2-1-链表理论基础"><a href="#2-1-链表理论基础" class="headerlink" title="2.1 链表理论基础"></a>2.1 链表理论基础</h2><p>单链表：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="链表1"></p>
<p>双链表：既可以向前查询也可以向后查询。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt="链表2"></p>
<p>循环链表：链表首尾相连，可以用来解决约瑟夫环问题（n个人围成圈，报到k出列）。</p>
<p>链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png" alt="链表3"></p>
<p>链表的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 结点的值</span></span><br><span class="line">    ListNode next;<span class="comment">// 下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p>删除节点：C++需要手动释放，Java、Python有自己的内存回收机制无需手动释放</p>
<blockquote>
<p>就算使用C++来做leetcode，如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p>
</blockquote>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png" alt="链表-链表与数据性能对比">数组在定义的时候长度是固定的，链表长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>
<h2 id="2-2-移除链表元素"><a href="#2-2-移除链表元素" class="headerlink" title="2.2 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">2.2 移除链表元素</a></h2><p>这里就涉及如下链表操作的两种方式：</p>
<ul>
<li><strong>直接使用原来的链表来进行删除操作。</strong></li>
<li><strong>设置一个虚拟头结点在进行删除操作。</strong>dummy会简单些，统一写dummy！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy; </span><br><span class="line">        <span class="keyword">while</span>(curr.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:<span class="comment">#Optional表示可以是ListNode类型，也可以是None。</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        curr = dummy</span><br><span class="line">        <span class="keyword">while</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.<span class="built_in">next</span>.val == val:</span><br><span class="line">                curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-设计链表"><a href="#2-3-设计链表" class="headerlink" title="2.3 设计链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/description/">2.3 设计链表</a></h2><p>这道题目设计链表的五个接口：</p>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
<p>采用设置一个虚拟头结点</p>
<ul>
<li>时间复杂度: 涉及 <code>index</code> 的相关操作为 O(index), 其余为 O(1)</li>
<li>空间复杂度: O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MyLinkedList类的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> ListNode head;<span class="comment">//dummy结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;<span class="comment">//注意index从0开始，所以实际的下标为index+1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//私有属性，相当于this.size</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index == size)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size)&#123;<span class="comment">//实际的下标是index + 1</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            newNode.next = cur;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = pre.next.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ListNode</code> 就是一个非静态内部类。它的实例依赖于外部类的实例。内部类 <code>ListNode</code> 可以直接访问 <code>MyLinkedList</code> 的私有属性（如 <code>head</code> 和 <code>size</code>），但在这个例子中并没有直接访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val = <span class="number">0</span>, <span class="built_in">next</span> = <span class="literal">None</span></span>):</span><br><span class="line">            <span class="variable language_">self</span>.val = val</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.head = <span class="variable language_">self</span>.ListNode()<span class="comment">#内部类也要写self</span></span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= <span class="variable language_">self</span>.size: <span class="comment">#访问内部属性必须写self</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        cur = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index + <span class="number">1</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtHead</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        newNode = <span class="variable language_">self</span>.ListNode(val)</span><br><span class="line">        newNode.<span class="built_in">next</span> = <span class="variable language_">self</span>.head.<span class="built_in">next</span></span><br><span class="line">        <span class="variable language_">self</span>.head.<span class="built_in">next</span> = newNode</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtTail</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        newNode = <span class="variable language_">self</span>.ListNode(val)</span><br><span class="line">        cur = <span class="variable language_">self</span>.head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = newNode</span><br><span class="line">        <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index == <span class="variable language_">self</span>.size:</span><br><span class="line">            <span class="variable language_">self</span>.addAtTail(val) <span class="comment">#注意访问实例方法也要写self</span></span><br><span class="line">        <span class="keyword">elif</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; <span class="variable language_">self</span>.size:</span><br><span class="line">            newNode = <span class="variable language_">self</span>.ListNode(val)</span><br><span class="line">            pre = <span class="variable language_">self</span>.head</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">            newNode.<span class="built_in">next</span> = pre.<span class="built_in">next</span>   </span><br><span class="line">            pre.<span class="built_in">next</span> = newNode</span><br><span class="line">            <span class="variable language_">self</span>.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAtIndex</span>(<span class="params">self, index: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> index &lt; <span class="variable language_">self</span>.size:</span><br><span class="line">            pre = <span class="variable language_">self</span>.head </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="variable language_">self</span>.size -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>注意python<strong>访问实例属性、实例方法、内部类</strong>都要使用 <code>self</code>。但是访问外部类不用。</p>
<h2 id="2-4-翻转链表"><a href="#2-4-翻转链表" class="headerlink" title="2.4 翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">2.4 翻转链表</a></h2><p>不需要定义一个新的链表，直接改变链表的next指针的指向即可，记得把 cur-&gt;next 节点用tmp指针保存一下即可</p>
<ul>
<li>用双指针法从前往后翻转指针指向，比较直接好理解（递归感觉这题没啥必要，反而复杂了）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;<span class="comment">//如果直接访问head.next，那head为空时会报错，这样更有普适性</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//写外面单纯更简洁</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;<span class="comment">//会把head.next赋为空</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span><span class="comment">#写里面也可以，与效率无关</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<p>因为每次循环都会进行垃圾回收，所以tmp定义在循环外部内部感觉区别不大，编译器会复用栈上的同一块内存，创建和销毁都很高效。</p>
<h2 id="2-5-两两交换链表中的节点"><a href="#2-5-两两交换链表中的节点" class="headerlink" title="2.5 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">2.5 两两交换链表中的节点</a></h2><p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="24.两两交换链表中的节点2"></p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="24.两两交换链表中的节点3"></p>
<p>重点是每次只交换2个数，不用纠结tmp3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp1</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp2</span> <span class="operator">=</span> tmp1.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp3</span> <span class="operator">=</span> tmp2.next;<span class="comment">//可能为空</span></span><br><span class="line">            cur.next = tmp2;<span class="comment">//每次交换2个数</span></span><br><span class="line">            tmp2.next = tmp1;</span><br><span class="line">            tmp1.next = tmp3;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            tmp1 = cur.<span class="built_in">next</span></span><br><span class="line">            tmp2 = tmp1.<span class="built_in">next</span></span><br><span class="line">            tmp3 = tmp2.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = tmp2</span><br><span class="line">            tmp2.<span class="built_in">next</span> = tmp1</span><br><span class="line">            tmp1.<span class="built_in">next</span> = tmp3</span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-删除链表的倒数第-N-个结点"><a href="#2-6-删除链表的倒数第-N-个结点" class="headerlink" title="2.6 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">2.6 删除链表的倒数第 N 个结点</a></h2><p><img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png" alt="img"></p>
<p>扫描两遍很简单，如何只扫描一遍？双指针法！</p>
<ul>
<li>fast首先走n + 1步，然后fast和slow同时移动，直到fast指向末尾</li>
<li>这样可以让slow正好在待删节点的前一个，原理是间距固定为n+1，fast为空时flow正好指向倒数n+1个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy, slow = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        fast = slow = dummy <span class="comment">#注意可以写连等</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-链表相交"><a href="#2-7-链表相交" class="headerlink" title="2.7 链表相交"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">2.7 链表相交</a></h2><p><img src="https://pic.leetcode-cn.com/1598234668-MAyoGk-%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2.png"></p>
<p>注意交点不是数值相等，而是指针相等，可以理解为物理结构就是相交的，先有图这样的物理结构再有题目。所以不要纠结为什么val和next一样但地址不一样，题目比较的就是地址。</p>
<ul>
<li><strong>引用</strong>指的是链表节点在内存中的地址。当我们说两个链表相交时，意味着它们共享同一个节点（即两个链表中的某个节点的内存地址相同），即引用完全相同。</li>
</ul>
<p>因为相交后面的节点一定一样，所以先将长一点的链表移动到<strong>相同的位置</strong>，然后同时向后移动cur比较即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">null</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> Math.abs(lenA - lenB);</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">while</span>(gap != <span class="number">0</span>)&#123;</span><br><span class="line">                curA = curA.next;</span><br><span class="line">                gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(gap != <span class="number">0</span>)&#123;</span><br><span class="line">                curB = curB.next;</span><br><span class="line">                gap--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不断比较节点是否相同</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curA = curA.next;</span><br><span class="line">                curB = curB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        lenA, lenB = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="keyword">while</span> curA:</span><br><span class="line">            curA = curA.<span class="built_in">next</span></span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> curB:</span><br><span class="line">            curB = curB.<span class="built_in">next</span></span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        gap = <span class="built_in">abs</span>(lenA - lenB)</span><br><span class="line">        curA = headA</span><br><span class="line">        curB = headB</span><br><span class="line">        <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">            <span class="keyword">while</span> gap:</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">                gap -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> gap:</span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">                gap -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> curA:</span><br><span class="line">            <span class="keyword">if</span> curA == curB:</span><br><span class="line">                <span class="keyword">return</span> curA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curA = curA.<span class="built_in">next</span></span><br><span class="line">                curB = curB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-环形链表-II"><a href="#2-8-环形链表-II" class="headerlink" title="2.8 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">2.8 环形链表 II</a></h2><p>哈希表是直观的思路，时间&#x2F;空间复杂度是O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pos</span> <span class="operator">=</span> head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;<span class="comment">//环的入口就是第一个重复的节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pos = head</span><br><span class="line">        visited = <span class="built_in">set</span>()  <span class="comment"># 使用 Python 的 set 来存储访问过的节点</span></span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            <span class="keyword">if</span> pos <span class="keyword">in</span> visited:  <span class="comment"># 如果节点已经存在于 set 中，说明是环的入口</span></span><br><span class="line">                <span class="keyword">return</span> pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.add(pos)  <span class="comment"># 将当前节点添加到 set 中</span></span><br><span class="line">            pos = pos.<span class="built_in">next</span>  <span class="comment"># 移动到下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 如果没有环，返回 None</span></span><br></pre></td></tr></table></figure>

<p>进阶：用空间O(1)实现，Floyd判圈算法</p>
<ul>
<li><p>判断链表是否环：可以使用<strong>快慢指针法</strong>，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p>
</li>
<li><p>如果有环，如何找到这个环的入口：首先可以证明<strong>第一次在环中相遇，slow的 步数 是 x+y 而不是 x + 若干环的长度 + y</strong> ，然后相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，可以得到x &#x3D; n (y + z) - y。</p>
</li>
<li><p>从头结点出发一个指针ptr，从相遇节点也出发一个指针slow，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点。如果n&#x3D;1，则slow没有在环中走多余的路，如果n&gt;1，则相遇前会在环中转n-1圈，但最后会和ptr在入口相遇。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;<span class="comment">//在环中相遇</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                ptr = head</span><br><span class="line">                <span class="keyword">while</span> ptr != slow:</span><br><span class="line">                    ptr = ptr.<span class="built_in">next</span></span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> ptr</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-9-总结篇"><a href="#2-9-总结篇" class="headerlink" title="2.9 总结篇"></a>2.9 总结篇</h2><p>统一使用虚拟头节点dummy<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" alt="img"></p>
<h1 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3. 哈希表"></a>3. 哈希表</h1><h2 id="3-1-哈希表理论基础"><a href="#3-1-哈希表理论基础" class="headerlink" title="3.1 哈希表理论基础"></a>3.1 哈希表理论基础</h2><p>哈希表是根据关键码的值而直接进行访问的数据结构，用来快速判断一个元素是否出现集合里。</p>
<p>哈希函数：通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt="哈希表2" style="zoom:50%;" />

<p>哈希碰撞：小李和小王都映射到了索引下标 1 的位置</p>
<ul>
<li>拉链法：发生冲突的元素都被存储在链表中。需要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png" alt="哈希表4" style="zoom:33%;" /></li>
<li>线性探测法：一定要保证tableSize大于dataSize，因为需要依靠哈希表中的空位来解决碰撞问题。如向下找一个空位。<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png" alt="哈希表5" style="zoom:33%;" /></li>
</ul>
<p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map（映射）</li>
</ul>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>
<p>虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。</p>
<p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p>
<p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235134572.png" alt="哈希表6" style="zoom:50%;" />

<blockquote>
<p>以下是我的补充：</p>
<p>Java：红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>哈希表 + 链表</td>
<td>有序（插入顺序）</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>TreeSet</td>
<td>红黑树</td>
<td>有序（自然顺序或自定义顺序）</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">映射</th>
<th align="left">底层实现</th>
<th align="left">是否有序</th>
<th align="left">key是否可以重复</th>
<th align="left">能否更改key</th>
<th align="left">查询效率</th>
<th align="left">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HashMap</td>
<td align="left">哈希表</td>
<td align="left">无序</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">LinkedHashMap</td>
<td align="left">哈希表 + 链表</td>
<td align="left">有序（插入顺序或访问顺序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">TreeMap</td>
<td align="left">红黑树</td>
<td align="left">有序（自然顺序或自定义顺序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(log n)</td>
<td align="left">O(log n)</td>
</tr>
</tbody></table>
<p>Python：</p>
<table>
<thead>
<tr>
<th align="left">集合</th>
<th align="left">底层实现</th>
<th align="left">是否有序</th>
<th align="left">数值是否可以重复</th>
<th align="left">能否更改数值</th>
<th align="left">查询效率</th>
<th align="left">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="left">set</td>
<td align="left">哈希表</td>
<td align="left">无序</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">frozenset</td>
<td align="left">哈希表</td>
<td align="left">无序</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">不可变</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">映射</th>
<th align="left">底层实现</th>
<th align="left">是否有序</th>
<th align="left">key是否可以重复</th>
<th align="left">能否更改key</th>
<th align="left">查询效率</th>
<th align="left">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dict</td>
<td align="left">哈希表</td>
<td align="left">无序（Python 3.7+ 有序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">OrderedDict</td>
<td align="left">哈希表 + 双向链表</td>
<td align="left">有序（插入顺序）</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">O(1)</td>
<td align="left">O(1)</td>
</tr>
</tbody></table>
<p>当我们要使用集合来解决哈希问题的时候，优先使用HashSet，因为它的查询和增删效率是最优的。基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。</p>
</blockquote>
<p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<h2 id="3-2-有效的字母异位词"><a href="#3-2-有效的字母异位词" class="headerlink" title="3.2 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">3.2 有效的字母异位词</a></h2><p>排序法时间复杂度<em>O</em>(<em>n</em>log<em>n</em>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] str2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(str1);</span><br><span class="line">        Arrays.sort(str2);</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(s) == <span class="built_in">sorted</span>(t)</span><br></pre></td></tr></table></figure>

<p><strong>数组其实就是一个简单哈希表</strong>，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p>
<p>定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。对一个字符串统计+1，对另一个字符串-1，最后看是否有元素不为0，有则不是字母异位词。时间复杂度: O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;<span class="comment">//先看边界情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**for (int count: record) &#123; 可以写作访问数组内容int的格式</span></span><br><span class="line"><span class="comment">            if (count != 0) &#123;               </span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;**/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):  <span class="comment"># 先看边界情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span>  <span class="comment"># 初始化一个长度为26的列表，对应英文字母的数量</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            record[<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span>  <span class="comment"># 计算s中每个字符的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> t:</span><br><span class="line">            record[<span class="built_in">ord</span>(char) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span>  <span class="comment"># 减去t中每个字符的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> count <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">if</span> count != <span class="number">0</span>:  <span class="comment"># 如果record数组中有非零元素，则表示s和t不是字母异位词</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>另外python的Counter和defaultdict也可以解题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> Counter(s) == Counter(t)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s_dict = defaultdict(<span class="built_in">int</span>)<span class="comment">#表示对于任何未见过的键，其初始值都会被设置为 0</span></span><br><span class="line">        t_dict = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            s_dict[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">            t_dict[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s_dict == t_dict</span><br></pre></td></tr></table></figure>

<h2 id="3-3-两个数组的交集"><a href="#3-3-两个数组的交集" class="headerlink" title="3.3 两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">3.3 两个数组的交集</a></h2><p>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序。</p>
<p>使用数组来做哈希的题目，是因为题目都限制了数值的大小，如上一题只需要26位记录次数，但这里没有限制大小，哈希值可能比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。此处就适合使用集合。</p>
<ul>
<li>那为什么有时哈希问题要用数组？直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。不要小瞧这个耗时，在数据量大的情况，差距是很明显的。</li>
<li>后来此题限制了大小在1000以内，也可以用数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//这里用set是因为不确定长度，同时避免重复，list不能避免重复</span></span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将set转为int[]</span></span><br><span class="line">        <span class="comment">//法1：将流中的每个Integer对象映射到其对应的int值</span></span><br><span class="line">        <span class="keyword">return</span> resSet.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">        <span class="comment">/**法2：另外构造一个int[]数组，比较符合记不住简单方法时候的用法</span></span><br><span class="line"><span class="comment">        int[] arr = new int[resSet.size()];</span></span><br><span class="line"><span class="comment">        int j = 0;</span></span><br><span class="line"><span class="comment">        for(int i : resSet)&#123;</span></span><br><span class="line"><span class="comment">            arr[j++] = i;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return arr;</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>(nums1) &amp; <span class="built_in">set</span>(nums2))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        st = <span class="built_in">set</span>(nums1)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> st:</span><br><span class="line">                st.remove(x)<span class="comment">#保证nums2的重复数字不会添加到ans，相当于保证ans是set，对nums2也做了set</span></span><br><span class="line">                ans.append(x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="3-4-快乐数"><a href="#3-4-快乐数" class="headerlink" title="3.4 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">3.4 快乐数</a></h2><p>注意无限循环：如果sum重复出现了，就不可能是快乐数，sum达到1了。所以需要用set存储出现过的sum值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; record = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//保存出现过的sum值</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !record.contains(n))&#123;</span><br><span class="line">            record.add(n);<span class="comment">//注意最开始的数字就应该加入进去了</span></span><br><span class="line">            n = getNextNum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;<span class="comment">//如果无限循环也会来到这里，但不满足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//对每一位求平方和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += Math.pow(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        record = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record.add(n)</span><br><span class="line">            n_str = <span class="built_in">str</span>(n)</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> n_str:</span><br><span class="line">                <span class="built_in">sum</span> += <span class="built_in">int</span>(i)**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == <span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-两数之和"><a href="#3-5-两数之和" class="headerlink" title="3.5 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">3.5 两数之和</a></h2><p>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</p>
<p>本题我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，<strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p>
<p>再来看一下使用数组和set来做哈希法的局限。</p>
<ul>
<li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li>
<li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的<strong>下标位置</strong>，因为要返回x 和 y的下标。所以set 也不能用。</li>
</ul>
<p>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一" style="zoom:50%;" />

<ul>
<li>因为只允许两数之和，所以可以随时作差</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;<span class="comment">//先看边界情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//注意里面写Integer而不是int，因为int不是类</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(tmp);<span class="comment">//返回tmp对应的下标</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);<span class="comment">//注意key是数组的值，value是数组的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = <span class="built_in">dict</span>() <span class="comment">#python中map就是dict</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  </span><br><span class="line">            <span class="keyword">if</span> target - value <span class="keyword">in</span> record:<span class="comment">#寻找匹配的key</span></span><br><span class="line">                <span class="keyword">return</span> [index, record[target - value]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                record[value] = index <span class="comment">#key不重复</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h2 id="3-6-四数相加-II"><a href="#3-6-四数相加-II" class="headerlink" title="3.6 四数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">3.6 四数相加 II</a></h2><p>参考前文的两数之和，建立map，先记录A+B数组的元素之和和出现次数，然后遍历C+D，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</p>
<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j: nums2)&#123;</span><br><span class="line">                map.put(i + j, map.getOrDefault(i + j, <span class="number">0</span>) + <span class="number">1</span>);<span class="comment">//如果找不到key，就返回设置的默认值0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j: nums4)&#123;</span><br><span class="line">                count += map.getOrDefault(- i - j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], nums3: <span class="type">List</span>[<span class="built_in">int</span>], nums4: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">map</span> = <span class="built_in">dict</span>()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="built_in">map</span>[i + j] = <span class="built_in">map</span>.get(i + j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums3:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums4:</span><br><span class="line">                count += <span class="built_in">map</span>.get( - i - j, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h2 id="3-7-赎金信"><a href="#3-7-赎金信" class="headerlink" title="3.7 赎金信"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">3.7 赎金信</a></h2><p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个<strong>长度为26的数组</strong>来记录magazine里字母出现的次数。然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p>
<p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">//ransomNote中的每个字符在magazine中都出现过</span></span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++)&#123;</span><br><span class="line">            record[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++)&#123;</span><br><span class="line">            record[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        record = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> magazine:</span><br><span class="line">            record[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> ransomNote:</span><br><span class="line">            record[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> record:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#Counter对字符串的每个字符计数，结果为空则为True</span></span><br><span class="line">        <span class="comment">#return (Counter(ransomNote) - Counter(magazine)) == &#123;&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (Counter(ransomNote) - Counter(magazine))</span><br></pre></td></tr></table></figure>

<h2 id="3-8-三数之和"><a href="#3-8-三数之和" class="headerlink" title="3.8 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">3.8 三数之和</a></h2><p>两层for循环就可以确定 两个数值，可以使用哈希法来确定 第三个数 0-(a+b) 或者 0 - (a + c) 是否在 数组里出现过，其实这个思路是正确的，但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组。</p>
<ul>
<li>哈希法用set存b，a是nums[i]，c是nums[k](另一层循环，k&#x3D;i+1…n)，过程中要不断对a和c去重，比较繁琐</li>
<li>时间复杂度: O(n^2)，第二层循环有时作c有时作b，总之有点难理解，用双指针！</li>
</ul>
<p>而排序可以去除重复解。拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。<img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p>
<p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。</p>
<ul>
<li>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</li>
<li>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。时间复杂度：O(n^2)。</li>
</ul>
<p>去重逻辑的思考</p>
<ol>
<li>a的去重：不是与nums[i + 1]比较，而是与nums[i - 1]比较，因为不能有重复的三元组，但三元组内的元素是可以重复的</li>
<li>b与c的去重：在三数之和非0时，无需去重bc，因为下一个循环也会校验。等于0时要校验是否重复。</li>
</ol>
<p>两数之和 就不能使用双指针法，因为<a target="_blank" rel="noopener" href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html">1.两数之和 (opens new window)</a>要求返回的是索引下标， 而<strong>双指针法一定要排序</strong>，一旦排序之后原数组的索引就被改变了（要求返回的是数值的话，就可以使用双指针法了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//排序，令左指针 L=i+1，右指针 R=n−1</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// a=nums[i], b=nums[left], c=nums[right]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//如果最小的a已然大于0，不可能和为0</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//对a去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;<span class="comment">//定义双指针</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left)&#123;<span class="comment">//在找以a为基础的这一轮循环</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="comment">//此时要去重，直到b和c是新的数字</span></span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    right--;<span class="comment">//注意跳出循环后仍要移动，不然停在重复值上</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                sum_ = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="3-9-四数之和"><a href="#3-9-四数之和" class="headerlink" title="3.9 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">3.9 四数之和</a></h2><p>三数之和：一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] &#x3D;&#x3D; 0。</p>
<p>四数之和：两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。</p>
<ul>
<li>对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和 (opens new window)</a>双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;<span class="comment">//枚举a=nums[i]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; target)&#123;<span class="comment">// 剪枝处理</span></span><br><span class="line">                <span class="keyword">return</span> res;<span class="comment">//列举可以发现相加只会越来越大</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;<span class="comment">//在i-1时已经覆盖了所有情况</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++)&#123;<span class="comment">//枚举b=nums[j]</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] &gt;= <span class="number">0</span> &amp;&amp; nums[i] + nums[j] &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//注意这里不应该return res，不像外层循环一样杜绝了可能的结果</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">//遇到重复值要过</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort() <span class="comment">#先排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] + nums[j] &gt; target:</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">#注意这里不能直接返回</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                left = j + <span class="number">1</span></span><br><span class="line">                right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    sum_ = nums[i] + nums[j] + nums[left] + nums[right]<span class="comment">#和求和函数作区分</span></span><br><span class="line">                    <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="3-10-总结篇"><a href="#3-10-总结篇" class="headerlink" title="3.10 总结篇"></a>3.10 总结篇</h2><p>要求只有小写字母时，很合适用数组，因为空间消耗固定</p>
<p>没有限制数值大小时，用set做映射</p>
<p>当需要记录下标时，用map，因为是<code>&lt;key, value&gt;</code>结构（虽然map是万能的，但数组和set当然效率更高）</p>
<ul>
<li>std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），并不需要key有序时选择std::unordered_map 效率更高</li>
</ul>
<h1 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h1><h2 id="4-1-反转字符串"><a href="#4-1-反转字符串" class="headerlink" title="4.1 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">4.1 反转字符串</a></h2><p>对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p>
<p>swap可以有两种实现。</p>
<p>一种就是常见的交换数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> s[i];</span><br><span class="line">s[i] = s[j];</span><br><span class="line">s[j] = tmp;</span><br></pre></td></tr></table></figure>

<p>一种就是通过位运算：01，则结果为1；11&#x2F;00，则结果为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s[i] ^= s[j];<span class="comment">//i=i^j</span></span><br><span class="line">s[j] ^= s[i];<span class="comment">//j=j^(i^j)=i 自己和自己异或是0</span></span><br><span class="line">s[i] ^= s[j];<span class="comment">//i=(i^j)^i=j</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="comment">//原地修改数组，就是用一个tmp存，然后把最先和最后进行交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]<span class="comment">#在内存中会使用一个临时的元组来保存中间状态</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="4-2-反转字符串-II"><a href="#4-2-反转字符串-II" class="headerlink" title="4.2 反转字符串 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">4.2 反转字符串 II</a></h2><p>在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<p>我独立完成的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_substring</span>(<span class="params">self, s:<span class="built_in">str</span>, i:<span class="built_in">int</span>, j:<span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:<span class="comment">#反转[i,j)</span></span><br><span class="line">        before = s[:i]</span><br><span class="line">        reversed_part = s[i:j][::-<span class="number">1</span>]</span><br><span class="line">        after = s[j:]</span><br><span class="line">        <span class="keyword">return</span> before + reversed_part + after</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s) // (<span class="number">2</span> * k)</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:<span class="comment">#反转n次前k个字符</span></span><br><span class="line">            index = (n - <span class="number">1</span>)*<span class="number">2</span>*k</span><br><span class="line">            s = <span class="variable language_">self</span>.reverse_substring(s, index, index + k)</span><br><span class="line">            <span class="comment">#s[index, index + k] = s[index, index + k][::-1]这样直接修改是错的，元组不能作为索引</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(s) // (<span class="number">2</span> * k)</span><br><span class="line">        last = <span class="built_in">len</span>(s) - n*<span class="number">2</span>*k <span class="comment">#7-1*2*2=3</span></span><br><span class="line">        <span class="keyword">if</span> last &gt; <span class="number">0</span> <span class="keyword">and</span> last &lt; k:</span><br><span class="line">            s = <span class="variable language_">self</span>.reverse_substring(s, n*<span class="number">2</span>*k, <span class="built_in">len</span>(s))</span><br><span class="line">        <span class="keyword">elif</span> last &gt;= k <span class="keyword">and</span> last &lt; <span class="number">2</span>*k:</span><br><span class="line">            s = <span class="variable language_">self</span>.reverse_substring(s, n*<span class="number">2</span>*k, n*<span class="number">2</span>*k + k)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p>改善版：其实每次看2k个，反转前k个就行，最后剩余字符的两种情况也符合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            p2 = p + k</span><br><span class="line">            s = s[:p] + s[p: p2][::-<span class="number">1</span>] + s[p2:]</span><br><span class="line">            p = p + <span class="number">2</span> * k</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h2 id="4-3-替换数字"><a href="#4-3-替换数字" class="headerlink" title="4.3 替换数字"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1064">4.3 替换数字</a></h2><p>申请新数组的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数字替换为number</span></span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> char.isdigit():</span><br><span class="line">        result += <span class="string">&quot;number&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += char</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>正则表达式的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(sc.next().replaceAll(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;number&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想把这道题目做到极致，就不要只用额外的辅助空间了！ （不过使用Java刷题的录友，一定要使用辅助空间，因为Java里的string不能修改）</p>
<p>注意<strong>从后往前</strong>填充：从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。</p>
<p>很多数组填充类的问题，其做法都是先预先给数组扩容到填充后的大小，然后在从后向前进行操作。这么做有两个好处：</p>
<ol>
<li>不用申请新数组。</li>
<li>从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。</li>
</ol>
<h2 id="4-4-反转字符串中的单词"><a href="#4-4-反转字符串中的单词" class="headerlink" title="4.4 反转字符串中的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">4.4 反转字符串中的单词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        s_list = s.split()</span><br><span class="line">        reversed_list = s_list[::-<span class="number">1</span>]<span class="comment">#反转列表而不是反转字符串</span></span><br><span class="line">        res = <span class="string">&quot; &quot;</span>.join(reversed_list)<span class="comment"># 使用单个空格将反转后的单词列表拼接成字符串</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 使用 split() 方法按任意连续空白字符分割字符串，注意不要写split(&quot; &quot;)，否则结果是[&#x27;a&#x27;, &#x27;good&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;example&#x27;]</span></span><br><span class="line">        s_list = s.split()</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> index, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(s_list):</span><br><span class="line">            res = word + <span class="string">&quot; &quot;</span> + res</span><br><span class="line">        <span class="keyword">return</span> res.strip() <span class="comment">#去除字符串首尾的空白字符</span></span><br></pre></td></tr></table></figure>

<p>不要使用辅助空间，空间复杂度要求为O(1)。所以解题思路如下：</p>
<ul>
<li><p>移除多余空格：包括前后的空格，中间的连续空格。要保持O(n)的话，用“1.3移除元素”的快慢指针法</p>
<ul>
<li>C++的话可以在string上原地修改，但Java的String不能修改（使用<code>final char[]</code>数组来存储字符），所以要使用<code>StringBuilder</code>或<code>char[]</code>数组作为辅助空间</li>
</ul>
</li>
<li><p>将整个字符串反转：参考4.1，用双指针+一个额外空间进行交换</p>
</li>
<li><p>将每个单词反转：等价于反转字符串</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用Java内置方法实现</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 1.去除首尾以及中间多余空格</span></span><br><span class="line"><span class="comment">     * 2.反转整个字符串</span></span><br><span class="line"><span class="comment">     * 3.反转各个单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder <span class="title function_">removeSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;<span class="comment">//去除前后的空格</span></span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;<span class="comment">//去除中间的连续空格，加入sb</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串指定区间[start, end]的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;<span class="comment">//双指针</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);<span class="comment">//用一个额外空间暂存</span></span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;<span class="comment">//主要是识别单词</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-右旋字符串"><a href="#4-5-右旋字符串" class="headerlink" title="4.5 右旋字符串"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1065">4.5 右旋字符串</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">input</span>()</span><br><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">index = <span class="built_in">len</span>(s) - <span class="built_in">int</span>(k)</span><br><span class="line">res = s[index:] + s[:index]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>通过 整体倒叙，把两段子串顺序颠倒，两个段子串里的的字符在倒叙一把，<strong>负负得正</strong>，这样就不影响子串里面字符的顺序了。</p>
<p>这样额外空间只有交换时的O(1)，左反转和右反转的思路一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(in.nextLine());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();  <span class="comment">//获取字符串长度</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();<span class="comment">//转成数组的原因是Java字符串无法修改，但数组可以修改</span></span><br><span class="line">        reverseString(chars, <span class="number">0</span>, len - <span class="number">1</span>);  <span class="comment">//反转整个字符串</span></span><br><span class="line">        reverseString(chars, <span class="number">0</span>, n - <span class="number">1</span>);  <span class="comment">//反转前一段字符串，此时的字符串首尾尾是0,n - 1</span></span><br><span class="line">        reverseString(chars, n, len - <span class="number">1</span>);  <span class="comment">//反转后一段字符串，此时的字符串首尾尾是n,len - 1</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;<span class="comment">//只用一个额外空间</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            ch[start] ^= ch[end];</span><br><span class="line">            ch[end] ^= ch[start];</span><br><span class="line">            ch[start] ^= ch[end];</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-找出字符串中第一个匹配项的下标"><a href="#4-6-找出字符串中第一个匹配项的下标" class="headerlink" title="4.6 找出字符串中第一个匹配项的下标"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">4.6 找出字符串中第一个匹配项的下标</a></h2><p>“mississippi”注意这种用例，不能一直前移haystack，朴素做法：<em>O</em>(<em>m</em>∗<em>n</em>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(haystack) &lt; <span class="built_in">len</span>(needle):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(haystack) - <span class="built_in">len</span>(needle) + <span class="number">1</span>):<span class="comment">#记得要写range，刚开始没注意</span></span><br><span class="line">            <span class="keyword">if</span> haystack[i: i+<span class="built_in">len</span>(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>KMP算法：<em>O</em>(<em>m</em>+<em>n</em>) 应用于匹配DNA片段、文本搜索</p>
<p>详见本人博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53632564/article/details/145783773?spm=1001.2014.3001.5502">超简单理解KMP算法（最长公共前后缀next数组、合并主子串、子串偏移法）-CSDN博客</a></p>
<p>获得next数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">       		len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">			<span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>合并主串子串的方法：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502212242572.png" alt="image-20250221224217526"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(haystack) <span class="comment">#主串的的长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(needle) <span class="comment">#子串的长度</span></span><br><span class="line">        <span class="keyword">if</span> haystack == needle: <span class="comment">#因为i从1开始，所以处理edge case</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s = needle + <span class="string">&quot;#&quot;</span> + haystack <span class="comment">#注意把子串放前面，这样前缀和才能覆盖子串</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + m + <span class="number">1</span>): <span class="comment">#注意+1是因为&quot;#&quot;多了一位</span></span><br><span class="line">            len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">                len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">                <span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span>[i] == m:<span class="comment">#返回第一个</span></span><br><span class="line">                    <span class="keyword">return</span> i - m*<span class="number">2</span> <span class="comment">#合并串从第m+1位开始才是主串，所以主串中开始匹配的下标是i - (m+1) - m + 1=i-2*m</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>子串偏移的做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">                len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">                <span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(needle)</span><br><span class="line">        <span class="variable language_">self</span>.getNext(<span class="built_in">next</span>, needle)</span><br><span class="line">        i = <span class="number">0</span> <span class="comment">#主串指针</span></span><br><span class="line">        j = <span class="number">0</span> <span class="comment">#子串指针</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:<span class="comment">#不匹配，子串到下一个可能匹配的地方next[j-1]，注意只要j&gt;0要一直找，而不是只试一次</span></span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:<span class="comment">#字符匹配，指针后移</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):<span class="comment">#在主串中找到了子串</span></span><br><span class="line">                <span class="keyword">return</span> i - <span class="built_in">len</span>(needle) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-7-重复的子字符串"><a href="#4-7-重复的子字符串" class="headerlink" title="4.7 重复的子字符串"></a>4.7 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></h2><p>暴力法：用一个for循环获取子串的终止位置（起始位置肯定是第一个字母，不然不可能重复多次构成，同时这里可以优化：子串至少重复一次，所以终止位置遍历到n&#x2F;2的中间位置即可），再用一个循环判断子串是否能重复构成字符串。<em>O</em>(n^2)</p>
<p><strong>移动匹配</strong>法：如果将两个<em>s</em>连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含<em>s</em>，即<em>s</em>是它的一个子串</p>
<ul>
<li>这种方法只能判断有没有，不能立马得到子串是什么，仅用于此题返回true&#x2F;false的情况</li>
<li>我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数， 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。也就是4.6中的KMP。</li>
<li>这里构造 <code>s + s</code> 的时间复杂度是 <em>O</em>(<em>n</em>)，在 <code>s + s</code> 中查找 <code>s</code> 的时间复杂度也是 <em>O</em>(<em>n</em>)。所以总的也是<em>O</em>(<em>n</em>)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>

<p>KMP法：</p>
<p>充分条件：如果字符串s是由重复子串组成，那么 最长相等前后缀不包含的子串 一定是 s的最小重复子串。</p>
<p>必要条件：如果字符串s的最长相等前后缀不包含的子串 是 s最小重复子串，那么 s是由重复子串组成。</p>
<p>当 最长相等前后缀不包含的子串的<strong>长度</strong> 可以被 字符串s的长度整除，那么不包含的子串 就是s的最小重复子串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):<span class="comment">#不减一</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            len_ = <span class="built_in">next</span>[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> len_ != <span class="number">0</span> <span class="keyword">and</span> s[i] != s[len_]: <span class="comment">#等于0也是没有，会跳过的</span></span><br><span class="line">                len_ = <span class="built_in">next</span>[len_ - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[len_]: <span class="comment">#跳出循环要不是0要不相等</span></span><br><span class="line">                <span class="built_in">next</span>[i] = len_ + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="variable language_">self</span>.getNext(<span class="built_in">next</span>, s) <span class="comment">#最长相等前后缀在该题中就是next[-1]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">next</span>[-<span class="number">1</span>] != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(s) % (<span class="built_in">len</span>(s) - <span class="built_in">next</span>[-<span class="number">1</span>]) == <span class="number">0</span>:<span class="comment">#可以被整除那不包含的子串就是重复子串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="4-8-总结篇"><a href="#4-8-总结篇" class="headerlink" title="4.8 总结篇"></a>4.8 总结篇</h2><p>建议不使用库函数</p>
<p>很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在<strong>从后向前</strong>进行操作。</p>
<p>双指针法是字符串处理的常客。</p>
<h1 id="5-双指针法"><a href="#5-双指针法" class="headerlink" title="5. 双指针法"></a>5. 双指针法</h1><h2 id="5-11-总结篇"><a href="#5-11-总结篇" class="headerlink" title="5.11 总结篇"></a>5.11 总结篇</h2><p>双指针不能同时存下标和数值</p>
<p>双指针有时是快慢（一个走2，一个走1），有时是从两头向中间逼近，有时是从后往前。虽然惯性思维经常是从前往后</p>
<p>除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将O(n^2)的时间复杂度，降为 $O(n)$</p>
<h1 id="6-栈与队列"><a href="#6-栈与队列" class="headerlink" title="6. 栈与队列"></a>6. 栈与队列</h1><h2 id="6-1-理论基础"><a href="#6-1-理论基础" class="headerlink" title="6.1 理论基础"></a>6.1 理论基础</h2><p>栈：先进后出</p>
<p>队列：先进先出</p>
<h2 id="6-2-用栈实现队列"><a href="#6-2-用栈实现队列" class="headerlink" title="6.2 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">6.2 用栈实现队列</a></h2><p>一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        in主要负责push，out主要负责pop</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_in = []</span><br><span class="line">        <span class="variable language_">self</span>.stack_out = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        有新元素进来，就往in里面push</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_in.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack_out:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#[10,20,30]就以30 20 10的顺序导入 这样是先进后出</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.stack_in)):</span><br><span class="line">                <span class="variable language_">self</span>.stack_out.append(<span class="variable language_">self</span>.stack_in.pop())</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()<span class="comment">#这里又会以10 20 30的顺序pop，两次先进后出实现队列的先进先出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="variable language_">self</span>.pop()<span class="comment">#复用了上面的方法，已经移除了不妨加入out</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        只要in或者out有元素，说明队列不为空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (<span class="variable language_">self</span>.stack_in <span class="keyword">or</span> <span class="variable language_">self</span>.stack_out)</span><br></pre></td></tr></table></figure>

<p>需要两个栈<strong>一个输入栈，一个输出栈</strong>，在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p>
<h2 id="6-3-用队列实现栈"><a href="#6-3-用队列实现栈" class="headerlink" title="6.3 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">6.3 用队列实现栈</a></h2><p>两个队列：新来的数字入2，然后把1中的数字加入，最后返回1中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.q1 = deque()</span><br><span class="line">        <span class="variable language_">self</span>.q2 = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.q2.append(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.q1:</span><br><span class="line">            <span class="variable language_">self</span>.q2.append(<span class="variable language_">self</span>.q1.popleft())</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.q2:</span><br><span class="line">            <span class="variable language_">self</span>.q1.append(<span class="variable language_">self</span>.q2.popleft())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:<span class="comment">#这里和top都m</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.q1.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.q1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.q1</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>

<p>一个队列：模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。O(n)</p>
<h2 id="6-4-有效的括号"><a href="#6-4-有效的括号" class="headerlink" title="6.4 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">6.4 有效的括号</a></h2><p>linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd a/b/c/../../</span><br></pre></td></tr></table></figure>

<p>这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用（..退，就是后面的目录级要出栈）</p>
<p>判断右括号的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;]&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;&#125;&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> st <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>碰到左括号，就把相应的右括号入栈，然后右括号来时对比是否一样即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二，使用字典</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        mapping = &#123;<span class="comment">#keys/[] 学习字典的用法</span></span><br><span class="line">            <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> item <span class="keyword">in</span> mapping.keys():</span><br><span class="line">                stack.append(mapping[item])</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != item: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="6-5-删除字符串中的所有相邻重复项"><a href="#6-5-删除字符串中的所有相邻重复项" class="headerlink" title="6.5 删除字符串中的所有相邻重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">6.5 删除字符串中的所有相邻重复项</a></h2><p>这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。</p>
<p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。无限递归会引发调用栈溢出<code>Segmentation fault</code></p>
<p>而且<strong>在企业项目开发中，尽量不要使用递归</strong>！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p>
<p>如果不让用栈可以用双指针模拟</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> st <span class="keyword">and</span> c == st[-<span class="number">1</span>]:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(c)</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> st:<span class="comment">#这里简单的写法是&quot;&quot;.join(res) 数组转字符串</span></span><br><span class="line">            res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="6-6-逆波兰表达式求值"><a href="#6-6-逆波兰表达式求值" class="headerlink" title="6.6 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">6.6 逆波兰表达式求值</a></h2><p>栈与递归之间在某种程度上是可以转换的！逆波兰表达式相当于是二叉树中的后序遍历。<strong>后缀表达式RPN对计算机来说是非常友好的</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        st = []</span><br><span class="line">        sign = [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> sign:</span><br><span class="line">                num1 = st.pop()</span><br><span class="line">                num2 = st.pop()</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    num = num1 + num2</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    num = num2 - num1</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    num = num1 * num2</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    num = num2 / num1<span class="comment">#注意向零截断，所以要用/+int，而不能用//</span></span><br><span class="line">                st.append(<span class="built_in">int</span>(num))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(<span class="built_in">int</span>(c))</span><br><span class="line">        <span class="keyword">return</span> st[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>可以学习下面这种调用函数的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, sub, mul</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="comment"># 使用整数除法的向零取整方式 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(x / y)<span class="comment">#答案是下面，但这样写也过了，感觉已经满足向0截断了</span></span><br><span class="line">    <span class="comment">#return int(x / y) if x * y &gt; 0 else -(abs(x) // abs(y))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    op_map = &#123;<span class="string">&#x27;+&#x27;</span>: add, <span class="string">&#x27;-&#x27;</span>: sub, <span class="string">&#x27;*&#x27;</span>: mul, <span class="string">&#x27;/&#x27;</span>: div&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(token))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                op2 = stack.pop()</span><br><span class="line">                op1 = stack.pop()</span><br><span class="line">                stack.append(<span class="variable language_">self</span>.op_map[token](op1, op2))  <span class="comment"># 第一个出来的在运算符后面</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>

<h2 id="6-7-滑动窗口最大值"><a href="#6-7-滑动窗口最大值" class="headerlink" title="6.7 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">6.7 滑动窗口最大值</a></h2><p>不能每k个数都调用一次max，会超时（如k&#x3D;5000）</p>
<p>每次出一个数，来一个数，和max比较，也会超时</p>
<p>后来我的思路是不需要维护滑动窗口中的每个数，只要维护第一大和第二大即可，这样如果最大数离开了，比较新来的数和第二大数即可 </p>
<ul>
<li>我本来觉得维护第一大和第二大简单，看答案后发现复杂度是一样的，不是非要死板地保证队列长度为2，不出界就行</li>
<li>标答的while和每次都加入巧妙地保证了队列一定单调，且无需重新计算也知道目前窗口里的最值（如果q长度为1就是1，不然长度为3就是top3）</li>
</ul>
<p>也就是单调队列维护队列递减，不断把新的数与队尾元素比较即可</p>
<p>存下标非常巧妙，因为和滑动窗口的位置息息相关！！这样窗口变更后才知道现有队列中的最值是否出去了，while保证队列里的每个值都被判断，留下来的都是还在滑动窗口里的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = deque()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 移除不在窗口内的队首元素 保证q中的每个下标都没有超越窗口的左边界</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt; i - k + <span class="number">1</span>:</span><br><span class="line">                q.popleft()</span><br><span class="line">            <span class="comment"># 维护队列递减性质 如果当前元素大于队尾元素 则队尾元素出队 有可能把队列全清空</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)<span class="comment">#我不懂为啥当前的数字非得存进去，只和队尾比较一次不好吗（仔细想和维护top1/2的复杂性是一样的，这样写单调性更简单灵活，不是说非要有2个数）</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:<span class="comment">#其实除了最开始窗口小于k，后面每次都会有一个最大值</span></span><br><span class="line">                result.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="6-8-前-K-个高频元素"><a href="#6-8-前-K-个高频元素" class="headerlink" title="6.8 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">6.8 前 K 个高频元素</a></h2><p>优先级队列：披着队列外衣的堆，看起来就是队列，但内部元素是自动依照元素的权值排列</p>
<p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，大顶堆就是节点的值不小于左右孩子的值</p>
<p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p>
<ul>
<li>维护k个有序的序列即可</li>
<li>要用小顶堆，这样每次更新时把最小的元素弹出，留下来的就是前k个最大元素；用大顶堆，每次更新会把最大的元素弹出去，不符合逻辑</li>
</ul>
<p>所以本题先计算频率，然后把频率放入大小为k的小顶堆中，最后留下的就是前k大的高频元素（对于我的重点是小顶堆怎么建？）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="comment"># 统计每个数字出现的频率</span></span><br><span class="line">    count = Counter(nums)<span class="comment">#Counter(&#123;1: 3, 2: 2, 3: 1&#125;)，key是值，value是频率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># heapq.nsmallest用于从可迭代对象中获取最小的k个元素，而题目是最高频的，x[1]是频率，所以-x[1]让频率反向</span></span><br><span class="line">    <span class="keyword">return</span> [item <span class="keyword">for</span> item, freq <span class="keyword">in</span> heapq.nsmallest(k, count.items(), key=<span class="keyword">lambda</span> x: (-x[<span class="number">1</span>]))]</span><br></pre></td></tr></table></figure>

<p>注意调用heapq库很方便：排序过程的时间复杂度是 O(log k) ，整个算法的时间复杂度是 O(nlog k)。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        map_ = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            map_[num] = map_.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heap = []  <span class="comment">#从小到大排前k高的元素</span></span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> map_.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k:</span><br><span class="line">                heapq.heappush(heap, (freq, num))</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#比较当前值和堆顶的频率最小值哪个大</span></span><br><span class="line">                <span class="keyword">if</span> freq &gt; heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappushpop(heap, (freq, num))</span><br><span class="line">        <span class="comment">#另一种写法是先加入，让其排序，然后超过k了再弹出最小值</span></span><br><span class="line">        <span class="comment">#for key, freq in map_.items():</span></span><br><span class="line">        <span class="comment">#    heapq.heappush(heap, (freq, key))</span></span><br><span class="line">        <span class="comment">#    if len(heap) &gt; k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">        <span class="comment">#        heapq.heappop(heap)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            res.append(heapq.heappop(heap)[<span class="number">1</span>])<span class="comment">#注意加入的是值不是频率</span></span><br><span class="line">        <span class="comment">#另一种写法是利用range可以倒序遍历索引</span></span><br><span class="line">        <span class="comment">#res = [0] * k</span></span><br><span class="line">        <span class="comment">#for i in range(k-1, -1, -1):#起点是k-1，终点是0（左闭右开所以写-1），步长-1实现倒序遍历</span></span><br><span class="line">        <span class="comment">#    res[i] = heapq.heappop(heap)[1]</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="6-9-总结篇"><a href="#6-9-总结篇" class="headerlink" title="6.9 总结篇"></a>6.9 总结篇</h2><p>栈里面的元素在内存中是连续分布的么？这个问题有两个陷阱：</p>
<ul>
<li>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。（python用list实现栈时是连续的）</li>
<li>陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。</li>
</ul>
<p><strong>递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<h1 id="7-二叉树"><a href="#7-二叉树" class="headerlink" title="7. 二叉树"></a>7. 二叉树</h1><h2 id="7-1-理论基础"><a href="#7-1-理论基础" class="headerlink" title="7.1 理论基础"></a>7.1 理论基础</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>满二叉树：所以排序的过程的时间复杂度是 $O(\log k)$ ，整个算法的时间复杂度是 $O(n\log k)$ 。深度为k，有2^k-1个节点</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111555701.png" alt="img" style="zoom:33%;" />

<p>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。<strong>堆就是一个完全二叉树。</strong><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111600136.png" alt="img" style="zoom: 33%;" /></p>
<p>二叉搜索树：有数值，有序。下面这两棵树都是搜索树</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111603310.png" alt="img" style="zoom:50%;" />

<p>平衡二叉搜索树：AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>如图：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111604650.png" alt="img"></p>
<p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p>
<p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p>
<ul>
<li>正是高度差&lt;&#x3D;1，以及红黑树的规则，保证了O(logn)的复杂度</li>
</ul>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>链式存储方式就用指针， 顺序存储的方式就是用数组。顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。一般是用链式表示二叉树，有助于理解。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111611790.png" alt="img" style="zoom:33%;" /><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111611874.png" alt="img" style="zoom: 33%;" /></p>
<p>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><ul>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。<ul>
<li>前序遍历（递归法，迭代法）中左右</li>
<li>中序遍历（递归法，迭代法）左中右</li>
<li>后序遍历（递归法，迭代法）左右中</li>
</ul>
</li>
<li>广度优先遍历：一层一层的去遍历。<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503111616426.png" alt="img" style="zoom:50%;" />

<p><strong>栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.left = left</span><br><span class="line">        <span class="variable language_">self</span>.right = right</span><br></pre></td></tr></table></figure>

<h2 id="7-2-二叉树的递归遍历"><a href="#7-2-二叉树的递归遍历" class="headerlink" title="7.2 二叉树的递归遍历"></a>7.2 二叉树的递归遍历</h2><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 左右中</span></span><br><span class="line">        res = []<span class="comment"># 定义在外部函数中的局部变量</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#注意没有null，以及不要用==None，写is None</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">            res.append(node.val)<span class="comment"># 子函数可以访问并修改外部函数的变量 属于闭包</span></span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            traverse(node.left)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-3-二叉树的迭代遍历"><a href="#7-3-二叉树的迭代遍历" class="headerlink" title="7.3 二叉树的迭代遍历"></a>7.3 二叉树的迭代遍历</h2><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，每次弹出来的加入res，然后将右孩子加入栈，再加入左孩子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="comment">#检查是否为空</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 中节点先处理</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="comment"># 右孩子先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="comment"># 左孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>中序遍历：需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        cur = root <span class="comment">#这里要先迭代到最底层的左子树节点，所以不能把root提前加进去</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment">#到达最左节点后逐步处理子树</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#else说明cur.left为空</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                result.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>后序遍历：因为第一个是中比较好处理，所以先得到中右左再反转，跟前序很像，就是先放左节点再放右节点</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503171430654.png" alt="前序到后序"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack.pop()</span><br><span class="line">            result.append(n.val)</span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                stack.append(n.left)</span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                stack.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。</p>
<p><strong>这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p>
<h2 id="7-4-二叉树的统一迭代法"><a href="#7-4-二叉树的统一迭代法" class="headerlink" title="7.4 二叉树的统一迭代法"></a>7.4 二叉树的统一迭代法</h2><p>方法一：<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法可以叫做<code>空指针标记法</code>。这样当遇见空指针时，就应该pop出栈+加入result列表。什么时候加空？就是在当前处理的节点（中）后面加None。</p>
<p>先统一把root加进去，然后左中右的顺序因为是栈，反过来加入即可。要处理指只访问了，没有加入到结果集未处理的点。</p>
<p>前序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st= []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)<span class="comment">#中是当前处理的节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>中序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#添加右节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                st.append(node) <span class="comment">#添加中节点</span></span><br><span class="line">                st.append(<span class="literal">None</span>) <span class="comment">#中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#添加左节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                node = st.pop() <span class="comment">#重新取出栈中元素</span></span><br><span class="line">                result.append(node.val) <span class="comment">#加入到结果集</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>后序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>方法二：<strong>加一个 <code>boolean</code> 值跟随每个节点，<code>false</code> (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，<code>true</code> 表示该节点的位次之前已经安排过了，可以收割节点了。</strong> 这种方法可以叫做<code>boolean 标记法</code>，样例代码见下文<code>C++ 和 Python 的 boolean 标记法</code>。 这种方法更容易理解，在面试中更容易写出来。</p>
<p>还是一开始把root进栈，很好理解的visited数组，如果该节点和两个子节点都安排过了，就可以标为true，准备加入结果集了</p>
<p>前序：中左右</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> [] </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()      </span><br><span class="line">            <span class="keyword">if</span> visited: </span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node.right:<span class="comment">#右</span></span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            <span class="keyword">if</span> node.left:<span class="comment">#左</span></span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) </span><br><span class="line">            stack.append((node, <span class="literal">True</span>))<span class="comment">#中</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>中序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> [] </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop()      </span><br><span class="line">            <span class="keyword">if</span> visited: </span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node.right:<span class="comment">#右</span></span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">            stack.append((node, <span class="literal">True</span>))<span class="comment">#中</span></span><br><span class="line">            <span class="keyword">if</span> node.left:<span class="comment">#左</span></span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>后序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        stack = [(root, <span class="literal">False</span>)] <span class="keyword">if</span> root <span class="keyword">else</span> [] <span class="comment"># 多加一个参数，False 为默认值</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, visited = stack.pop() <span class="comment"># 多加一个 visited 参数，使“迭代统一写法”成为一件简单的事</span></span><br><span class="line">            <span class="keyword">if</span> visited: <span class="comment"># visited 为 True，表示该节点和两个儿子位次之前已经安排过了，现在可以收割节点了</span></span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">#这一轮循环过掉</span></span><br><span class="line">            <span class="comment"># visited 当前为 False, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次” 同时，设置 visited 为 True，表示下次再访问本节点时，允许收割。</span></span><br><span class="line">            stack.append((node, <span class="literal">True</span>)) <span class="comment">#中节点</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>)) <span class="comment"># 右儿子位置居中</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>)) <span class="comment"># 左儿子最后入栈，最先出栈</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="7-5-二叉树层序遍历"><a href="#7-5-二叉树层序遍历" class="headerlink" title="7.5 二叉树层序遍历"></a>7.5 二叉树层序遍历</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>栈先进后出适合模拟DFS，深度优先</p>
<p>队列先进先出适合模拟BFS，广度优先</p>
<p>难点是如何确定在某一层？用目前队列的长度len！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []<span class="comment">#当前层的内容，可看作子数组</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h3><p>自底向上的层序遍历，最后反转一下即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>取层序遍历的右值，即level[-1]，其实不需要像上面一样记录每层完整的level，只需要在i&#x3D;&#x3D;len(queue)-1时获取值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue) <span class="comment">#这里要记录，不然popleft后长度会变</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == level_size - <span class="number">1</span>:</span><br><span class="line">                    result.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><p>就是把每层求累计再求平均</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level_sum = <span class="number">0</span> <span class="comment">#这里要记录，不然popleft后长度会变</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level_sum += cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level_sum / level_size)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h3><p>从2叉树变为n叉树，遍历每个节点的children即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> cur.children:</span><br><span class="line">                    queue.append(node)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h3><p>定义无穷小值然后去比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            max_ = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.val &gt; max_:</span><br><span class="line">                    max_ = cur.val</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(max_)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><p>保证是有两个子节点，仍然是遍历level进行指针的排列，最后一个节点指向null</p>
<p>我刚开始是先把同层节点都加入level，再遍历level进行连接，但其实不用额外的空间level存每层节点，遍历时用prev存即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []<span class="comment">#当前层的内容，可看作子数组</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(level)):</span><br><span class="line">                <span class="keyword">if</span> i != <span class="built_in">len</span>(level) - <span class="number">1</span>:</span><br><span class="line">                    level[i].<span class="built_in">next</span> = level[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    level[i].<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; <span class="string">&#x27;Optional[Node]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            prev = <span class="literal">None</span> <span class="comment">#存上一个节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> prev: </span><br><span class="line">                    prev.<span class="built_in">next</span> = cur</span><br><span class="line">                prev = cur <span class="comment">#最后一个节点自然不会有next</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h3><p>要求只能使用常量级的额外空间，上面的两种方法均符合，时间复杂度为O(n)，把树上的每个节点都遍历了</p>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>仍然用层序遍历看，最大深度就是二叉树的层数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>哪一层最先出现叶子节点，该层数就是最小深度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            res += <span class="number">1</span> <span class="comment">#记录当前的层数</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-6-翻转二叉树"><a href="#7-6-翻转二叉树" class="headerlink" title="7.6 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">7.6 翻转二叉树</a></h2><p>我使用的方法是迭代法的层序遍历，把每个节点的左右孩子翻转，用前中后序也是可以的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#存储未翻转的节点</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>递归法的前序遍历举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.left)</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="7-7-二叉树周末总结"><a href="#7-7-二叉树周末总结" class="headerlink" title="7.7 二叉树周末总结"></a>7.7 二叉树周末总结</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root: <span class="string">&#x27;Node&#x27;</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">                traverse(node)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root: <span class="string">&#x27;Node&#x27;</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">                traverse(node)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。</p>
<p>一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代</p>
<h2 id="7-8-对称二叉树"><a href="#7-8-对称二叉树" class="headerlink" title="7.8 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">7.8 对称二叉树</a></h2><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503181742779.png" alt="101. 对称二叉树1" style="zoom:50%;" />

<p>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。所以要用后序遍历。</p>
<p>递归三部曲</p>
<ol>
<li><p>确定递归函数的参数和返回值：bool</p>
</li>
<li><p>确定终止条件：</p>
<ol>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ol>
</li>
<li><p>确定单层递归的逻辑：</p>
<ol>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.compare(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#两个节点都不为空时</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#当前两个节点相等，就比较子节点的外侧和内侧</span></span><br><span class="line">        outside = <span class="variable language_">self</span>.compare(left.left, right.right)</span><br><span class="line">        inside = <span class="variable language_">self</span>.compare(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure>

<p>迭代法：我使用层序遍历获得level判断是否对称，但这样有额外的空间开销</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#收集每层的内容，反转数组一样</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)<span class="comment">#这里是代码随想录补充的剪枝，这样某一层是奇数个节点就不用看了，不是对称二叉树</span></span><br><span class="line">            <span class="keyword">if</span> level_size % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                    level.append(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">                    level.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> level != level[::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>不适用level记录，直接根据终止条件获得左右子树节点然后判断的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left) <span class="comment">#将左子树头结点加入队列</span></span><br><span class="line">        queue.append(root.right) <span class="comment">#将右子树头结点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment">#接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            leftNode = queue.popleft()</span><br><span class="line">            rightNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode: <span class="comment">#左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#到这一步说明左右节点不为空且数值相同，可以比接下来的。注意加入顺序：先比外侧再比内侧，所以左左+右右一组/左右+右左一组</span></span><br><span class="line">            queue.append(leftNode.left) <span class="comment">#加入左节点左孩子</span></span><br><span class="line">            queue.append(rightNode.right) <span class="comment">#加入右节点右孩子</span></span><br><span class="line">            queue.append(leftNode.right) <span class="comment">#加入左节点右孩子</span></span><br><span class="line">            queue.append(rightNode.left) <span class="comment">#加入右节点左孩子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="7-9-二叉树的最大深度"><a href="#7-9-二叉树的最大深度" class="headerlink" title="7.9 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">7.9 二叉树的最大深度</a></h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<p>递归法：左右中：后序遍历，取最大值作为深度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l, r = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            l = <span class="variable language_">self</span>.maxDepth(root.left) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            r = <span class="variable language_">self</span>.maxDepth(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r)</span><br></pre></td></tr></table></figure>

<p>迭代法：用queue，每轮存一层的所有节点，层数就是深度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列的库</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):<span class="comment">#注意这里长度为len(queue)是最巧妙的</span></span><br><span class="line">                n = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    queue.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    queue.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></p>
<p>递归法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.children:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> root.children:</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="variable language_">self</span>.maxDepth(n))</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>迭代法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                n = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> n.children:</span><br><span class="line">                    <span class="keyword">for</span> node <span class="keyword">in</span> n.children:</span><br><span class="line">                        queue.append(node)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<h2 id="7-10-二叉树的最小深度"><a href="#7-10-二叉树的最小深度" class="headerlink" title="7.10 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">7.10 二叉树的最小深度</a></h2><p>难点在于左右孩子不为空的逻辑</p>
<p>可以设置正无穷，这样只有一边的节点时不会取默认值0，但测出来效率低</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">        l, r = <span class="built_in">float</span>(<span class="string">&#x27;+inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;+inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            l = <span class="variable language_">self</span>.minDepth(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            r = <span class="variable language_">self</span>.minDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(l, r) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>也可以老实写判断逻辑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDepth = <span class="variable language_">self</span>.minDepth(root.left)  <span class="comment"># 左</span></span><br><span class="line">        rightDepth = <span class="variable language_">self</span>.minDepth(root.right)  <span class="comment"># 右</span></span><br><span class="line">        <span class="comment"># 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line">        <span class="comment"># 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth</span><br><span class="line">        result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>迭代法就是层序遍历到第一个叶子节点就返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                n = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n.left <span class="keyword">and</span> <span class="keyword">not</span> n.right:</span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    queue.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    queue.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>

<h2 id="7-11-完全二叉树的节点个数"><a href="#7-11-完全二叉树的节点个数" class="headerlink" title="7.11 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">7.11 完全二叉树的节点个数</a></h2><p>求节点个数：O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.countNodes(root.left) + <span class="variable language_">self</span>.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>利用完全二叉树：只有两种情况</p>
<ul>
<li>一种是满二叉树：节点个数可以直接用2^树深度-1来计算</li>
<li>一种是最后一层叶子节点没有满，但递归到某一深度后一定会有左右孩子为满二叉树，用上式计算<ul>
<li>满二叉树的判断是左右子树的深度相等</li>
</ul>
</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503291621043.png" alt="img" style="zoom: 33%;" />

<p>这个情况无需考虑因为不是完全二叉树<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503291621084.png" alt="img" style="zoom:25%;" /></p>
<p>别看最后还是后序遍历的递归，但用满二叉树的公式计算左右子树是一种剪枝，节约了许多递归开销</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        leftDepth = <span class="number">0</span> <span class="comment">#这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        rightDepth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left: <span class="comment">#求左子树深度</span></span><br><span class="line">            left = left.left</span><br><span class="line">            leftDepth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right: <span class="comment">#求右子树深度</span></span><br><span class="line">            right = right.right</span><br><span class="line">            rightDepth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> leftDepth == rightDepth:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span> <span class="comment">#注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.countNodes(root.left) + <span class="variable language_">self</span>.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>或者把left&#x2F;right写在一个while里循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        left = root.left; right = root.right</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            left = left.left; right = right.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="comment"># 如果同时到底说明是满二叉树，反之则不是，剪枝</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;count)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="variable language_">self</span>.countNodes(root.left)+<span class="variable language_">self</span>.countNodes(root.right) </span><br></pre></td></tr></table></figure>

<h2 id="7-12-平衡二叉树"><a href="#7-12-平衡二叉树" class="headerlink" title="7.12 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">7.12 平衡二叉树</a></h2><p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的高度相差不超过 1。</p>
<ul>
<li>二叉树节点的深度：指从根节点到<strong>该节点</strong>的最长简单路径边的条数。用前序遍历，是层数</li>
<li>二叉树节点的高度：指从该节点到<strong>叶子节点</strong>的最长简单路径边的条数。用后序遍历，是倒数第几层</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503291706513.png" alt="110.平衡二叉树2" style="zoom:33%;" />

<p>我本来的算法把递归重复了两遍，其实没必要，因为getDepth的过程中就可以进行平衡二叉树的判断了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">root</span>) -&gt; <span class="built_in">int</span>:<span class="comment">#计算左右子树的高度.子函数要写在前面，不然，不然访问不到，认为根节点为0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(getHeight(root.left), getHeight(root.right)) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        l = getHeight(root.left) + <span class="number">1</span></span><br><span class="line">        r = getHeight(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.isBalanced(root.right) <span class="keyword">and</span> <span class="variable language_">self</span>.isBalanced(root.left)</span><br></pre></td></tr></table></figure>

<p>定义getHeight依然返回高度，如果不是平衡二叉树就返回-1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getHeight</span>(<span class="params">root</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            l = getHeight(root.left)</span><br><span class="line">            r = getHeight(root.right)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span> <span class="keyword">or</span> l == -<span class="number">1</span> <span class="keyword">or</span> r == -<span class="number">1</span>:<span class="comment">#这里记得判断l/r是否为-1，会覆盖左右子树不满足平衡的情况</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> getHeight(root) == -<span class="number">1</span> <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>此题用迭代法效率很低，虽然理论上所有递归都可以迭代实现，但这里需要遍历每个节点然后计算当前节点左右子树的高度，没细看感觉很麻烦</p>
<h2 id="7-13-二叉树的所有路径"><a href="#7-13-二叉树的所有路径" class="headerlink" title="7.13 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">7.13 二叉树的所有路径</a></h2><p>从根节点到叶子节点：前序遍历（中左右）递归+回溯</p>
<p>递归法+回溯：回溯这里的path.pop()是关键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, cur, path, result</span>):</span><br><span class="line">            path.append(cur.val)  <span class="comment"># 中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:  <span class="comment"># 到达叶子节点</span></span><br><span class="line">                sPath = <span class="string">&#x27;-&gt;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, path)) <span class="comment">#把访问到的节点的值都连接起来</span></span><br><span class="line">                result.append(sPath)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:  <span class="comment"># 左</span></span><br><span class="line">                <span class="variable language_">self</span>.traversal(cur.left, path, result)</span><br><span class="line">                path.pop()  <span class="comment"># 回溯</span></span><br><span class="line">            <span class="keyword">if</span> cur.right:  <span class="comment"># 右</span></span><br><span class="line">                <span class="variable language_">self</span>.traversal(cur.right, path, result)</span><br><span class="line">                path.pop()  <span class="comment"># 回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root</span>):</span><br><span class="line">            result = [] <span class="comment">#存路径结果</span></span><br><span class="line">            path = [] <span class="comment">#存每个节点的值</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="variable language_">self</span>.traversal(root, path, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>迭代法：刚开始我用stack不知道如何实现，发现答案用path_st存储遍历到每个节点的路径，而不是仅用一个res保存当前的访问</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment">#需要深度优先搜索，前序遍历（中左右），用栈</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        path_st = [<span class="built_in">str</span>(root.val)]<span class="comment">#存储遍历到每个节点时的路径</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack.pop()</span><br><span class="line">            path = path_st.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n.left <span class="keyword">and</span> <span class="keyword">not</span> n.right:</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">if</span> n.right:<span class="comment">#因为是栈先进右值</span></span><br><span class="line">                stack.append(n.right)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(n.right.val))<span class="comment">#是下一步的内容</span></span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                stack.append(n.left)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(n.left.val))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="7-14-二叉树周末总结"><a href="#7-14-二叉树周末总结" class="headerlink" title="7.14 二叉树周末总结"></a>7.14 二叉树周末总结</h2><h1 id="Hot100"><a href="#Hot100" class="headerlink" title="Hot100"></a>Hot100</h1><h2 id="1：160-相交链表"><a href="#1：160-相交链表" class="headerlink" title="1：160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">1：160. 相交链表</a></h2><p>我本来的想法是倒序看两个链表，但链表又只能从头开始。看来还是要用数学技巧</p>
<p>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：<br>a+(b−c)<br>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：<br>b+(a−c)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A != B:</span><br><span class="line">            A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br><span class="line">            B = B.<span class="built_in">next</span> <span class="keyword">if</span> B <span class="keyword">else</span> headA</span><br><span class="line">            <span class="comment">#就是进行了切换，等价于下面，这里的跳跃是技巧</span></span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A = A.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = headB</span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                B = B.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = headA</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>

<h2 id="2：236-二叉树的最近公共祖先"><a href="#2：236-二叉树的最近公共祖先" class="headerlink" title="2：236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">2：236. 二叉树的最近公共祖先</a></h2><p>深度就是第几层，从根节点到该节点，从上往下</p>
<p>高度是倒数第几层，就像楼层一样从下往上</p>
<p>两个节点 <code>p</code>,<code>q</code> 分为两种情况：</p>
<ul>
<li><code>p</code> 和 <code>q</code> 在相同子树中</li>
<li><code>p</code> 和 <code>q</code> 在不同子树中</li>
</ul>
<p>从根节点遍历，递归向左右子树查询节点信息</p>
<p>递归终止条件：如果当前节点为空或等于 p 或 q，则返回当前节点</p>
<p>递归遍历左右子树，如果左右子树查到节点都不为空，则表明 p 和 q 分别在左右子树中，在root的两侧，因此，当前节点root即为最近公共祖先；</p>
<p>如果左右子树其中一个不为空，则返回非空节点。</p>
<ul>
<li>如果left不为空，说明p,q在左子树。</li>
<li>如果right不为空，说明p,q在右子树。</li>
<li>left和right都为空，说明找不到。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="comment">#深度是指第几层，尽可能大说明如果在同侧要尽量往下（就是本身）</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == q <span class="keyword">or</span> root == p:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = <span class="variable language_">self</span>.lowestCommonAncestor(root.left, p, q)<span class="comment">#注意自己调自己要写self</span></span><br><span class="line">        right = <span class="variable language_">self</span>.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:<span class="comment">#说明在同侧的一棵子树上，p/q只能搜到一个</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> <span class="comment">#这题场景中应该不存在找不到</span></span><br></pre></td></tr></table></figure>

<h2 id="3：234-回文链表"><a href="#3：234-回文链表" class="headerlink" title="3：234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">3：234. 回文链表</a></h2><ol>
<li>找中间节点：快慢指针</li>
<li>反转链表：中间到最后的反转了</li>
<li>对比两个链表</li>
</ol>
<p>为什么反转中间而不是一开始就反转全部，当然是为了O(n)节约复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#回文链表是中间对称的</span></span><br><span class="line">        mid = <span class="variable language_">self</span>.middleNode(head)</span><br><span class="line">        head2 = <span class="variable language_">self</span>.reverse(mid)<span class="comment">#注意是mid，不是head</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head2:</span><br><span class="line">            <span class="keyword">if</span> head.val != head2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            head2 = head2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="4：739-每日温度-stack"><a href="#4：739-每日温度-stack" class="headerlink" title="4：739. 每日温度 stack"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">4：739. 每日温度</a> stack</h2><p>单调栈（Monotonic Stack）是一种特殊的栈结构，其元素按照<strong>严格递增或严格递减</strong>的顺序排列。它的核心思想是<strong>利用栈的单调性快速找到元素的前后边界</strong>，常用于解决数组中与“相邻元素大小关系”相关的问题。</p>
<ul>
<li><p>下一次更高的温度出现在几天后，相当于我要把温度排序，得到它的序号作为名次，或者看作折线图（我的想法没有单调栈简单）</p>
</li>
<li><p>从左到右, 更新为主, 去除为辅, 元素可重复。</p>
<p>从右到左, 去除为主, 更新为辅, 元素无重复。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        st = []<span class="comment">#栈内元素在该题中保持递减，存的是下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):<span class="comment">#倒序</span></span><br><span class="line">            t = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt;= temperatures[st[-<span class="number">1</span>]]:<span class="comment">#st的最后一个存的是离自己最近的最高温度 自己比未来&gt;=不算数</span></span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                res[i] = st[-<span class="number">1</span>] - i<span class="comment">#看下标的距离</span></span><br><span class="line">            st.append(i) <span class="comment">#会把当前的加进去</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>从左到右的方法是TODO list</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        st = []<span class="comment">#栈内元素在该题中保持递减，存的是下标</span></span><br><span class="line">        <span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):<span class="comment">#从左到右，todo</span></span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> t &gt; temperatures[st[-<span class="number">1</span>]]:<span class="comment">#现在比之前的大，则前面的可以解决（注意不是&gt;=号！）</span></span><br><span class="line">                j = st.pop()</span><br><span class="line">                res[j] = i - j<span class="comment">#看下标的距离</span></span><br><span class="line">            st.append(i) <span class="comment">#会把当前的加进去</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="5：226-翻转二叉树"><a href="#5：226-翻转二叉树" class="headerlink" title="5：226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">5：226. 翻转二叉树</a></h2><p>普通递推，注意不用定义tmp，直接用&#x3D;即可进行交换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.left)</span><br><span class="line">        <span class="variable language_">self</span>.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="6：221-最大正方形-dp"><a href="#6：221-最大正方形-dp" class="headerlink" title="6：221. 最大正方形 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">6：221. 最大正方形</a> dp</h2><p>状态转移方程根据不等式来的</p>
<p>&#x3D;别手误写成&#x3D;&#x3D;</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504011307571.png" alt="image-20250401130758479"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxSide = <span class="number">0</span> <span class="comment">#记录整个图形中出现过最大的边长</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):   <span class="comment">#从左上开始</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:   <span class="comment">#如果为0那dp也为0</span></span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:   <span class="comment">#在边界上</span></span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j])</span><br><span class="line">        maxSquare = maxSide * maxSide</span><br><span class="line">        <span class="keyword">return</span> maxSquare</span><br></pre></td></tr></table></figure>

<h2 id="7：215-数组中的第K个最大元素"><a href="#7：215-数组中的第K个最大元素" class="headerlink" title="7：215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">7：215. 数组中的第K个最大元素</a></h2><p>快速排序：</p>
<ul>
<li><p>哨兵划分： 以数组某个元素（一般选取首元素）为基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p>
</li>
<li><p>递归： 对 左子数组 和 右子数组 递归执行 哨兵划分，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。</p>
</li>
</ul>
<p>这里并没有排序好完整的序列，只是把k所在的地方排序了，节约了时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quick_select</span>(<span class="params">nums, k</span>):</span><br><span class="line">            pivot = random.choice(nums)</span><br><span class="line">            big, equal, small = [], [], []</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &gt; pivot:</span><br><span class="line">                    big.append(num)</span><br><span class="line">                <span class="keyword">elif</span> num &lt; pivot:</span><br><span class="line">                    small.append(num)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    equal.append(num)</span><br><span class="line">            <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(big):</span><br><span class="line">                <span class="keyword">return</span> quick_select(big, k)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums) - <span class="built_in">len</span>(small) &lt; k:<span class="comment">#比如第9大，有10个元素，small有3，就是找small中的第二大</span></span><br><span class="line">                <span class="keyword">return</span> quick_select(small, k - <span class="built_in">len</span>(nums) + <span class="built_in">len</span>(small))</span><br><span class="line">            <span class="keyword">return</span> pivot</span><br><span class="line">        <span class="keyword">return</span> quick_select(nums, k)</span><br></pre></td></tr></table></figure>

<h2 id="8：208-实现-Trie-前缀树-模板题"><a href="#8：208-实现-Trie-前缀树-模板题" class="headerlink" title="8：208. 实现 Trie (前缀树)模板题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">8：208. 实现 Trie (前缀树)</a>模板题</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504011358426.png" alt="前缀树"></p>
<p>插入单词，检索是否存在，看前缀是否存在</p>
<p> 创建26叉树，像桶排序一样方便查找；然后用bool表示是否结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    __slots__ = <span class="string">&#x27;son&#x27;</span>, <span class="string">&#x27;end&#x27;</span> <span class="comment">#限制属性以节省内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.son = [<span class="literal">None</span>] * <span class="number">26</span></span><br><span class="line">        <span class="variable language_">self</span>.end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.root = Node()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur = <span class="variable language_">self</span>.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            c = <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.son[c] <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#目前没有这个</span></span><br><span class="line">                cur.son[c] = Node()</span><br><span class="line">            cur = cur.son[c] <span class="comment">#变成子节点，深度搜索</span></span><br><span class="line">        cur.end = <span class="literal">True</span> <span class="comment">#最后一个字符的end设置为true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur = <span class="variable language_">self</span>.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            c = <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.son[c] <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#有一个字符不一样就返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            cur = cur.son[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="keyword">if</span> cur.end <span class="keyword">else</span> <span class="number">1</span> <span class="comment">#如果是end，说明是search</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:<span class="comment">#每个字符都一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.find(word) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:<span class="comment">#包括search和开头两种情况，所以返回1/2都行，但不能返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.find(prefix) != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>

<h2 id="9：207-课程表-拓扑"><a href="#9：207-课程表-拓扑" class="headerlink" title="9：207. 课程表 拓扑"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">9：207. 课程表</a> 拓扑</h2><p>拓扑排序：给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面。如果有有向无环图即可</p>
<ul>
<li><p>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canFinish</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)] <span class="comment">#记录每个课程的入度（即有多少先修课程）</span></span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)] <span class="comment">#邻接表，用于存储每个课程的后继课程</span></span><br><span class="line">        queue = collections.deque() <span class="comment">#先进先出 进行BFS 存储学了的课程方便遍历后继</span></span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:<span class="comment">#[0,1]0是1的后继，1是0的先修</span></span><br><span class="line">            indegrees[cur] += <span class="number">1</span></span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="comment">#把所有入度为0的课程加入队列，没有先修课程可以立即开始学习</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(indegrees)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> indegrees[i]: </span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="comment"># BFS TopSort. numCourses记录仍待学习的课程总数</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = queue.popleft()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjacency[pre]:<span class="comment">#pre的后继课程如果只有pre一个先修，就学了</span></span><br><span class="line">                indegrees[cur] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> indegrees[cur]: </span><br><span class="line">                    queue.append(cur)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> numCourses</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10：206-反转链表"><a href="#10：206-反转链表" class="headerlink" title="10：206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">10：206. 反转链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h2 id="11：200-岛屿数量-dfs"><a href="#11：200-岛屿数量-dfs" class="headerlink" title="11：200. 岛屿数量 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">11：200. 岛屿数量 dfs</a></h2><p>一旦我们发现 (i,j) 是 1，就从 (i,j) 开始，DFS 这个岛。</p>
<p>每一步可以往左右上下四个方向走，也就是</p>
<p>(i,j−1),(i,j+1),(i−1,j),(i+1,j)<br>这四个格子。</p>
<p>每次到达一个新的格子，就插上旗子🚩，把 grid[i][j] 改成 2。</p>
<p>如果 (i,j) 出界，或者 (i,j) 是水，或者 (i,j) 已经插上了旗子🚩，就不再继续往下递归。</p>
<p>⚠注意：DFS 的过程中，最重要的是不能重复访问之前访问过的格子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:<span class="comment">#子函数可以访问外部函数的参数，外部函数调用也可以直接写</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> grid[i][j] != <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">#不在往下递归的条件</span></span><br><span class="line">            grid[i][j] = <span class="string">&#x27;2&#x27;</span><span class="comment">#插旗子</span></span><br><span class="line">            dfs(i, j - <span class="number">1</span>)</span><br><span class="line">            dfs(i, j + <span class="number">1</span>)</span><br><span class="line">            dfs(i - <span class="number">1</span>, j)</span><br><span class="line">            dfs(i + <span class="number">1</span>, j)</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dfs(i, j)</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="12：198-打家劫舍-dp"><a href="#12：198-打家劫舍-dp" class="headerlink" title="12：198. 打家劫舍  dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">12：198. 打家劫舍</a>  dp</h2><p>1.子问题：从k个房子能偷到的最大金额</p>
<p>2.递推关系：<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504011426722.jpeg" alt="子问题的递推关系" style="zoom:33%;" /></p>
<p>3.计算顺序：k依赖K-1和k-2，所以从左到右算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="comment">#注意要设置n+1个数，这样i-2才不会越界，保证可以不选第一个数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], nums[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<p>空间优化：其实只用两个值迭代，不需要一整个dp，就能推出最后的最大值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        pre, cur = <span class="number">0</span>, <span class="number">0</span> <span class="comment">#分别代表i-2和i-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            pre, cur = cur, <span class="built_in">max</span>(cur, i + pre)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h2 id="13：169-多数元素-投票"><a href="#13：169-多数元素-投票" class="headerlink" title="13：169. 多数元素  投票"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">13：169. 多数元素</a>  投票</h2><p>暴力：排序返回中间数字；哈希表统计</p>
<p>最佳方法：摩尔投票（就是抵消原则，一一配对，最后剩下来至少一个该元素）</p>
<ul>
<li>推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 &gt;0 。</li>
<li>推论二： 若数组的前 a 个数字的 票数和 &#x3D;0 ，则 数组剩余 (n−a) 个数字的 票数和一定仍 &gt;0 ，即后 (n−a) 个数字的 众数仍为 x 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        votes, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>: x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 验证 x 是否为众数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == x: count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; <span class="built_in">len</span>(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 当无众数时返回 0</span></span><br></pre></td></tr></table></figure>

<h2 id="14：238-除自身以外数组的乘积"><a href="#14：238-除自身以外数组的乘积" class="headerlink" title="14：238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">14：238. 除自身以外数组的乘积</a></h2><p>分别<strong>迭代计算</strong>上三角和下三角的乘积即可。前缀积和后缀积</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504011445541.png" alt="Picture1.png" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">productExceptSelf</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans, tmp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] * nums[i -<span class="number">1</span>] <span class="comment">#下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp *= nums[i + <span class="number">1</span>]</span><br><span class="line">            ans[i] *= tmp <span class="comment">#上三角</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="15：155-最小栈"><a href="#15：155-最小栈" class="headerlink" title="15：155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">15：155. 最小栈</a></h2><p>为什么不能用一个stack，因为min是O(n)，不是常数时间</p>
<p>用额外的空间辅助存最小值，用list的原因是最小值可能不止一个，可以保证数量的正确性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stack = []</span><br><span class="line">        <span class="variable language_">self</span>.min_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.min_stack <span class="keyword">or</span> val &lt;= <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>]: <span class="comment">#更新栈顶的最小值，重复值也重复入（保证pop的正确性，不然数量对不上）</span></span><br><span class="line">            <span class="variable language_">self</span>.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack.pop() == <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>]:<span class="comment">#这里stack是一定会pop的，如果和最小值相等把mini_stack也pop了</span></span><br><span class="line">            <span class="variable language_">self</span>.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>

<h2 id="16：152-乘积最大子数组"><a href="#16：152-乘积最大子数组" class="headerlink" title="16：152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">16：152. 乘积最大子数组</a></h2><p>要有连续的非空子数组</p>
<p>如果当前的数是正数，要与前面最大的乘积相乘；如果当前的数是负数，要与前面最小的乘积相乘。这样才有可能最大（这是最关键的思路，一般题只考虑最大值，但因为连续，这里要考虑最小值）</p>
<p>可以合并在一起写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f_max = [<span class="number">0</span>] * n</span><br><span class="line">        f_min = [<span class="number">0</span>] * n</span><br><span class="line">        f_max[<span class="number">0</span>] = f_min[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            x = nums[i]</span><br><span class="line">            f_max[i] = <span class="built_in">max</span>(f_max[i - <span class="number">1</span>] * x, f_min[i - <span class="number">1</span>] * x, x)</span><br><span class="line">            f_min[i] = <span class="built_in">min</span>(f_max[i - <span class="number">1</span>] * x, f_min[i - <span class="number">1</span>] * x, x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f_max)</span><br></pre></td></tr></table></figure>

<p>注意最后返回的是过程中的最大值</p>
<p>空间优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -inf  <span class="comment"># 注意答案可能是负数</span></span><br><span class="line">        f_max = f_min = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            f_max, f_min = <span class="built_in">max</span>(f_max * x, f_min * x, x), <span class="built_in">min</span>(f_max * x, f_min * x, x)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f_max)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="17：148-排序链表-难！"><a href="#17：148-排序链表-难！" class="headerlink" title="17：148. 排序链表 难！"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">17：148. 排序链表 </a>难！</h2><p>归并排序：</p>
<ul>
<li>分割：不断用快慢指针找到mid，然后mid.next&#x3D;None把链表切断<ul>
<li>终止条件非常重要！当head.next为空时说明只有一个节点，返回该节点即可</li>
</ul>
</li>
<li>合并：把两个有序链表合并，不断比较头节点即可，用dummy更简单</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        mid, slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">        left, right = <span class="variable language_">self</span>.sortList(head), <span class="variable language_">self</span>.sortList(mid)</span><br><span class="line">        res = ListNode(<span class="number">0</span>)<span class="comment">#dummy节点，不变用于返回</span></span><br><span class="line">        h = res <span class="comment">#存储合并后的链表</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                h.<span class="built_in">next</span> = left</span><br><span class="line">                left = left.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h.<span class="built_in">next</span> = right</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">            h = h.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            h.<span class="built_in">next</span> = left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            h.<span class="built_in">next</span> = right</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="18：146-LRU-缓存模板题"><a href="#18：146-LRU-缓存模板题" class="headerlink" title="18：146. LRU 缓存模板题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">18：146. LRU 缓存</a>模板题</h2><p>最近最久未使用的缓存会被移除</p>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p>看到题目要我们实现一个可以存储 key-value 形式数据的数据结构，并且可以记录最近访问的 key 值。首先想到的就是用字典来存储 key-value 结构，这样对于查找操作时间复杂度就是 O(1)。</p>
<p>但是因为字典本身是无序的，所以我们还需要一个类似于队列的结构来记录访问的先后顺序，这个队列需要支持如下几种操作：</p>
<ul>
<li><p>在末尾加入一项</p>
</li>
<li><p>去除最前端一项</p>
</li>
<li><p>将队列中某一项移到末尾</p>
</li>
</ul>
<p>链表末尾就是最新访问的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="literal">None</span>, value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.key = key</span><br><span class="line">        <span class="variable language_">self</span>.value = value</span><br><span class="line">        <span class="variable language_">self</span>.prev = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.capacity = capacity <span class="comment">#LRU的大小</span></span><br><span class="line">        <span class="variable language_">self</span>.hashmap = &#123;&#125; <span class="comment">#缓存，存储key和listnode节点！而不仅仅是value！</span></span><br><span class="line">        <span class="comment">#定义双向链表用于更新最新访问的key</span></span><br><span class="line">        <span class="variable language_">self</span>.head = ListNode()</span><br><span class="line">        <span class="variable language_">self</span>.tail = ListNode()</span><br><span class="line">        <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">        <span class="variable language_">self</span>.tail.prev = <span class="variable language_">self</span>.head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move_node_to_tail</span>(<span class="params">self, key</span>):</span><br><span class="line">            node = <span class="variable language_">self</span>.hashmap[key] <span class="comment">#先从现有链表中删除key指向的节点</span></span><br><span class="line">            node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line"></span><br><span class="line">            node.prev = <span class="variable language_">self</span>.tail.prev <span class="comment"># 之后将node插入到尾节点前</span></span><br><span class="line">            node.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:<span class="comment">#不在缓存中就返回-1</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.hashmap:</span><br><span class="line">            <span class="variable language_">self</span>.move_node_to_tail(key)<span class="comment"># 如果已经在链表中了久把它移到末尾（变成最新访问的）</span></span><br><span class="line">        res = <span class="variable language_">self</span>.hashmap.get(key, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> res == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res.value <span class="comment">#因为找到的是listnode，返回value</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.hashmap:</span><br><span class="line">            <span class="variable language_">self</span>.hashmap[key].value = value <span class="comment"># 更新值</span></span><br><span class="line">            <span class="variable language_">self</span>.move_node_to_tail(key)  <span class="comment"># 随后将该节点移到末尾</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#key不在里面，要逐出一个</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.hashmap) == <span class="variable language_">self</span>.capacity:</span><br><span class="line">                <span class="variable language_">self</span>.hashmap.pop(<span class="variable language_">self</span>.head.<span class="built_in">next</span>.key)</span><br><span class="line">                <span class="comment"># 去掉最久没有被访问过的节点，即头节点之后的节点</span></span><br><span class="line">                <span class="variable language_">self</span>.head.<span class="built_in">next</span> = <span class="variable language_">self</span>.head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="variable language_">self</span>.head.<span class="built_in">next</span>.prev = <span class="variable language_">self</span>.head</span><br><span class="line">           </span><br><span class="line">            <span class="comment">#现在容量够了，作为最新访问的节点插到tail之前即可</span></span><br><span class="line">            new = ListNode(key, value)</span><br><span class="line">            <span class="variable language_">self</span>.hashmap[key] = new</span><br><span class="line">            new.prev = <span class="variable language_">self</span>.tail.prev</span><br><span class="line">            new.<span class="built_in">next</span> = <span class="variable language_">self</span>.tail</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev.<span class="built_in">next</span> = new</span><br><span class="line">            <span class="variable language_">self</span>.tail.prev = new</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>

<h2 id="19：142-环形链表-II"><a href="#19：142-环形链表-II" class="headerlink" title="19：142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">19：142. 环形链表 II</a></h2><p>第一次相遇后，令fast重新指向头节点</p>
<p><em>f</em>&#x3D;2<em>nb</em>，<em>s</em>&#x3D;<em>nb</em>，n是环的周长（根据<em>f</em>&#x3D;2<em>s</em>和<em>f</em>&#x3D;<em>s</em>+<em>nb</em>求出）</p>
<p>此指针和 <code>slow</code> 一起向前走 <code>a</code> 步后，两者在入口节点重合。那么从哪里走到入口节点需要 <em>a</em> 步？答案是链表头节点<code>head</code>。这样可以求出a</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                ptr = head</span><br><span class="line">                <span class="keyword">while</span> head != slow:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    head = head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="20：141-环形链表-双指针"><a href="#20：141-环形链表-双指针" class="headerlink" title="20：141. 环形链表 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">20：141. 环形链表 双指针</a></h2><p>这题简单些，不必用求出环的入口，用快慢指针证明有环即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow = fast = head  <span class="comment"># 乌龟和兔子同时从起点出发</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span>  <span class="comment"># 乌龟走一步</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span>  <span class="comment"># 兔子走两步</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:  <span class="comment"># 兔子追上乌龟（套圈），说明有环 这里也可以写isSlow</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 访问到了链表末尾，无环</span></span><br></pre></td></tr></table></figure>

<h2 id="21：139-单词拆分-dp"><a href="#21：139-单词拆分-dp" class="headerlink" title="21：139. 单词拆分 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">21：139. 单词拆分 </a>dp</h2><p>动态规划（回溯暂时没看懂）</p>
<p>dp表示前i位是否可用wordDict表示，返回dp[-1]</p>
<p>trick是如果dp[i]为True，s[i:j]又在worddict中，则dp[j]为true。ij都需要枚举</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:       </span><br><span class="line">        n=<span class="built_in">len</span>(s)</span><br><span class="line">        dp=[<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span>(dp[i] <span class="keyword">and</span> (s[i:j] <span class="keyword">in</span> wordDict)):</span><br><span class="line">                    dp[j]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="22：136-只出现一次的数字"><a href="#22：136-只出现一次的数字" class="headerlink" title="22：136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">22：136. 只出现一次的数字</a></h2><p>异或：n^n&#x3D;0, n^0&#x3D;n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ans ^= n</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="23：647-回文子串-dp"><a href="#23：647-回文子串-dp" class="headerlink" title="23：647. 回文子串 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">23：647. 回文子串</a> dp</h2><p>返回数目</p>
<p>用dp[i][j]表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。该定义j一定&gt;&#x3D;i，所以dp只填充右上部分</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li><p>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</p>
</li>
<li><p>情况二：下标i 与 j相差为1，例如aa，也是回文子串</p>
</li>
<li><p>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</p>
</li>
<li><p>根据递推关系的下标，需要从下到上，从左到右遍历</p>
</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504011640123.png" alt="image.png" style="zoom:33%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="literal">False</span>] * <span class="built_in">len</span>(s) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment">#注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt;= <span class="number">1</span>: <span class="comment">#情况一 和 情况二</span></span><br><span class="line">                        result += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]: <span class="comment">#情况三</span></span><br><span class="line">                        result += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>双指针法：一个元素可以作为中心点，两个元素也可以作为中心点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            res += <span class="variable language_">self</span>.extend(s, i, i, <span class="built_in">len</span>(s))</span><br><span class="line">            res += <span class="variable language_">self</span>.extend(s, i, i + <span class="number">1</span>, <span class="built_in">len</span>(s))<span class="comment">#这里最后会越界，但下面有边界校验了</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self, s, i, j, n</span>):<span class="comment">#ij是下标</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> s[i] == s[j]: <span class="comment">#先看作为中心的点相不相等</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="24：128-最长连续序列"><a href="#24：128-最长连续序列" class="headerlink" title="24：128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">24：128. 最长连续序列</a></h2><p>这里连续的意思是下一个数字要+1</p>
<p>O(n)所以不能排序</p>
<p>把nums放进集合（去除重复元素，因为重复元素不连续）</p>
<p>如果 x−1 在哈希集合中，则不以 x 为起点。为什么？因为以 x−1 为起点计算出的序列长度，一定比以 x 为起点计算出的序列长度要长！这样可以避免大量重复计算。比如 nums&#x3D;[3,2,4,5]，从 3 开始，我们可以找到 3,4,5 这个连续序列；而从 2 开始，我们可以找到 2,3,4,5 这个连续序列，一定比从 3 开始的序列更长。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        st = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> st:</span><br><span class="line">            <span class="keyword">if</span> x - <span class="number">1</span> <span class="keyword">in</span> st: <span class="comment">#这里剪枝了，注意不是while，只看前一个数</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            y = x + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> y <span class="keyword">in</span> st:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">            <span class="comment">#退出循环时是没找到的值y+1，与x的距离就是序列 的长度</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, y - x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="25：124-二叉树中的最大路径和-dfs"><a href="#25：124-二叉树中的最大路径和-dfs" class="headerlink" title="25：124. 二叉树中的最大路径和 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">25：124. 二叉树中的最大路径和 </a>dfs</h2><p>各值和，不一定经过根节点</p>
<ul>
<li><p>链：从下面的某个节点（不一定是叶子）到当前节点的路径。把这条链的节点值之和，作为 dfs 的返回值。如果节点值之和是负数，则返回 0。</p>
</li>
<li><p>直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的某个节点（不一定是叶子）到 node 的链的节点值之和，去更新答案的最大值</p>
</li>
</ul>
<p>这里dfs算的是链！</p>
<p>注意一定要写nonlocal，如果只是读取外层变量，不用nonlocal，但这里要修改，加入nonlocal用于在嵌套函数中修改外层函数的变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -inf <span class="comment">#在这里定义了子函数也能访问到</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l_val = dfs(node.left)</span><br><span class="line">            r_val = dfs(node.right)</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = <span class="built_in">max</span>(l_val + r_val + node.val, ans)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(l_val, r_val) + node.val, <span class="number">0</span>) <span class="comment">#这里返回的是链，并不是一定要经过node两侧的直径</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="26：322-零钱兑换-dp"><a href="#26：322-零钱兑换-dp" class="headerlink" title="26：322. 零钱兑换 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">26：322. 零钱兑换 </a>dp</h2><p>背包问题</p>
<p>因为求最小值所以用inf初始化dp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] + [inf] * amount</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> coins:<span class="comment">#n是当前硬币的值</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n, amount + <span class="number">1</span>):<span class="comment">#这里的范围是重点，相当于选中硬币n了，金额不可能小于n</span></span><br><span class="line">                dp[c] = <span class="built_in">min</span>(dp[c], dp[c - n] + <span class="number">1</span>)</span><br><span class="line">        ans = dp[amount]</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="27：494-目标和-dfs背包"><a href="#27：494-目标和-dfs背包" class="headerlink" title="27：494. 目标和 dfs背包"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">27：494. 目标和</a> dfs背包</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504012005283.png" alt="image-20250401200536138"></p>
<p>当s-|target|是奇数时直接返回0即可</p>
<p>dfs(i, c)表示用i个数字凑出背包容量的方案数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">sum</span>(nums) - <span class="built_in">abs</span>(target)</span><br><span class="line">        <span class="keyword">if</span> s &lt; <span class="number">0</span> <span class="keyword">or</span> s % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = s // <span class="number">2</span>  <span class="comment"># 背包容量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache  </span><span class="comment"># 缓存装饰器，避免重复计算</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 如果已经遍历完所有数字（i &lt; 0），检查是否恰好凑出 c</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> c &lt; nums[i]: <span class="comment">#选不了c</span></span><br><span class="line">                <span class="keyword">return</span> dfs(i - <span class="number">1</span>, c)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># - 不选：直接递归到 i-1，容量 c 不变</span></span><br><span class="line">            <span class="comment"># - 选：递归到 i-1，容量 c 减少 nums[i]</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i - <span class="number">1</span>, c) + dfs(i - <span class="number">1</span>, c - nums[i])</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="built_in">len</span>(nums) - <span class="number">1</span>, m)</span><br></pre></td></tr></table></figure>

<h2 id="28：461-汉明距离"><a href="#28：461-汉明距离" class="headerlink" title="28：461. 汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hamming-distance/">28：461. 汉明距离</a></h2><p>异或剩下不为1的数字就对应二进制位不同的位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> (x ^ y).bit_count()</span><br><span class="line">    <span class="comment">#或者写return bin(x ^ y).count(&#x27;1&#x27;) bin把整数转为二进制</span></span><br></pre></td></tr></table></figure>

<h2 id="29：448-找到所有数组中消失的数字"><a href="#29：448-找到所有数组中消失的数字" class="headerlink" title="29：448. 找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/">29：448. 找到所有数组中消失的数字</a></h2><p>列表查询的时间为on，集合只用o1，因为list是连续内存存储，set是哈希表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums = <span class="built_in">set</span>(nums)<span class="comment">#注意不加这句会超时，加了就保证数量小于N了</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="30：438-找到字符串中所有字母异位词-双指针"><a href="#30：438-找到字符串中所有字母异位词-双指针" class="headerlink" title="30：438. 找到字符串中所有字母异位词 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">30：438. 找到字符串中所有字母异位词</a> 双指针</h2><p>异位词：字母相同顺序不同</p>
<p>暴力法：以右侧下标做对比可以保证左侧数据早已加入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        cnt_p = Counter(p)  <span class="comment"># 统计 p 的每种字母的出现次数</span></span><br><span class="line">        cnt_s = Counter()  <span class="comment"># 统计 s 的长为 len(p) 的子串 s&#x27; 的每种字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            cnt_s[c] += <span class="number">1</span>  <span class="comment"># 右端点字母进入窗口</span></span><br><span class="line">            left = right - <span class="built_in">len</span>(p) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="number">0</span>:  <span class="comment"># 窗口长度不足 len(p)</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> cnt_s == cnt_p:  <span class="comment"># s&#x27; 和 p 的每种字母的出现次数都相同</span></span><br><span class="line">                ans.append(left)  <span class="comment"># s&#x27; 左端点下标加入答案</span></span><br><span class="line">            cnt_s[s[left]] -= <span class="number">1</span>  <span class="comment"># 左端点字母离开窗口</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>下面的方法是通过比较右侧值保证[left,right]内有cnt的内容</p>
<p> 1.维护一个有条件的滑动窗口； 2.右端点右移，导致窗口扩大，是不满足条件的罪魁祸首； 3.左端点右移目的是为了缩小窗口，重新满足条件</p>
<p>如果出现一个非p的字符，cnt[c]就为-1，left会移到right+1的位置，right下一个循环也是right+1。只有字符和次数都和p正好相同，left才不会移动，right进行右移扩大范围到长度为p</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        cnt = Counter(p)  <span class="comment"># 统计 p 的每种字母的出现次数</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            cnt[c] -= <span class="number">1</span>  <span class="comment"># 右端点字母进入窗口</span></span><br><span class="line">            <span class="keyword">while</span> cnt[c] &lt; <span class="number">0</span>:  <span class="comment"># 字母 c 太多了</span></span><br><span class="line">                cnt[s[left]] += <span class="number">1</span>  <span class="comment"># 左端点字母离开窗口</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> == <span class="built_in">len</span>(p):  <span class="comment"># s&#x27; 和 p 的每种字母的出现次数都相同</span></span><br><span class="line">                ans.append(left)  <span class="comment"># s&#x27; 左端点下标加入答案</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="31：437-路径总和-III-dfs"><a href="#31：437-路径总和-III-dfs" class="headerlink" title="31：437. 路径总和 III dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">31：437. 路径总和 III</a> dfs</h2><p>路径必须从父节点到子节点</p>
<p>前缀和+回溯&#x2F;DFS</p>
<p>dfs(node, presum)以node为最后节点的，节点和等于目标和的路径数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], presum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span>          <span class="comment"># 空节点，满足条件路径数为0</span></span><br><span class="line">            presum += node.val             <span class="comment"># 更新节点和</span></span><br><span class="line">            </span><br><span class="line">            path_cnt = presum_counts.get(presum - targetSum, <span class="number">0</span>)             <span class="comment"># 从哈希表中获取能和presum配对的前缀和个数</span></span><br><span class="line">            presum_counts[presum] = presum_counts.get(presum, <span class="number">0</span>) + <span class="number">1</span>        <span class="comment"># 将当前前缀和加入哈希表</span></span><br><span class="line">            path_cnt += dfs(node.left, presum) + dfs(node.right, presum)    <span class="comment"># 递归处理左右子树</span></span><br><span class="line">            presum_counts[presum] -= <span class="number">1</span>                                      <span class="comment"># 选择这个节点组成target的情况已经遍历完了，回溯方便下一个节点选择</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> path_cnt                                                 <span class="comment"># 返回总路径数</span></span><br><span class="line"></span><br><span class="line">        presum_counts = &#123;<span class="number">0</span> : <span class="number">1</span>&#125; <span class="comment"># 记录当前路径上出现的前缀和以及数量, 有一个默认的前缀和0</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)     <span class="comment"># 从根节点开始搜索</span></span><br></pre></td></tr></table></figure>

<h2 id="32：416-分割等和子集-dp"><a href="#32：416-分割等和子集-dp" class="headerlink" title="32：416. 分割等和子集 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">32：416. 分割等和子集</a> dp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">#dp[i][j]选择前i个数组成j的方案数，dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]</span></span><br><span class="line">        s = <span class="built_in">sum</span>(nums) </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> s % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = s // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (num + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="comment">#一般把0空出来比较好，避免下标越界问题</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> dp[n][num] == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="33：406-根据身高重建队列-sort"><a href="#33：406-根据身高重建队列-sort" class="headerlink" title="33：406. 根据身高重建队列 sort"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">33：406. 根据身高重建队列</a> sort</h2><p><code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>要把乱序的数组排列成实际身高的队形</p>
<p><strong>一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。</strong></p>
<p>这里首先按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。保证身高高的在前面，以及同样身高的排在前面的在前面（因为&gt;&#x3D;的人少），这样也保证在插队时不会有数量错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        people = <span class="built_in">sorted</span>(people, key = <span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))<span class="comment">#key可以指定字符串排序的方式</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= p[<span class="number">1</span>]:<span class="comment">#在最后加入，前面的人的个数是符合记录的</span></span><br><span class="line">                res.append(p)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(res) &gt; p[<span class="number">1</span>]:</span><br><span class="line">                res.insert(p[<span class="number">1</span>], p) <span class="comment">#插队，在p[1]的位置插入p</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="34：399-除法求值-dfs"><a href="#34：399-除法求值-dfs" class="headerlink" title="34：399. 除法求值 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/">34：399. 除法求值 dfs</a></h2><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>
<p>建立过渡变量，用图的形式构造双向边（dict:{}），值作为权重</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcEquation</span>(<span class="params">self, equations: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], values: <span class="type">List</span>[<span class="built_in">float</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]: </span><br><span class="line">        <span class="comment"># 构造图，equations的第一项除以第二项等于value里的对应值，第二项除以第一项等于其倒数（构造双向边）</span></span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (x, y), v <span class="keyword">in</span> <span class="built_in">zip</span>(equations, values):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> graph:</span><br><span class="line">                graph[x][y] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[x] = &#123;y: v&#125;</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> graph:</span><br><span class="line">                graph[y][x] = <span class="number">1</span>/v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[y] = &#123;x: <span class="number">1</span>/v&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs找寻从s到t的路径并返回结果叠乘后的边权重即结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, t</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t == s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[s].keys():</span><br><span class="line">                <span class="keyword">if</span> node == t:<span class="comment">#直接连接</span></span><br><span class="line">                    <span class="keyword">return</span> graph[s][node]</span><br><span class="line">                <span class="keyword">elif</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(node)  <span class="comment"># 添加到已访问避免重复遍历</span></span><br><span class="line">                    v = dfs(node, t)</span><br><span class="line">                    <span class="keyword">if</span> v != -<span class="number">1</span>:<span class="comment">#说明走通了，该场景并没有多路</span></span><br><span class="line">                        <span class="keyword">return</span> graph[s][node]*v</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逐个计算query的值</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> qs, qt <span class="keyword">in</span> queries:</span><br><span class="line">            visited = <span class="built_in">set</span>()<span class="comment">#记录遍历过的节点</span></span><br><span class="line">            res.append(dfs(qs, qt))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="35：394-字符串解码-stack"><a href="#35：394-字符串解码-stack" class="headerlink" title="35：394. 字符串解码 stack"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">35：394. 字符串解码</a> stack</h2><p>难点在于嵌套括号，以及数字可能也是多位数，用栈！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack, res, multi = [], <span class="string">&quot;&quot;</span>, <span class="number">0</span> <span class="comment">#stack存</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append([multi, res])<span class="comment">#存的是数字之前的字符串，不会变</span></span><br><span class="line">                res, multi = <span class="string">&quot;&quot;</span>, <span class="number">0</span> <span class="comment">#res开始存需要重复的字符串，同时可能继续遇到multi</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                cur_multi, last_res = stack.pop()</span><br><span class="line">                res = last_res + cur_multi * res</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="string">&#x27;9&#x27;</span>:<span class="comment">#数字不一定是个位数，所以*10</span></span><br><span class="line">                multi = multi * <span class="number">10</span> + <span class="built_in">int</span>(c)            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="36：347-前-K-个高频元素-heap"><a href="#36：347-前-K-个高频元素-heap" class="headerlink" title="36：347. 前 K 个高频元素 heap"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">36：347. 前 K 个高频元素</a> heap</h2><p>先获得频率，再创建小顶堆。如果比k个数的最小值大，就更换数据</p>
<p>heapq会自动把最小的frequency放在开头，因为封装了最小堆，从小到大排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        map_ = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            map_[num] = map_.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heap = []  <span class="comment">#从小到大排前k高的元素，是模块提供的小顶堆（大顶堆用负数模拟）</span></span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> map_.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k:</span><br><span class="line">                heapq.heappush(heap, (freq, num))</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#比较当前值和堆顶的频率最小值哪个大</span></span><br><span class="line">                <span class="keyword">if</span> freq &gt; heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                    heapq.heappushpop(heap, (freq, num))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            res.append(heapq.heappop(heap)[<span class="number">1</span>])<span class="comment">#注意加入的是值不是频率</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="37：338-比特位计数-dp"><a href="#37：338-比特位计数-dp" class="headerlink" title="37：338. 比特位计数 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/">37：338. 比特位计数</a> dp</h2><p>内置函数就是bin和count(‘1’)</p>
<p>动态规划：某个偶数肯定能由前面的某个数左移一位得到，如十进制6对应的二进制为110，由十进制3对应二进制11左移一位得到。<br>某个奇数肯定能由前面的某个数左移一位并加上1得到，如十进制7对应的二进制为111，是由十进制3对应二进制11左移一位为110并加一得到。利用位运算的性质</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dp=[<span class="number">0</span>]*(num+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            dp[i*<span class="number">2</span>]=dp[i]</span><br><span class="line">            <span class="keyword">if</span> i*<span class="number">2</span>+<span class="number">1</span>&lt;=num:</span><br><span class="line">                dp[i*<span class="number">2</span>+<span class="number">1</span>]=dp[i]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>

<h2 id="38：337-打家劫舍-III-dp-dfs"><a href="#38：337-打家劫舍-III-dp-dfs" class="headerlink" title="38：337. 打家劫舍 III dp+dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">38：337. 打家劫舍 III</a> dp+dfs</h2><p>对于选择了根,那么我们就不能选它的儿子了<br>如果没有选根，我们就可以任意选了(即选最大的那一个)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">self,root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]   <span class="comment">#列表[0]代表当前节点不偷带来的钱，列表[1]代表当前节点偷带来的钱</span></span><br><span class="line">        l=<span class="variable language_">self</span>.dp(root.left)   <span class="comment">#root的左节点[不偷][偷]带来的钱</span></span><br><span class="line">        r=<span class="variable language_">self</span>.dp(root.right)   <span class="comment">#root的右节点[不偷][偷]带来的钱</span></span><br><span class="line">        <span class="comment">#root节点不偷，则可以偷左右儿子节点，但不是一定要偷。取左儿子偷或不偷的最大值和右儿子偷或不偷的最大值；</span></span><br><span class="line">        <span class="comment">#root节点偷，则root节点值+左儿子不偷+右儿子不偷。</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">max</span>(l)+<span class="built_in">max</span>(r), root.val+l[<span class="number">0</span>]+r[<span class="number">0</span>]]  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="variable language_">self</span>.dp(root))  <span class="comment">#取root节点偷或不偷的最大值</span></span><br></pre></td></tr></table></figure>

<h2 id="39：121-买卖股票的最佳时机-trick"><a href="#39：121-买卖股票的最佳时机-trick" class="headerlink" title="39：121. 买卖股票的最佳时机 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">39：121. 买卖股票的最佳时机</a> trick</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span> <span class="comment">#存最大利润</span></span><br><span class="line">        minPrice = prices[<span class="number">0</span>]<span class="comment">#需要知道第i天之前，股票价格的最小值，作为买入价格</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - minPrice)</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, p)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="40：TODO-312-戳气球"><a href="#40：TODO-312-戳气球" class="headerlink" title="40：TODO 312. 戳气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/burst-balloons/">40：TODO 312. 戳气球</a></h2><h2 id="41-309-买卖股票的最佳时机含冷冻期-dp"><a href="#41-309-买卖股票的最佳时机含冷冻期-dp" class="headerlink" title="41:309. 买卖股票的最佳时机含冷冻期 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">41:309. 买卖股票的最佳时机含冷冻期</a> dp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp0 = <span class="number">0</span> <span class="comment"># 手里没股票，没有处于冷冻期</span></span><br><span class="line">        dp1 = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>) <span class="comment"># 手里没股票，并且处于冷冻期</span></span><br><span class="line">        dp2 = - prices[<span class="number">0</span>] <span class="comment"># 手里有股票</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            new_dp0 = <span class="built_in">max</span>(dp0, dp1)<span class="comment">#可能解冻了</span></span><br><span class="line">            new_dp1 = dp2 + prices[i] <span class="comment">#必然是昨天卖出了</span></span><br><span class="line">            new_dp2 = <span class="built_in">max</span>(dp2, dp0 - prices[i])<span class="comment">#可能0状态买入了</span></span><br><span class="line">            dp0, dp1, dp2 = new_dp0, new_dp1, new_dp2</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp0, dp1)<span class="comment">#一定是手里没有股票赚的钱最多，因此最后返回dp0和dp1的最大值</span></span><br></pre></td></tr></table></figure>

<h2 id="42：TODO301-删除无效的括号"><a href="#42：TODO301-删除无效的括号" class="headerlink" title="42：TODO301. 删除无效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-invalid-parentheses/">42：TODO301. 删除无效的括号</a></h2><h2 id="43：300-最长递增子序列-dp"><a href="#43：300-最长递增子序列-dp" class="headerlink" title="43：300. 最长递增子序列 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">43：300. 最长递增子序列</a> dp</h2><p>dp表示以 <em>nums</em>[<em>i</em>] 结尾的最长子序列长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)<span class="comment">#注意返回的是数组的最大值，并不是要以最后一个字符结尾</span></span><br></pre></td></tr></table></figure>

<h2 id="44：TODO297-二叉树的序列化与反序列化"><a href="#44：TODO297-二叉树的序列化与反序列化" class="headerlink" title="44：TODO297. 二叉树的序列化与反序列化"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">44：TODO297. 二叉树的序列化与反序列化</a></h2><h2 id="45：87-寻找重复数-二分"><a href="#45：87-寻找重复数-二分" class="headerlink" title="45：87. 寻找重复数 二分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">45：87. 寻找重复数 </a>二分</h2><p>已知数字都在[1, n]范围内，有n+1个整数，根据抽屉原理至少存在一个重复的整数</p>
<p>用二分法（知道最大最小界），数在范围里的数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_val = <span class="number">1</span> <span class="comment"># 所查找数字范围的最小值</span></span><br><span class="line">        max_val = <span class="built_in">len</span>(nums) <span class="comment"># 所查找数字范围的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> min_val &lt; max_val:</span><br><span class="line">            mid = (min_val + max_val) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 计数</span></span><br><span class="line">            cnt = <span class="built_in">sum</span>(min_val &lt;= num &lt;= mid <span class="keyword">for</span> num <span class="keyword">in</span> nums)<span class="comment">#数在这个区间里的数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cnt &gt; mid - min_val + <span class="number">1</span>: <span class="comment"># 个数超出范围长度，即存在重复数</span></span><br><span class="line">                max_val = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                min_val = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_val</span><br></pre></td></tr></table></figure>

<h2 id="46：283-移动零-双指针"><a href="#46：283-移动零-双指针" class="headerlink" title="46：283. 移动零 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">46：283. 移动零</a> 双指针</h2><p>因为要保持原数组非零元素的顺序，用双指针</p>
<p>将 <em>l</em> 移动到自身右侧第一个元素为 0 的位置，将 <em>r</em> 移动到 <em>l</em> 右侧第一个元素非 0 的位置，然后交换元素</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504012312239.png" alt="283_3.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> r == l <span class="keyword">or</span> nums[r] == <span class="number">0</span>: <span class="comment"># 优先检测 r，确保 r 在 l 右侧， 让 r 指向非0</span></span><br><span class="line">                r += <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">elif</span> nums[l] != <span class="number">0</span>: <span class="comment">#让l指向0</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[l] = nums[r]<span class="comment">#把0赋值为非0</span></span><br><span class="line">                nums[r] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="47：279-完全平方数-dp"><a href="#47：279-完全平方数-dp" class="headerlink" title="47：279. 完全平方数 dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">47：279. 完全平方数 </a>dp</h2><p>完全平方数满足n^2，用最少的完全平方数使和为n，也是DP</p>
<p>DFS都可以1：1翻译成递推，往往再进行空间优化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">10000</span></span><br><span class="line">f = [<span class="number">0</span>] + [inf] * N</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, isqrt(N) + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i * i, N + <span class="number">1</span>):</span><br><span class="line">        f[j] = <span class="built_in">min</span>(f[j], f[j - i * i] + <span class="number">1</span>)  <span class="comment"># 不选 vs 选</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>

<p>为什么f写在类的外面而不是函数内就不会超时：作为全局变量不用重复计算</p>
<p>在程序启动时，<code>f</code> 数组被计算一次（时间复杂度 <code>O(N√N)</code>），之后所有测试用例的 <code>numSquares(n)</code> 查询都是 <code>O(1)</code>。</p>
<h2 id="48：253-会议室II-堆"><a href="#48：253-会议室II-堆" class="headerlink" title="48：253.会议室II 堆"></a>48：253.会议室II 堆</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504012324238.jpeg" alt="img">时间间隔问题，按照会议的开始时间进行排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minMeetingRooms</span>(<span class="params">intervals</span>):</span><br><span class="line">    <span class="comment"># 如果会议安排列表为空，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化一个空的最小堆</span></span><br><span class="line">    free_rooms = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先根据会议的开始时间对会议进行排序</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将第一个会议的结束时间加入到最小堆中</span></span><br><span class="line">    <span class="comment"># 这表示目前我们有一个会议室被占用，直到这个时间点</span></span><br><span class="line">    heapq.heappush(free_rooms, intervals[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从第二个会议开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果当前会议的开始时间大于等于最小堆中的最早结束时间</span></span><br><span class="line">        <span class="comment"># 说明这个会议室可以被重复使用</span></span><br><span class="line">        <span class="comment"># 因此我们可以移除堆顶元素（最早结束的会议室）</span></span><br><span class="line">        <span class="keyword">if</span> i[<span class="number">0</span>] &gt;= free_rooms[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappop(free_rooms)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将当前会议的结束时间加入最小堆</span></span><br><span class="line">        <span class="comment"># 表示新增一个会议室，或是延续使用原会议室</span></span><br><span class="line">        heapq.heappush(free_rooms, i[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 堆中元素的数量，就是我们需要的会议室数量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(free_rooms)</span><br></pre></td></tr></table></figure>
<h2 id="49：240-搜索二维矩阵-II-trick"><a href="#49：240-搜索二维矩阵-II-trick" class="headerlink" title="49：240. 搜索二维矩阵 II trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">49：240. 搜索二维矩阵 II</a> trick</h2><p>类似二叉搜索树，3&#x2F;7这种左下角、右上角元素称为标志数flag，每次比较可以消除一行或一列</p>
<ul>
<li>若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。</li>
<li>若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</li>
</ul>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504012330016.png" alt="Picture1.png" style="zoom:33%;" />

<p>我们从左下角开始找：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        i, j = <span class="built_in">len</span>(matrix) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &gt; target: </span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="50：239-滑动窗口最大值"><a href="#50：239-滑动窗口最大值" class="headerlink" title="50：239. 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">50：239. 滑动窗口最大值</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        q = deque()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 移除不在窗口内的队首元素 保证q中的每个下标都没有超越窗口的左边界</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> q[<span class="number">0</span>] &lt; i - k + <span class="number">1</span>:</span><br><span class="line">                q.popleft()</span><br><span class="line">            <span class="comment"># 维护队列递减性质 如果当前元素大于队尾元素 则队尾元素出队 有可能把队列全清空</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)<span class="comment">#我不懂为啥当前的数字非得存进去，只和队尾比较一次不好吗（仔细想和维护top1/2的复杂性是一样的，这样写单调性更简单灵活，不是说非要有2个数）</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:<span class="comment">#其实除了最开始窗口小于k，后面每次都会有一个最大值</span></span><br><span class="line">                result.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>



<h2 id="51：22-括号生成-回溯"><a href="#51：22-括号生成-回溯" class="headerlink" title="51：22. 括号生成 回溯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">51：22. 括号生成</a> 回溯</h2><p>n为生成括号的对数</p>
<p>先左括号+让右小于左是为了保证括号组合有效</p>
<p>回溯模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足终止条件:</span><br><span class="line">        结果.append(路径.copy())  # 注意深拷贝</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        if 剪枝条件:  # 可选，提前跳过无效选择</span><br><span class="line">            continue</span><br><span class="line">        </span><br><span class="line">        做选择  # 将当前选择加入路径</span><br><span class="line">        backtrack(路径, 新选择列表)  # 递归</span><br><span class="line">        撤销选择  # 从路径中移除当前选择</span><br></pre></td></tr></table></figure>

<p>本题注意不等式的细节</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">S, left, right</span>):<span class="comment">#left,right指已使用的括号数量</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(S) == <span class="number">2</span> * n:<span class="comment">#总数量达到要求</span></span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(S))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:<span class="comment">#left表示左括号的数量</span></span><br><span class="line">                S.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                backtrack(S, left+<span class="number">1</span>, right)</span><br><span class="line">                S.pop()</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:<span class="comment">#保证括号有效</span></span><br><span class="line">                S.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                backtrack(S, left, right+<span class="number">1</span>)</span><br><span class="line">                S.pop()</span><br><span class="line"></span><br><span class="line">        backtrack([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="52：49-字母异位词分组dict"><a href="#52：49-字母异位词分组dict" class="headerlink" title="52：49. 字母异位词分组dict"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">52：49. 字母异位词分组</a>dict</h2><p>把输入数组中的字母异位词组合到一起</p>
<p>把字符串排序后字母异位词应该一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        d = defaultdict(<span class="built_in">list</span>) <span class="comment">#当访问不存在的key时，会创建空list作为该key的value。适用于分组</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            d[<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))].append(s)  <span class="comment"># sorted(s) 相同的字符串分到同一组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(d.values())</span><br></pre></td></tr></table></figure>

<h2 id="53：48-旋转图像-trick"><a href="#53：48-旋转图像-trick" class="headerlink" title="53：48. 旋转图像 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">53：48. 旋转图像</a> trick</h2><p>原地旋转二维矩阵，不采用额外的空间</p>
<p>如果用拷贝，记得用深拷贝！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 深拷贝 matrix -&gt; tmp，若是普通赋值，matrix变化了tmp也会变</span></span><br><span class="line">        tmp = copy.deepcopy(matrix)</span><br><span class="line">        <span class="comment"># 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp[i][j]</span><br></pre></td></tr></table></figure>

<p>原地修改时只用看左上角1&#x2F;4的部分，就可以实现全局修改</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202504021219478.png" alt="image-20250402121910315"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">                tmp = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i]</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j]</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i]</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp</span><br></pre></td></tr></table></figure>

<h2 id="54：46-全排列dfs"><a href="#54：46-全排列dfs" class="headerlink" title="54：46. 全排列dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">54：46. 全排列</a>dfs</h2><p>回溯算法：</p>
<p>终止条件：长度为len-1</p>
<p>递推参数：当前固定位x</p>
<p>递推工作：固定nums[i]作为当前位元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x == <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">                res.append(<span class="built_in">list</span>(nums))   <span class="comment"># 添加排列方案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x, <span class="built_in">len</span>(nums)):</span><br><span class="line">                nums[i], nums[x] = nums[x], nums[i]  <span class="comment"># 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">                dfs(x + <span class="number">1</span>)                           <span class="comment"># 开启固定第 x + 1 位元素</span></span><br><span class="line">                nums[i], nums[x] = nums[x], nums[i]  <span class="comment"># 恢复交换</span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="55：42-接雨水-trick"><a href="#55：42-接雨水-trick" class="headerlink" title="55：42. 接雨水 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">55：42. 接雨水 </a>trick</h2><p>res[i] &#x3D; min(l_max[i], r_max[i]) - height[i]：min是木桶效应，决定当前柱子i能承载的最高水位；减去height是因为柱子本身会占据一定高度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        l_max = [<span class="number">0</span>] * n</span><br><span class="line">        r_max = [<span class="number">0</span>] * n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算 l_max</span></span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            l_max[i] = <span class="built_in">max</span>(l_max[i-<span class="number">1</span>], height[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算 r_max</span></span><br><span class="line">        r_max[-<span class="number">1</span>] = height[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            r_max[i] = <span class="built_in">max</span>(r_max[i+<span class="number">1</span>], height[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算总雨水量</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res += <span class="built_in">min</span>(l_max[i], r_max[i]) - height[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="56：39-组合总和-回溯"><a href="#56：39-组合总和-回溯" class="headerlink" title="56：39. 组合总和 回溯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">56：39. 组合总和</a> 回溯</h2><p>dfs(i, left) i是当前选择的下标，left是剩余的数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, left: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 找到一个合法组合</span></span><br><span class="line">                ans.append(path.copy())<span class="comment">#必须写copy，不然ans所有组合都指向同一个path，这个path最终会被清空为[]</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(candidates) <span class="keyword">or</span> left &lt; candidates[i]:<span class="comment">#剪枝：下标不越界+left不能太小</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 不选candidates[i]</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 选candidates[i]</span></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            dfs(i, left - candidates[i])</span><br><span class="line">            path.pop()  <span class="comment"># 恢复现场</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="57：543-二叉树的直径-dfs"><a href="#57：543-二叉树的直径-dfs" class="headerlink" title="57：543. 二叉树的直径 dfs"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">57：543. 二叉树的直径</a> dfs</h2><p>求左右子树深度值的最大值</p>
<p>注意返回的是子树的链长</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            l_len = dfs(node.left) + <span class="number">1</span>  <span class="comment"># 左子树最大链长+1</span></span><br><span class="line">            r_len = dfs(node.right) + <span class="number">1</span>  <span class="comment"># 右子树最大链长+1</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans <span class="comment">#让外层函数的变量可以修改</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, l_len + r_len)  <span class="comment"># 两条链拼成路径</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l_len, r_len)  <span class="comment"># 当前子树最大链长</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="58：34-在排序数组中查找元素的第一个和最后一个位置-二分"><a href="#58：34-在排序数组中查找元素的第一个和最后一个位置-二分" class="headerlink" title="58：34. 在排序数组中查找元素的第一个和最后一个位置 二分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">58：34. 在排序数组中查找元素的第一个和最后一个位置 </a>二分</h2><p>递增的数组</p>
<p>开始位置和结束位置</p>
<p>闭区间的二分写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:   </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  </span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:<span class="comment">#这里等于也不能直接return，因为要找最左的target</span></span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 范围缩小到 [left, mid-1]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 范围缩小到 [mid+1, right]</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = <span class="variable language_">self</span>.lower_bound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]  <span class="comment"># nums 中没有 target</span></span><br><span class="line">        <span class="comment"># 如果 start 存在，那么 end 必定存在</span></span><br><span class="line">        end = <span class="variable language_">self</span>.lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span> <span class="comment">#非常巧妙，因为是递增数列</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>

<h2 id="59：33-搜索旋转排序数组-二分"><a href="#59：33-搜索旋转排序数组-二分" class="headerlink" title="59：33. 搜索旋转排序数组 二分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">59：33. 搜索旋转排序数组</a> 二分</h2><p>排序数组被旋转了，要找目标值</p>
<ul>
<li>思路：先找排序数组的最小值，知道目标值在哪一段，然后在那一段进行二分查找</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 153. 寻找旋转排序数组中的最小值（返回的是下标）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = -<span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 开区间 (-1, n-1)</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 开区间不为空</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[-<span class="number">1</span>]:<span class="comment">#和最后的值比</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有序数组中找 target 的下标</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 开区间不为空</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                right = mid  <span class="comment"># 范围缩小到 (left, mid)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid  <span class="comment"># 范围缩小到 (mid, right)</span></span><br><span class="line">        <span class="keyword">return</span> right <span class="keyword">if</span> nums[right] == target <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="variable language_">self</span>.findMin(nums)</span><br><span class="line">        <span class="keyword">if</span> target &gt; nums[-<span class="number">1</span>]:  <span class="comment"># target 在第一段</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.lower_bound(nums, -<span class="number">1</span>, i, target)  <span class="comment"># 开区间 (-1, i)</span></span><br><span class="line">        <span class="comment"># target 在第二段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.lower_bound(nums, i - <span class="number">1</span>, <span class="built_in">len</span>(nums), target)  <span class="comment"># 开区间 (i-1, n)</span></span><br></pre></td></tr></table></figure>

<h2 id="60：32-最长有效括号-标记-dp"><a href="#60：32-最长有效括号-标记-dp" class="headerlink" title="60：32. 最长有效括号 标记+dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">60：32. 最长有效括号</a> 标记+dp</h2><p>只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p>先遍历一遍字符串，用栈把左右括号进行匹配，然后计算连续1出现的最大次数即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = [] <span class="comment">#用于匹配括号</span></span><br><span class="line">        maxL = <span class="number">0</span> <span class="comment">#记录答案，最长有效括号子串</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        tmp = [<span class="number">0</span>] * n         <span class="comment">#标记字符串s</span></span><br><span class="line">        cur = <span class="number">0</span> <span class="comment">#中间变量，记录1出现次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    j = stack.pop()</span><br><span class="line">                    tmp[i], tmp[j] = <span class="number">1</span>,<span class="number">1</span>      <span class="comment">#匹配成功时标记    </span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> tmp:    <span class="comment">#计算连续1出现的最大次数</span></span><br><span class="line">            <span class="keyword">if</span> num:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:          <span class="comment">#遇到0时中断，进行对比，并重置</span></span><br><span class="line">                maxL = <span class="built_in">max</span>(cur, maxL)  </span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">        maxL = <span class="built_in">max</span>(cur,maxL) <span class="comment">#最后一次统计可能未终断，多做一次对比</span></span><br><span class="line">        <span class="keyword">return</span> maxL</span><br></pre></td></tr></table></figure>

<h2 id="61：31-下一个排列-trick"><a href="#61：31-下一个排列-trick" class="headerlink" title="61：31. 下一个排列 trick"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">61：31. 下一个排列 trick</a></h2><p>下一个排列是字典序更大的排列</p>
<p>最大的字典序是从左到右依次递减的，下一个是最小字典序</p>
<p>否则从右向左寻找第一个严格递减的位置i；然后从右向左寻找第一个严格小于该位置值的位置j；</p>
<p>将i右侧的所有值翻转：</p>
<p>1 2 1 4 2 i &#x3D; 2,j&#x3D;4 1 2 1 2 4 1 然后翻转 得到2 1 2 1 4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> nums == <span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">return</span> nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        i, j = n - <span class="number">2</span>, n - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> nums[i] &lt; nums[i + <span class="number">1</span>]:<span class="comment">#从右到左找第一个递减的位置i</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> nums[j] &gt; nums[i]:<span class="comment">#从右向左寻找第一个严格小于该位置值的位置j；</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]<span class="comment">#交换</span></span><br><span class="line"></span><br><span class="line">        left, right = i + <span class="number">1</span>, n - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="62：538-把二叉搜索树转换为累加树"><a href="#62：538-把二叉搜索树转换为累加树" class="headerlink" title="62：538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">62：538. 把二叉搜索树转换为累加树</a></h2><p>看不太懂题，但是先递归右边，再赋给中间，再递归左边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: TreeNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(node.right)  <span class="comment"># 递归右子树</span></span><br><span class="line">            <span class="comment"># 递归结束后，s 就等于右子树的所有节点值之和</span></span><br><span class="line">            <span class="keyword">nonlocal</span> s</span><br><span class="line">            s += node.val</span><br><span class="line">            node.val = s  <span class="comment"># 此时 s 就是 &gt;= node.val 的所有数之和</span></span><br><span class="line">            dfs(node.left)  <span class="comment"># 递归左子树</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="63：23-合并-K-个升序链表-堆"><a href="#63：23-合并-K-个升序链表-堆" class="headerlink" title="63：23. 合并 K 个升序链表 堆"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">63：23. 合并 K 个升序链表</a> 堆</h2><p>最小堆：这可以用最小堆实现。初始把所有链表的头节点入堆，然后不断弹出堆中最小节点 x，如果 x.next 不为空就加入堆中。循环直到堆为空。把弹出的节点按顺序拼接起来，就得到了答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode.__lt__ = <span class="keyword">lambda</span> a, b: a.val &lt; b.val  <span class="comment"># 让堆可以比较节点大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        cur = dummy = ListNode()  <span class="comment"># 哨兵节点，作为合并后链表头节点的前一个节点</span></span><br><span class="line">        h = [head <span class="keyword">for</span> head <span class="keyword">in</span> lists <span class="keyword">if</span> head]  <span class="comment"># 把所有非空链表的头节点入堆</span></span><br><span class="line">        heapify(h)  <span class="comment"># 堆化</span></span><br><span class="line">        <span class="keyword">while</span> h:  <span class="comment"># 循环直到堆为空</span></span><br><span class="line">            node = heappop(h)  <span class="comment"># 剩余节点中的最小节点</span></span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span>:  <span class="comment"># 下一个节点不为空</span></span><br><span class="line">                heappush(h, node.<span class="built_in">next</span>)  <span class="comment"># 下一个节点有可能是最小节点，入堆</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node  <span class="comment"># 把 node 添加到新链表的末尾</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>  <span class="comment"># 准备合并下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>  <span class="comment"># 哨兵节点的下一个节点就是新链表的头节点</span></span><br></pre></td></tr></table></figure>

<h2 id="64：560-和为-K-的子数组-前缀和"><a href="#64：560-和为-K-的子数组-前缀和" class="headerlink" title="64：560. 和为 K 的子数组 前缀和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">64：560. 和为 K 的子数组 </a>前缀和</h2><p>注意要求子数组是数组中连续的非空序列，所以要用前缀和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = s = <span class="number">0</span></span><br><span class="line">        cnt = defaultdict(<span class="built_in">int</span>)<span class="comment">#对于没有的key默认value为0</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># s[0]=0 单独统计</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            s += x <span class="comment">#s是前缀和</span></span><br><span class="line">            ans += cnt[s - k] <span class="comment">#ans+=cnt[-1]</span></span><br><span class="line">            cnt[s] += <span class="number">1</span> <span class="comment">#说明有一种方案达到和为s</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="65：21-合并两个有序链表-递推"><a href="#65：21-合并两个有序链表-递推" class="headerlink" title="65：21. 合并两个有序链表 递推"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">65：21. 合并两个有序链表</a> 递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1: <span class="keyword">return</span> list2  <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2: <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt;= list2.val:  <span class="comment"># 递归调用</span></span><br><span class="line">            list1.<span class="built_in">next</span> = <span class="variable language_">self</span>.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list2.<span class="built_in">next</span> = <span class="variable language_">self</span>.mergeTwoLists(list1, list2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> list2</span><br></pre></td></tr></table></figure>

<h2 id="66：20-有效的括号"><a href="#66：20-有效的括号" class="headerlink" title="66：20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">66：20. 有效的括号</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&quot;]&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;&#125;&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> st:</span><br><span class="line">                tmp = st.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp != <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> st <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="67：19-删除链表的倒数第-N-个结点-快慢指针"><a href="#67：19-删除链表的倒数第-N-个结点-快慢指针" class="headerlink" title="67：19.删除链表的倒数第 N 个结点 快慢指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">67：19.删除链表的倒数第 N 个结点</a> 快慢指针</h2><p>注意是倒数第n个，而不是正数第n个，所以slow才能找到倒数第一个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        fast = slow = dummy <span class="comment">#注意可以写连等</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="68：17-电话号码的字母组合-回溯"><a href="#68：17-电话号码的字母组合-回溯" class="headerlink" title="68：17. 电话号码的字母组合 回溯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">68：17. 电话号码的字母组合</a> 回溯</h2><p>符合回溯模板，for遍历选择，+letter写在参数里面了所以没有+ -的添加和移除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        phone = &#123;<span class="string">&#x27;2&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;3&#x27;</span>:[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;4&#x27;</span>:[<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;5&#x27;</span>:[<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;6&#x27;</span>:[<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;7&#x27;</span>:[<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;8&#x27;</span>:[<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;9&#x27;</span>:[<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]&#125;<span class="comment">#创建dict</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">conbination, nextdigit</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nextdigit) == <span class="number">0</span>:</span><br><span class="line">                res.append(conbination)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> phone[nextdigit[<span class="number">0</span>]]:</span><br><span class="line">                    backtrack(conbination + letter,nextdigit[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        backtrack(<span class="string">&#x27;&#x27;</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="69：15-三数之和-排序-双指针"><a href="#69：15-三数之和-排序-双指针" class="headerlink" title="69：15. 三数之和 排序+双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">69：15. 三数之和</a> 排序+双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                sum_ = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:<span class="comment">#关键是去除重复解</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="70：11-盛最多水的容器-双指针"><a href="#70：11-盛最多水的容器-双指针" class="headerlink" title="70：11. 盛最多水的容器 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">70：11. 盛最多水的容器</a> 双指针</h2><p><em>S</em>(<em>i</em>,<em>j</em>)&#x3D;<em>min</em>(<em>h</em>[<em>i</em>],<em>h</em>[<em>j</em>])×(<em>j</em>−<em>i</em>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[i] * (j - i))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(res, height[j] * (j - i))</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="71：10-正则表达式匹配-没懂"><a href="#71：10-正则表达式匹配-没懂" class="headerlink" title="71：10. 正则表达式匹配 没懂"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/regular-expression-matching/">71：10. 正则表达式匹配 没懂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(s) + <span class="number">1</span>, <span class="built_in">len</span>(p) + <span class="number">1</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n, <span class="number">2</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">2</span>] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] <span class="keyword">or</span> p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) \</span><br><span class="line">                           <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> <span class="keyword">else</span> \</span><br><span class="line">                           dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="72：5-最长回文子串"><a href="#72：5-最长回文子串" class="headerlink" title="72：5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">72：5. 最长回文子串</a></h2><p>使用双指针从中心往两边扩展</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">         <span class="comment"># 首先检查输入的字符串是否为空，如果为空则直接返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        start = end = <span class="number">0</span> <span class="comment">#记录最长的子串的节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">             <span class="comment"># 处理奇数长度的回文子串</span></span><br><span class="line">            left = right = i    <span class="comment">#以 s[i] 为中心，向两边扩展，直至左右字符不相等。</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            cur_len = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; end - start + <span class="number">1</span>:</span><br><span class="line">                start = left + <span class="number">1</span></span><br><span class="line">                end = right - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理偶数长度的回文子串</span></span><br><span class="line">            left, right = i, i+<span class="number">1</span>    <span class="comment">#以 s[i] 和 s[i+1] 为中心，向两边扩展，直至左右字符不相等。</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            cur_len = right - left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_len &gt; end - start + <span class="number">1</span>:</span><br><span class="line">                start = left + <span class="number">1</span></span><br><span class="line">                end = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="73：TODO4-寻找两个正序数组的中位数"><a href="#73：TODO4-寻找两个正序数组的中位数" class="headerlink" title="73：TODO4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">73：TODO4. 寻找两个正序数组的中位数</a></h2><h2 id="74：3-无重复字符的最长子串"><a href="#74：3-无重复字符的最长子串" class="headerlink" title="74：3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">74：3. 无重复字符的最长子串</a></h2><p>子串是连续的</p>
<p>滑动窗口+哈希表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        res = <span class="number">0</span> </span><br><span class="line">        i = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> dic:</span><br><span class="line">                i = <span class="built_in">max</span>(dic[s[j]], i) <span class="comment"># 更新左指针 i 保证指针不会往左跳</span></span><br><span class="line">            dic[s[j]] = j <span class="comment"># 更新哈希表记录，最新的值为s[j]的下标j</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i) <span class="comment"># 更新结果</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="75：2-两数相加-递推"><a href="#75：2-两数相加-递推" class="headerlink" title="75：2. 两数相加 递推"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">75：2. 两数相加</a> 递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode], carry=<span class="number">0</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            <span class="keyword">return</span> ListNode(carry) <span class="keyword">if</span> carry <span class="keyword">else</span> <span class="literal">None</span>  <span class="comment"># 如果进位了，就额外创建一个节点</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            l1, l2 = l2, l1  </span><br><span class="line">        s = carry + l1.val + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)  <span class="comment"># 节点值和进位加在一起</span></span><br><span class="line">        l1.val = s % <span class="number">10</span>  <span class="comment"># 直接修改原链表</span></span><br><span class="line">        l1.<span class="built_in">next</span> = <span class="variable language_">self</span>.addTwoNumbers(l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span>, s // <span class="number">10</span>)  <span class="comment"># 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1 <span class="comment">#把答案保存在l1中</span></span><br></pre></td></tr></table></figure>

<h2 id="76：79-单词搜索"><a href="#76：79-单词搜索" class="headerlink" title="76：79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">76：79. 单词搜索</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j, k</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; <span class="built_in">len</span>(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="built_in">len</span>(word) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            board[i][j] = <span class="string">&#x27;&#x27;</span> <span class="comment">#修改为空字符，表示元素已经访问过，防止搜索时重复访问</span></span><br><span class="line">            <span class="comment">#上下左右找下一个字符</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = word[k] <span class="comment">#回溯，恢复</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="77：114-二叉树展开为链表"><a href="#77：114-二叉树展开为链表" class="headerlink" title="77：114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">77：114. 二叉树展开为链表</a></h2><p>链表应该是先序遍历</p>
<p>头插法反过来了：右左中，倒着在插</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.flatten(root.right)</span><br><span class="line">        <span class="variable language_">self</span>.flatten(root.left)</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        root.right = <span class="variable language_">self</span>.head  <span class="comment"># 头插法，相当于链表的 root.next = head</span></span><br><span class="line">        <span class="variable language_">self</span>.head = root  <span class="comment"># 现在链表头节点是 root</span></span><br></pre></td></tr></table></figure>

<h2 id="78：621-任务调度器"><a href="#78：621-任务调度器" class="headerlink" title="78：621. 任务调度器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/task-scheduler/">78：621. 任务调度器</a></h2><p>假如 <strong>只有</strong> 任务 <code>A</code> 且出现了 <code>freq_A</code> 次，那么执行这些任务的最少时间是：<code>(freq_A - 1) * (n+1) + 1</code>.</p>
<p>假设有多种任务，且需要填充空闲，<code>A</code> 还是出现次数最多的任务。此时 <code>ans = (freq_A-1) * (n+1) + 1 + p</code> p 等于和 A 出现次数一致的数目。</p>
<p>first_freq就是出现次数最多的任务的执行次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leastInterval</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="built_in">str</span>], need: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, c = <span class="built_in">len</span>(tasks), Counter(tasks)</span><br><span class="line">        most = c.most_common() <span class="comment">#出现次数最多的任务</span></span><br><span class="line">        first_freq, cnt = most[<span class="number">0</span>][<span class="number">1</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(most)):</span><br><span class="line">            <span class="keyword">if</span> most[i][<span class="number">1</span>] == first_freq: cnt += <span class="number">1</span> <span class="comment">#因为most[i][1]只会&lt;=first_freq，&lt;时直接填补冻结，=时在最后加一步</span></span><br><span class="line">        res = (first_freq - <span class="number">1</span>) * (need+<span class="number">1</span>) + cnt </span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &gt;= n <span class="keyword">else</span> n <span class="comment">#这里也是有必要的，因为上面主要在处理有冻结的情况，如果res&lt;n说明其他任务不够填补冻结</span></span><br></pre></td></tr></table></figure>

<h2 id="79：617-合并二叉树"><a href="#79：617-合并二叉树" class="headerlink" title="79：617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">79：617. 合并二叉树</a></h2><p>合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> root1</span><br><span class="line">        <span class="keyword">return</span> TreeNode(root1.val + root2.val, <span class="comment">#合并后的新节点</span></span><br><span class="line">            <span class="variable language_">self</span>.mergeTrees(root1.left, root2.left),    <span class="comment"># 合并左子树</span></span><br><span class="line">            <span class="variable language_">self</span>.mergeTrees(root1.right, root2.right))  <span class="comment"># 合并右子树</span></span><br></pre></td></tr></table></figure>

<h2 id="80：105-从前序与中序遍历序列构造二叉树"><a href="#80：105-从前序与中序遍历序列构造二叉树" class="headerlink" title="80：105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">80：105. 从前序与中序遍历序列构造二叉树</a></h2><p>知道前序（中左右）和中序（左中右），然后递推</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:  <span class="comment"># 空节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left_size = inorder.index(preorder[<span class="number">0</span>])  <span class="comment"># 左子树的大小</span></span><br><span class="line">        left = <span class="variable language_">self</span>.buildTree(preorder[<span class="number">1</span>: <span class="number">1</span> + left_size], inorder[:left_size])</span><br><span class="line">        right = <span class="variable language_">self</span>.buildTree(preorder[<span class="number">1</span> + left_size:], inorder[<span class="number">1</span> + left_size:])</span><br><span class="line">        <span class="keyword">return</span> TreeNode(preorder[<span class="number">0</span>], left, right)</span><br></pre></td></tr></table></figure>

<h2 id="81：104-二叉树的最大深度"><a href="#81：104-二叉树的最大深度" class="headerlink" title="81：104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">81：104. 二叉树的最大深度</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l, r = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            l = <span class="variable language_">self</span>.maxDepth(root.left) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            r = <span class="variable language_">self</span>.maxDepth(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r)</span><br></pre></td></tr></table></figure>

<h2 id="82：102-二叉树的层序遍历"><a href="#82：102-二叉树的层序遍历" class="headerlink" title="82：102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">82：102. 二叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])<span class="comment">#创建队列并加入root</span></span><br><span class="line">        result = []<span class="comment">#记录结果的list</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []<span class="comment">#当前层的内容，可看作子数组</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="83：101-对称二叉树"><a href="#83：101-对称二叉树" class="headerlink" title="83：101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">83：101. 对称二叉树</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.compare(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">self, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#两个节点都不为空时</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#当前两个节点相等，就比较子节点的外侧和内侧</span></span><br><span class="line">        outside = <span class="variable language_">self</span>.compare(left.left, right.right)</span><br><span class="line">        inside = <span class="variable language_">self</span>.compare(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure>

<h2 id="84：98-验证二叉搜索树"><a href="#84：98-验证二叉搜索树" class="headerlink" title="84：98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">84：98. 验证二叉搜索树</a></h2><p>前序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], left=-inf, right=inf</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        x = root.val</span><br><span class="line">        <span class="keyword">return</span> left &lt; x &lt; right <span class="keyword">and</span> \</span><br><span class="line">               <span class="variable language_">self</span>.isValidBST(root.left, left, x) <span class="keyword">and</span> \</span><br><span class="line">               <span class="variable language_">self</span>.isValidBST(root.right, x, right)</span><br></pre></td></tr></table></figure>

<h2 id="85：96-不同的二叉搜索树"><a href="#85：96-不同的二叉搜索树" class="headerlink" title="85：96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">85：96. 不同的二叉搜索树</a></h2><p>f(3) &#x3D; f(0)*f(2) + f(1)*f(1) + f(2)*f(0)</p>
<p>f(n) &#x3D; Σf(i)*f(n-1-i)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        store = [<span class="number">1</span>,<span class="number">1</span>] <span class="comment">#f(0),f(1)</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> store[n]</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            s = m-<span class="number">1</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                count += store[i]*store[s-i]</span><br><span class="line">            store.append(count)</span><br><span class="line">        <span class="keyword">return</span> store[n]</span><br></pre></td></tr></table></figure>

<h2 id="86：94-二叉树的中序遍历"><a href="#86：94-二叉树的中序遍历" class="headerlink" title="86：94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">86：94. 二叉树的中序遍历</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            traverse(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            traverse(node.right)</span><br><span class="line">        traverse(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="87：TODO85-最大矩形"><a href="#87：TODO85-最大矩形" class="headerlink" title="87：TODO85. 最大矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/">87：TODO85. 最大矩形</a></h2><h2 id="88：TODO84-柱状图中最大的矩形"><a href="#88：TODO84-柱状图中最大的矩形" class="headerlink" title="88：TODO84. 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">88：TODO84. 柱状图中最大的矩形</a></h2><h2 id="89：1-两数之和"><a href="#89：1-两数之和" class="headerlink" title="89：1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">89：1. 两数之和</a></h2><p>只返回一种答案</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        record = <span class="built_in">dict</span>() <span class="comment">#python中map就是dict</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  </span><br><span class="line">            <span class="keyword">if</span> target - value <span class="keyword">in</span> record:<span class="comment">#寻找匹配的key</span></span><br><span class="line">                <span class="keyword">return</span> [index, record[target - value]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                record[value] = index <span class="comment">#key不重复</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h2 id="90：78-子集"><a href="#90：78-子集" class="headerlink" title="90：78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">90：78. 子集</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">i, tmp</span>):</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):<span class="comment">#回溯的for选择</span></span><br><span class="line">                helper(j + <span class="number">1</span>,tmp + [nums[j]] )</span><br><span class="line">        helper(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>

<h2 id="91：TODO76-最小覆盖子串"><a href="#91：TODO76-最小覆盖子串" class="headerlink" title="91：TODO76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">91：TODO76. 最小覆盖子串</a></h2><h2 id="92：75-颜色分类三指针"><a href="#92：75-颜色分类三指针" class="headerlink" title="92：75. 颜色分类三指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">92：75. 颜色分类</a>三指针</h2><p>维护三个指针 p0：指向 0 应该放置的位置；p0左边全是0, p0本身并不包括0</p>
<p>p2：指向 2 应该放置的位置；p2右边全是2, p2本身并不包括2</p>
<p>i：当前遍历位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        p0, i , p2 = <span class="number">0</span>,<span class="number">0</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= p2:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span> <span class="comment">#这里可以增加，因为p0和i都是从左边开始，nums[p0]一定是0/1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[i], nums[p2] = nums[p2], nums[i]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 注意：i 不增加，因为换过来的 nums[i] 还要检查</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="93：72-编辑距离"><a href="#93：72-编辑距离" class="headerlink" title="93：72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">93：72. 编辑距离</a></h2><p><code>dp[i][j]</code> 代表 <code>word1</code> 到 <code>i</code> 位置转换成 <code>word2</code> 到 <code>j</code> 位置需要最少步数</p>
<p>当 word1[i] &#x3D;&#x3D; word2[j]，dp[i][j] &#x3D; dp[i-1][j-1]；</p>
<p>当 word1[i] !&#x3D; word2[j]，dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1 + <span class="number">1</span>)] <span class="comment">#dp[0][0]为0，不用额外赋值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="94：70-爬楼梯"><a href="#94：70-爬楼梯" class="headerlink" title="94：70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">94：70. 爬楼梯</a></h2><p>#dp[n] &#x3D; dp[n - 1] + dp[n - 2]</p>
<p>​    #dp[1] &#x3D; 1</p>
<p>​    #dp[2] &#x3D; 2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>

<h2 id="95：581-最短无序连续子数组-双指针"><a href="#95：581-最短无序连续子数组-双指针" class="headerlink" title="95：581. 最短无序连续子数组 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">95：581. 最短无序连续子数组</a> 双指针</h2><p>单调性：右边的数永远大于左边的所有数，左边的数永远小于右边的所有数。</p>
<p>找到的是连续子数组，所以left&#x2F;right找到存在比左边数小的right和存在比右边数大的left</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findUnsortedSubarray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        left, right, min_num, max_num = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): <span class="comment">#正序遍历</span></span><br><span class="line">            <span class="keyword">if</span> n &lt; max_num:</span><br><span class="line">                right = i <span class="comment">#在右边的数小于自己左边的数时会得到right，不一定相邻</span></span><br><span class="line">            max_num = <span class="built_in">max</span>(max_num, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment">#倒序遍历</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; min_num: <span class="comment">#在左边的数大于自己右边的数时会得到right，不一定相邻</span></span><br><span class="line">                left = i</span><br><span class="line">            min_num = <span class="built_in">min</span>(min_num, nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> left == right <span class="keyword">else</span> right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="96：64-最小路径和"><a href="#96：64-最小路径和" class="headerlink" title="96：64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">96：64. 最小路径和</a></h2><p>找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self, grid: [[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j] <span class="comment">#朝右走</span></span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j] <span class="comment">#朝下走</span></span><br><span class="line">                <span class="keyword">else</span>: grid[i][j] = <span class="built_in">min</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j] <span class="comment">#朝右和朝下走</span></span><br><span class="line">        <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="97：62-不同路径"><a href="#97：62-不同路径" class="headerlink" title="97：62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">97：62. 不同路径</a></h2><p>dfs(i,j)表示从起点 (0,0) 走到 (<em>i</em>,<em>j</em>) 的路径数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="meta">        @cache  </span><span class="comment"># 缓存装饰器，避免重复计算 dfs 的结果（一行代码实现记忆化）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: <span class="comment">#这是因为呆在原地也算一种</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i - <span class="number">1</span>, j) + dfs(i, j - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dfs(m - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="98：56-合并区间"><a href="#98：56-合并区间" class="headerlink" title="98：56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">98：56. 合并区间</a></h2><p>按照左端点排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> p: p[<span class="number">0</span>])  <span class="comment"># 按照左端点从小到大排序</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> ans <span class="keyword">and</span> p[<span class="number">0</span>] &lt;= ans[-<span class="number">1</span>][<span class="number">1</span>]:  <span class="comment"># 可以合并</span></span><br><span class="line">                ans[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ans[-<span class="number">1</span>][<span class="number">1</span>], p[<span class="number">1</span>])  <span class="comment"># 更新右端点最大值</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 不相交，无法合并</span></span><br><span class="line">                ans.append(p)  <span class="comment"># 新的合并区间</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="99：55-跳跃游戏"><a href="#99：55-跳跃游戏" class="headerlink" title="99：55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">99：55. 跳跃游戏</a></h2><p>思路：尽可能到达最远的位置。最远能到达某个位置，就一定能到达它前面的任何位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        max_i = <span class="number">0</span>       <span class="comment">#初始化当前能到达最远的位置</span></span><br><span class="line">        <span class="keyword">for</span> i, jump <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):   <span class="comment">#i为当前位置，jump是当前位置的跳数</span></span><br><span class="line">            <span class="keyword">if</span> max_i &gt;= i <span class="keyword">and</span> i + jump &gt; max_i:  <span class="comment">#如果当前位置能到达，并且当前位置+跳数&gt;最远位置  </span></span><br><span class="line">                max_i = i + jump  <span class="comment">#更新最远能到达位置</span></span><br><span class="line">            <span class="comment"># 提前结束</span></span><br><span class="line">            <span class="keyword">if</span> max_i&lt; i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#i是最后一个下标</span></span><br></pre></td></tr></table></figure>

<h2 id="100：53-最大子数组和"><a href="#100：53-最大子数组和" class="headerlink" title="100：53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">100：53. 最大子数组和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#dp[i]=max(dp[i-1],0)+nums[i]</span></span><br><span class="line">        ans = -inf</span><br><span class="line">        dp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            dp = <span class="built_in">max</span>(dp, <span class="number">0</span>) + n</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>




        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E8%BD%AF%E4%BB%B6/"># 软件</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/03/15/%E7%8E%8B%E6%A0%91%E6%A3%AE%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%85%AC%E5%BC%80%E8%AF%BE%E7%AC%94%E8%AE%B0/">王树森推荐系统公开课笔记</a>
            
        </section>


    </article>
</div>


    <div id="gitalk-container"></div>
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'blog_comment',
        owner: 'lyxx2535',
        admin: 'lyxx2535',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Annie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | 2020 - 2025
            <br>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    Total visitors:
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;|&nbsp;


<span class="site-pv">
    Total views:
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

          </span>
    </div>
</footer>

    </div>
</body>

</html>