<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Annie">





<title>字节青训营AI方向笔记 | Annie&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Annie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Annie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">字节青训营AI方向笔记</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Annie</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">November 7, 2024&nbsp;&nbsp;22:57:46</a>
                        </span>
                    
                    
                        <span class="post-category">
                        分类:
                            
                                <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><a target="_blank" rel="noopener" href="https://juejin.cn/book/7387702347436130304?scrollMenuIndex=0">LangChain实战课</a></p>
<p>踩坑参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7433411854470496291">Langchain AI 练中学 踩坑记录(00-03) | 豆包MarsCode AI刷题在这几天的课程学习中，我在 - 掘金</a></p>
<h1 id="1-开篇词"><a href="#1-开篇词" class="headerlink" title="1. 开篇词"></a>1. 开篇词</h1><p>LangChain：以大模型为引擎的全新应用开发框架</p>
<p>作为一种专为开发基于语言模型的应用而设计的框架，通过LangChain，我们不仅可以通过API调用如 ChatGPT、GPT-4、Llama 2 等大型语言模型，还可以实现更高级的功能。</p>
<p>具备以下两个特性：</p>
<ol>
<li><strong>数据感知：</strong> 能够将语言模型与其他数据源连接起来，从而实现对更丰富、更多样化数据的理解和利用。</li>
<li><strong>具有代理性：</strong> 能够让语言模型与其环境进行交互，使得模型能够对其环境有更深入的理解，并能够进行有效的响应。</li>
</ol>
<p>因此，LangChain框架的设计目标，是使这种AI类型的应用成为可能，并帮助我们最大限度地释放大语言模型的潜能。</p>
<p>LangChain是一个基于大语言模型（LLMs）用于<strong>构建端到端语言模型应用</strong>的框架，它可以让开发者使用语言模型来实现各种复杂的任务，例如文本到图像的生成、文档问答、聊天机器人等。LangChain提供了一系列工具、套件和接口，可以简化创建由LLMs和聊天模型提供支持的应用程序的过程。</p>
<h2 id="应用-1：情人节玫瑰宣传语"><a href="#应用-1：情人节玫瑰宣传语" class="headerlink" title="应用 1：情人节玫瑰宣传语"></a><strong>应用 1：情人节玫瑰宣传语</strong></h2><p>第一步是安装三个包，通过 <code>pip install langchain</code> 来安装LangChain，通过 <code>pip install openai</code> 来安装OpenAI，还需要通过 <code>pip install langchain-openai</code> 以便在 LangChain 中使用 OpenAI 模型。</p>
<p>第二步，你还需要在OpenAI网站注册属于自己的<strong>OpenAI Key</strong>。（当然，LangChain也支持其他的开源大语言模型，但是推理效果没有GPT那么好，所以我们这个课程里面的大多数示例都是用OpenAI的GPT系列模型来完成。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI Key&#x27;这里因为没有token，用的是ChatOpenAI</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="comment">#llm = OpenAI(model_name=&quot;gpt-3.5-turbo-instruct&quot;,max_tokens=200) max_token限制API响应中最大返回的令牌（token）数量。在自然语言处理中，文本通常被分割成一系列的令牌，每个令牌可以是一个词或者一个子词。这里的max_tokens=200意味着API在生成回答时，最多使用200个令牌。</span></span><br><span class="line">llm = ChatOpenAI(model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>))</span><br><span class="line">text = llm.invoke(<span class="string">&quot;请给我写一句情人节红玫瑰的中文宣传语&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="应用2：海报文案生成器"><a href="#应用2：海报文案生成器" class="headerlink" title="应用2：海报文案生成器"></a><strong>应用2：海报文案生成器</strong></h2><blockquote>
<p><em>已经制作好了一批鲜花的推广海报，想为每一个海报的内容，写一两句话，然后post到社交平台上，以期图文并茂。</em></p>
</blockquote>
<p>gpt不能读图，所以用图像字幕生成</p>
<p>我们就用一段简单的代码实现上述功能。这段代码主要包含三个部分：</p>
<ol>
<li>初始化图像字幕生成模型（HuggingFace中的image-caption模型）。</li>
<li>定义LangChain图像字幕生成工具。</li>
<li>初始化并运行LangChain Agent（代理），这个Agent是OpenAI的大语言模型，会自动进行分析，调用工具，完成任务。</li>
</ol>
<p>不过，这段代码需要的包比较多。在运行这段代码之前，你需要先更新LangChain到最新版本，安装HuggingFace的Transformers库（开源大模型工具），并安装 Pillow（Python图像处理工具包）和 PyTorch（深度学习框架）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade langchain</span><br><span class="line">pip install transformers</span><br><span class="line">pip install pillow</span><br><span class="line">pip install torch torchvision torchaudio</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---- Part 0 导入所需要的类</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BlipProcessor, BlipForConditionalGeneration</span><br><span class="line"><span class="keyword">from</span> langchain.tools <span class="keyword">import</span> BaseTool</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent, AgentType</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- Part I 初始化图像字幕生成模型</span></span><br><span class="line"><span class="comment"># 指定要使用的工具模型（HuggingFace中的image-caption模型）</span></span><br><span class="line">hf_model = <span class="string">&quot;Salesforce/blip-image-captioning-large&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在初始化图像字幕生成模型...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化处理器和工具模型</span></span><br><span class="line"><span class="comment"># 预处理器将准备图像供模型使用</span></span><br><span class="line">processor = BlipProcessor.from_pretrained(hf_model)</span><br><span class="line"><span class="comment"># 然后我们初始化工具模型本身</span></span><br><span class="line">model = BlipForConditionalGeneration.from_pretrained(hf_model)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始化图像字幕生成模型成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- Part II 定义图像字幕生成工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageCapTool</span>(<span class="title class_ inherited__">BaseTool</span>):</span><br><span class="line">    name = <span class="string">&quot;Image captioner&quot;</span></span><br><span class="line">    description = <span class="string">&quot;使用该工具可以生成图片的文字描述，需要传入图片的URL.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self, url: <span class="built_in">str</span></span>): <span class="comment">#输入的url是待处理的图片</span></span><br><span class="line">        <span class="comment"># 下载图像并将其转换为PIL对象</span></span><br><span class="line">        image = Image.<span class="built_in">open</span>(requests.get(url, stream=<span class="literal">True</span>).raw).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">        <span class="comment"># 预处理图像 调用上面的预处理器</span></span><br><span class="line">        inputs = processor(image, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">        <span class="comment"># 生成字幕</span></span><br><span class="line">        out = model.generate(**inputs, max_new_tokens=<span class="number">20</span>)</span><br><span class="line">        <span class="comment"># 获取字幕</span></span><br><span class="line">        caption = processor.decode(out[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> caption</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_arun</span>(<span class="params">self, query: <span class="built_in">str</span></span>):<span class="comment">#表明不支持异步操作</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;This tool does not support async&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- PartIII 初始化并运行LangChain智能体</span></span><br><span class="line"><span class="comment"># 设置OpenAI的API密钥并初始化大语言模型（OpenAI的Text模型）</span></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"><span class="comment"># llm = OpenAI(temperature=0.2)</span></span><br><span class="line"><span class="comment"># 因为temperature=0.2代表模型拥有一定的随机性，所以大模型每次的推理过程生成的文案都不尽相同</span></span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">    model=os.environ.get(<span class="string">&quot;LLM_MODEL_4K_FUNCTION_CALL&quot;</span>),</span><br><span class="line">    temperature=<span class="number">0</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;初始化大语言模型成功&quot;</span>)</span><br><span class="line"><span class="comment"># 使用工具初始化智能体并运行</span></span><br><span class="line">tools = [ImageCapTool()] <span class="comment">#图像字幕生成工具类的实例化</span></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,</span><br><span class="line">    tools=tools,</span><br><span class="line">    llm=llm,</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">    handle_parsing_errors=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">img_url = <span class="string">&quot;https://lf3-static.bytednsdoc.com/obj/eden-cn/lkpkbvsj/ljhwZthlaukjlkulzlp/eec79e20058499.563190744f903.jpg&quot;</span></span><br><span class="line"><span class="comment"># agent.run(input=f&quot;&#123;img_url&#125;\n请创作合适的中文推广文案&quot;)</span></span><br><span class="line">agent.invoke(<span class="built_in">input</span>=<span class="string">f&quot;图片链接如下：<span class="subst">&#123;img_url&#125;</span>\n 请为这张图创作合适的中文推广文案&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202411080011952.png" alt="image-20241108001106800"></p>
<p>针对上面的鲜花图片，程序进入了AgentExecutor链，开始思考推理，并采取行动——调用Image Cationer工具，接收该工具给出的结果，并根据其返回的内容，再次进行思考推理，最后给出文案。</p>
<p>当然，这个过程中还有很多很多的细节，比如大模型是怎么思考的？LangChain调用大模型时传入的具体提示文本是什么？代理是什么？AgentExecutor Chain 是什么？它究竟是怎样调度工具的？你现在可能有很多的疑惑。</p>
<h1 id="2-Langchain系统安装和快速入门"><a href="#2-Langchain系统安装和快速入门" class="headerlink" title="2. Langchain系统安装和快速入门"></a>2. Langchain系统安装和快速入门</h1><p>可以<strong>将大语言模型想象成一个巨大的预测机器，其训练过程主要基于“猜词”</strong>：给定一段文本的开头，它的任务就是预测下一个词是什么。模型会根据大量的训练数据（例如在互联网上爬取的文本），试图理解词语和词组在语言中的用法和含义，以及它们如何组合形成意义。它会通过不断地学习和调整参数，使得自己的预测越来越准确。</p>
<ul>
<li>这种预测并不只基于词语的统计关系，还包括对上下文的理解，甚至有时能体现出对世界常识的认知</li>
<li>并不完全理解语言，它们没有人类的情感、意识或理解力。它们只是通过复杂的数学函数学习到的语言模式，一个概率模型来做预测，所以有时候它们会犯错误，或者生成不合理甚至偏离主题的内容</li>
</ul>
<p>LangChain 是一个全方位的、基于大语言模型这种预测能力的应用开发工具。支持Python和JavaScript两个开发版本。</p>
<ul>
<li>预构建链功能</li>
<li>模块化组件</li>
<li>LangChain 要与各种模型、数据存储库集成，比如说最重要的OpenAI的API接口，比如说开源大模型库HuggingFace Hub，再比如说对各种向量数据库的支持</li>
<li><a target="_blank" rel="noopener" href="https://github.com/langchain-ai/langchain">https://github.com/langchain-ai/langchain</a></li>
<li><strong>LangChain本质上就是对各种大模型提供的API的套壳，是为了方便我们使用这些API，搭建起来的一些框架、模块和接口。</strong></li>
</ul>
<h2 id="Chat模型和Text模型"><a href="#Chat模型和Text模型" class="headerlink" title="Chat模型和Text模型"></a>Chat模型和Text模型</h2><p>OpenAI：先得到API Key。TPM和RPM分别代表tokens-per-minute、requests-per-minute。也就是说，对于GPT-4，你通过API最多每分钟调用200次、传输40000个字节。</p>
<ul>
<li><p>Text Model，文本模型：OpenAI的Completions API已被废弃，被ChatCompletion接口替代，仅作示意（运行会报错，因为API废弃的原因）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_BASE_URL&quot;] = &#x27;OpenAI 的 API URL&#x27;</span></span><br><span class="line"></span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line">response = client.completions.create(</span><br><span class="line">    model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>),<span class="comment">#如&quot;gpt-3.5-turbo-instruct&quot;</span></span><br><span class="line">    temperature=<span class="number">0.5</span>,<span class="comment">#影响输出的随机性</span></span><br><span class="line">    max_tokens=<span class="number">100</span>,<span class="comment">#限制输出的最大长度，一个token可以是一个字、一个词或一个字符，取决于模型</span></span><br><span class="line">    prompt=<span class="string">&quot;请给我的花店起个名&quot;</span>,<span class="comment">#提示，输入的问题，要做什么</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.choices[<span class="number">0</span>].text.strip())<span class="comment">#choices是所有输出，一般就一项，strip去掉前后空格</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Chat Model，聊天模型。有两个专属于Chat模型的概念，一个是消息，一个是角色</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_BASE_URL&quot;] = &#x27;OpenAI 的 API URL&#x27;</span></span><br><span class="line"></span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># text = client.invoke(&quot;请给我写一句情人节红玫瑰的中文宣传语&quot;)</span></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">    model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>),</span><br><span class="line">    messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a creative AI.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;请给我的花店起个名&quot;</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    temperature=<span class="number">0.8</span>,</span><br><span class="line">    max_tokens=<span class="number">600</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.choices[<span class="number">0</span>].message.content)</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息就是传入模型的提示。此处的messages参数是一个列表，包含了多个消息。每个消息都有一个role（可以是system、user或assistant）和content（消息的内容）。系统消息设定了对话的背景（你是一个很棒的智能助手），然后用户消息提出了具体请求（请给我的花店起个名）。模型的任务是基于这些消息来生成回复。</p>
</li>
<li><p>在OpenAI的Chat模型中，system、user和assistant都是消息的角色。每一种角色都有不同的含义和作用。</p>
<ul>
<li>system：系统消息主要用于设定对话的背景或上下文。这可以帮助模型理解它在对话中的角色和任务。例如，你可以通过系统消息来设定一个场景，让模型知道它是在扮演一个医生、律师或者一个知识丰富的AI助手。系统消息通常在对话开始时给出。</li>
<li>user：用户消息是从用户或人类角色发出的。它们通常包含了用户想要模型回答或完成的请求。用户消息可以是一个问题、一段话，或者任何其他用户希望模型响应的内容。</li>
<li>assistant：助手消息是模型的回复。例如，在你使用API发送多轮对话中新的对话请求时，可以通过助手消息提供先前对话的上下文。然而，请注意在对话的最后一条消息应始终为用户消息，因为模型总是要回应最后这条用户消息。</li>
</ul>
</li>
<li><p>在使用Chat模型生成内容后，返回的<strong>响应</strong>，也就是response会包含一个或多个choices，每个choices都包含一个message。每个message也都包含一个role和content。role可以是system、user或assistant，表示该消息的发送者，content则包含了消息的实际内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;chatcmpl-2nZI6v1cW9E3Jg4w2Xtoql0M3XHfH&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;object&#x27;</span>: <span class="string">&#x27;chat.completion&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;created&#x27;</span>: <span class="number">1677649420</span>,</span><br><span class="line"> <span class="string">&#x27;model&#x27;</span>: <span class="string">&#x27;gpt-4&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;usage&#x27;</span>: &#123;<span class="string">&#x27;prompt_tokens&#x27;</span>: <span class="number">56</span>, <span class="string">&#x27;completion_tokens&#x27;</span>: <span class="number">31</span>, <span class="string">&#x27;total_tokens&#x27;</span>: <span class="number">87</span>&#125;,</span><br><span class="line"> <span class="string">&#x27;choices&#x27;</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&#x27;message&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;assistant&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;content&#x27;</span>: <span class="string">&#x27;你的花店可以叫做&quot;花香四溢&quot;。&#x27;</span></span><br><span class="line">     &#125;,</span><br><span class="line">    <span class="string">&#x27;finish_reason&#x27;</span>: <span class="string">&#x27;stop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;index&#x27;</span>: <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Chat模型 vs Text模型</strong></p>
<p>相较于Text模型，Chat模型的设计更适合处理对话或者多轮次交互的情况。这是因为它可以接受一个消息列表作为输入，而不仅仅是一个字符串。这个消息列表可以包含system、user和assistant的历史信息，从而在处理交互式对话时提供更多的上下文信息。</p>
<p>这种设计的主要优点包括：</p>
<ol>
<li>对话历史的管理：通过使用Chat模型，你可以更方便地管理对话的历史，并在需要时向模型提供这些历史信息。例如，你可以将过去的用户输入和模型的回复都包含在消息列表中，这样模型在生成新的回复时就可以考虑到这些历史信息。</li>
<li>角色模拟：通过system角色，你可以设定对话的背景，给模型提供额外的指导信息，从而更好地控制输出的结果。当然在Text模型中，你在提示中也可以为AI设定角色，作为输入的一部分。</li>
</ol>
<p>然而，对于简单的单轮文本生成任务，使用Text模型可能会更简单、更直接。例如，如果你只需要模型根据一个简单的提示生成一段文本，那么Text模型可能更适合。从上面的结果看，Chat模型给我们输出的文本更完善，是一句完整的话，而Text模型输出的是几个名字。这是因为ChatGPT经过了对齐（基于人类反馈的强化学习），输出的答案更像是真实聊天场景（Chat模型）。</p>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>在训练大语言模型时，模型可能会生成一些不符合人类期望的内容，例如：</p>
<ul>
<li>输出内容不准确、不相关或不完整。</li>
<li>生成有害、偏见性或不当的回答。</li>
<li>回答缺乏上下文理解，显得机械化或不自然。</li>
</ul>
<p>这些问题可能源于以下原因：</p>
<ul>
<li>模型的目标函数（如最大化语言概率）并不完全等同于人类的实际需求。</li>
<li>训练数据中可能存在偏差或噪声。</li>
<li>模型缺乏对复杂社会规范和人类价值观的理解。</li>
</ul>
<p>为了克服这些问题，研究者引入了“对齐”的概念，通过调整模型的行为，使其输出更加符合人类的期望。</p>
<p>对齐的一个关键实现方法是 <strong>基于人类反馈的强化学习（Reinforcement Learning from Human Feedback, RLHF）</strong> 。这种方法通过以下几个步骤来优化模型：</p>
<p><strong>(1) 收集人类反馈</strong></p>
<ul>
<li>在模型生成回答后，人类评估者会对模型的输出进行评分或排序，指出哪些回答更好、更符合人类期望。</li>
<li>例如，对于一个提问，模型可能生成多个候选答案，人类评估者会选择最自然、最有用的答案。</li>
</ul>
<p><strong>(2) 构建奖励模型</strong></p>
<ul>
<li>根据人类反馈，构建一个“奖励模型”（Reward Model），用于量化模型输出的质量。</li>
<li>奖励模型会为每个生成的回答分配一个分数，分数越高表示回答越符合人类期望。</li>
</ul>
<p><strong>(3) 强化学习优化</strong></p>
<ul>
<li>使用强化学习算法（如 PPO，Proximal Policy Optimization），让模型根据奖励模型的反馈逐步调整其行为。</li>
<li>在这个过程中，模型会学习如何生成更高质量、更符合人类期望的回答。</li>
</ul>
<h2 id="通过-LangChain-调用-Text-和-Chat-模型"><a href="#通过-LangChain-调用-Text-和-Chat-模型" class="headerlink" title="通过 LangChain 调用 Text 和 Chat 模型"></a>通过 LangChain 调用 Text 和 Chat 模型</h2><p>Text：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;你的Open API Key&#x27;</span></span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line">llm = OpenAI(  </span><br><span class="line">    model=<span class="string">&quot;gpt-3.5-turbo-instruct&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.8</span>,</span><br><span class="line">    max_tokens=<span class="number">60</span>,)</span><br><span class="line">response = llm.predict(<span class="string">&quot;请给我的花店起个名&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<p>Chat：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;你的Open API Key&#x27;</span></span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line">chat = ChatOpenAI(model=<span class="string">&quot;gpt-4&quot;</span>,</span><br><span class="line">                    temperature=<span class="number">0.8</span>,</span><br><span class="line">                    max_tokens=<span class="number">60</span>)</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> (</span><br><span class="line">    HumanMessage,</span><br><span class="line">    SystemMessage</span><br><span class="line">)</span><br><span class="line">messages = [</span><br><span class="line">    SystemMessage(content=<span class="string">&quot;你是一个很棒的智能助手&quot;</span>),</span><br><span class="line">    HumanMessage(content=<span class="string">&quot;请给我的花店起个名&quot;</span>)</span><br><span class="line">]</span><br><span class="line">response = chat(messages)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<p>无论是langchain.llms中的OpenAI（Text模型），还是langchain.chat_models中的ChatOpenAI中的ChatOpenAI（Chat模型），其返回的结果response变量的结构，都比直接调用OpenAI API来得简单一些。这是因为，LangChain已经对大语言模型的output进行了解析，只保留了响应中最重要的文字部分。</p>
<p>大语言模型可不是OpenAI一家独大，知名的大模型开源社群HugginFace网站上面提供了很多开源模型供你尝试使用。就在我写这节课的时候，Meta的Llama-2最受热捧，而且通义千问（Qwen）则刚刚开源。</p>
<p>两点提醒，一是这个领域进展太快，当你学这门课程的时候，流行的开源模型肯定变成别的了；二是这些新的开源模型，LangChain还不一定提供很好的接口，因此通过LangChain来使用最新的开源模型可能不容易。</p>
<p>不过LangChain作为最流行的LLM框架，新的开源模型被封装进来是迟早的事情。而且，LangChain的框架也已经定型，各个组件的设计都基本固定了。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>从今天的两个例子看起来，使用LangChain并不比直接调用OpenAI API来得省事？而且也仍然需要OpenAI API才能调用GPT家族模型。那么LangChain的核心价值在哪里？至少从这两个示例中没看出来。针对这个问题，你仔细思考思考。</li>
</ol>
<blockquote>
<h3 id="一、-抽象层的核心价值"><a href="#一、-抽象层的核心价值" class="headerlink" title="一、 抽象层的核心价值"></a>一、 <strong>抽象层的核心价值</strong></h3><ol>
<li><p><strong>组件解耦设计</strong></p>
<ul>
<li>当需要切换模型供应商时（如从GPT-3.5切换为Claude&#x2F;本地部署模型），使用LangChain只需修改1行配置，而直接调用API需要重构所有接口调用代码</li>
<li>示例对比：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LangChain切换模型</span></span><br><span class="line">llm = ChatOpenAI() → llm = ChatAnthropic()</span><br><span class="line">                              </span><br><span class="line"><span class="comment"># 直接API调用</span></span><br><span class="line">openai.ChatCompletion.create() → anthropic.Messages.create()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>标准化接口</strong></p>
<ul>
<li>统一了不同模型供应商的输入输出格式，这对需要同时使用多个LLM的混合系统尤为重要</li>
<li>提供统一的Prompt模板、记忆管理、输出解析等标准组件</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、-复杂场景优势"><a href="#二、-复杂场景优势" class="headerlink" title="二、 复杂场景优势"></a>二、 <strong>复杂场景优势</strong></h3><ol>
<li><p><strong>链式调用（Chains）</strong></p>
<ul>
<li>需要多步LLM交互时，LangChain提供预制工作流：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chain = LLMChain(llm=llm, prompt=prompt, output_parser=parser, memory=memory)</span><br></pre></td></tr></table></figure></li>
<li>直接调用API时需要手动维护上下文、解析输出、错误处理</li>
</ul>
</li>
<li><p><strong>记忆管理（Memory）</strong></p>
<ul>
<li>实现多轮对话时自动维护历史记录：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory = ConversationBufferMemory()</span><br><span class="line">memory.save_context(&#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;你好&quot;</span>&#125;, &#123;<span class="string">&quot;output&quot;</span>: <span class="string">&quot;你好！&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>直接API调用需自行设计历史记录存储和上下文窗口管理</li>
</ul>
</li>
<li><p><strong>工具集成（Tools）</strong></p>
<ul>
<li>快速构建具备外部能力的AI代理：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tools = [GoogleSearchTool(), CalculatorTool()]</span><br><span class="line">agent = initialize_agent(tools, llm, agent=<span class="string">&quot;chat-conversational-react-description&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、-企业级开发考量"><a href="#三、-企业级开发考量" class="headerlink" title="三、 企业级开发考量"></a>三、 <strong>企业级开发考量</strong></h3><ol>
<li><p><strong>可观测性</strong></p>
<ul>
<li>内置LangSmith监控平台集成，提供完整的调用链路追踪：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_TRACING_V2&quot;</span>] = <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>文档处理</strong></p>
<ul>
<li>复杂文档的自动化处理流水线：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loader = PyPDFLoader(<span class="string">&quot;report.pdf&quot;</span>)</span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter()</span><br><span class="line">vectorstore = FAISS.from_documents(pages, embeddings)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>生产部署</strong></p>
<ul>
<li>支持通过LangServe快速构建API服务：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_routes(app, chain, path=<span class="string">&quot;/chat&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、-成本效益分析"><a href="#四、-成本效益分析" class="headerlink" title="四、 成本效益分析"></a>四、 <strong>成本效益分析</strong></h3><table>
<thead>
<tr>
<th>维度</th>
<th>直接调用API</th>
<th>LangChain</th>
</tr>
</thead>
<tbody><tr>
<td>简单对话实现成本</td>
<td>低 ✅</td>
<td>中</td>
</tr>
<tr>
<td>复杂系统开发成本</td>
<td>高（需自建轮子）</td>
<td>低 ✅</td>
</tr>
<tr>
<td>多模型支持成本</td>
<td>高（每个模型不同接口）</td>
<td>低（统一接口）✅</td>
</tr>
<tr>
<td>长期维护成本</td>
<td>高</td>
<td>低 ✅</td>
</tr>
</tbody></table>
<hr>
<h3 id="五、-典型应用场景"><a href="#五、-典型应用场景" class="headerlink" title="五、 典型应用场景"></a>五、 <strong>典型应用场景</strong></h3><ol>
<li><p><strong>企业知识库系统</strong></p>
<ul>
<li>需要整合：文档加载 → 文本分割 → 向量存储 → 检索增强生成（RAG）</li>
<li>LangChain提供完整解决方案，直接API调用需自行实现全流程</li>
</ul>
</li>
<li><p><strong>AI Agent开发</strong></p>
<ul>
<li>需要动态组合：工具调用 → 记忆管理 → 决策判断</li>
<li>使用LangChain Agent框架可节省70%开发时间</li>
</ul>
</li>
<li><p><strong>混合模型系统</strong></p>
<ul>
<li>同时使用GPT-4（创意生成） + Claude（逻辑推理） + 本地模型（敏感数据处理）</li>
<li>LangChain的标准化接口使多模型协同更易实现</li>
</ul>
</li>
</ol>
<hr>
<h3 id="六、-演进趋势"><a href="#六、-演进趋势" class="headerlink" title="六、 演进趋势"></a>六、 <strong>演进趋势</strong></h3><ol>
<li><p><strong>LLM OS理念</strong></p>
<ul>
<li>LangChain正在演变为大模型操作系统，管理模型、工具、知识库等资源</li>
</ul>
</li>
<li><p><strong>可视化编排</strong></p>
<ul>
<li>最新版本支持通过LangGraph实现可视化工作流编排</li>
</ul>
</li>
<li><p><strong>企业级功能</strong></p>
<ul>
<li>即将推出的RBAC（基于角色的访问控制）、审计日志等企业特性</li>
</ul>
</li>
</ol>
<hr>
<h3 id="结论建议"><a href="#结论建议" class="headerlink" title="结论建议"></a>结论建议</h3><ul>
<li><strong>简单场景</strong>：直接API更合适（快速原型验证、单次对话）</li>
<li><strong>复杂系统</strong>：LangChain优势显著（需长期维护、多组件集成、企业级需求）</li>
<li><strong>学习曲线</strong>：初期投入学习LangChain会在后续开发中获得指数级回报</li>
</ul>
<p>建议在后续实践中尝试以下复杂场景，以更深入体会其价值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建一个具备长期记忆、网络搜索、文档检索能力的客服系统</span></span><br><span class="line">agent_executor = AgentExecutor(</span><br><span class="line">    agent=agent,</span><br><span class="line">    tools=tools,</span><br><span class="line">    memory=memory,</span><br><span class="line">    return_intermediate_steps=<span class="literal">True</span>,</span><br><span class="line">    handle_parsing_errors=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>LangChain支持的可绝不只有OpenAI模型，那么你能否试一试HuggingFace开源社区中的其它模型，看看能不能用。</li>
</ol>
<blockquote>
<p><strong>提示</strong>：你要选择Text-Generation、Text-Text Generation和Question-Answer这一类的文本生成式模型。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调用API的方式</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> HuggingFaceHub</span><br><span class="line">llm = HuggingFaceHub(model_id=<span class="string">&quot;bigscience/bloom-1b7&quot;</span>) </span><br><span class="line"><span class="comment">#本地部署</span></span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> HuggingFacePipeline</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, AutoTokenizer, pipeline</span><br><span class="line">model_id = <span class="string">&quot;IDEA-CCNL/Ziya-LLaMA-13B-v1&quot;</span>  <span class="comment"># 13B参数中文模型（需要至少24GB显存）</span></span><br><span class="line"><span class="comment"># 加载模型与分词器</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_id)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_id)</span><br><span class="line"><span class="comment"># 创建文本生成管道</span></span><br><span class="line">pipe = pipeline(</span><br><span class="line">    <span class="string">&quot;text-generation&quot;</span>,</span><br><span class="line">    model=model,</span><br><span class="line">    tokenizer=tokenizer,</span><br><span class="line">    device=<span class="number">0</span>,  <span class="comment"># 使用第一个GPU</span></span><br><span class="line">    max_new_tokens=<span class="number">128</span>,</span><br><span class="line">    temperature=<span class="number">0.8</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 转换为LangChain接口</span></span><br><span class="line">local_llm = HuggingFacePipeline(pipeline=pipe)</span><br><span class="line"><span class="comment"># 测试生成</span></span><br><span class="line">response = local_llm(<span class="string">&quot;如何用Python实现快速排序？步骤是：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">HuggingFaceHub API</th>
<th align="left">本地部署模型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">硬件需求</td>
<td align="left">无需本地GPU</td>
<td align="left">需要高性能GPU (&gt;16GB显存)</td>
</tr>
<tr>
<td align="left">响应速度</td>
<td align="left">依赖API延迟 (~1-5秒)</td>
<td align="left">本地计算延迟 (~0.1-3秒)</td>
</tr>
<tr>
<td align="left">可定制性</td>
<td align="left">受限</td>
<td align="left">完全控制模型参数</td>
</tr>
<tr>
<td align="left">隐私性</td>
<td align="left">数据需传输到第三方服务器</td>
<td align="left">完全本地运行</td>
</tr>
<tr>
<td align="left">典型应用场景</td>
<td align="left">原型验证&#x2F;小规模测试</td>
<td align="left">生产环境&#x2F;敏感数据处理</td>
</tr>
</tbody></table>
<ol>
<li>上面我提到了生成式模型，那么，大语言模型除了文本生成式模型，还有哪些类别的模型？比如说有名的Bert模型，是不是文本生成式的模型？</li>
</ol>
<blockquote>
<p><strong>提示</strong>：如果你没有太多NLP基础知识，建议你可以看一下我的专栏《<a href="https://link.juejin.cn/?target=https://time.geekbang.org/column/intro/100085501">零基础实战机器学习</a>》和公开课《<a href="https://link.juejin.cn/?target=https://time.geekbang.org/opencourse/videointro/100541201">ChatGPT和预训练模型实战课</a>》。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">代表模型</th>
<th align="left">核心能力</th>
<th align="left">典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>生成式模型</strong></td>
<td align="left">GPT-4、LLaMA</td>
<td align="left">文本续写、自由创作</td>
<td align="left">故事生成、代码编写</td>
</tr>
<tr>
<td align="left"><strong>判别式模型</strong></td>
<td align="left">BERT、RoBERTa</td>
<td align="left">文本理解、分类判断</td>
<td align="left">情感分析、文本分类</td>
</tr>
<tr>
<td align="left"><strong>编码器-解码器模型</strong></td>
<td align="left">T5、BART</td>
<td align="left">文本转换</td>
<td align="left">机器翻译、文本摘要</td>
</tr>
<tr>
<td align="left"><strong>混合架构模型</strong></td>
<td align="left">PALM、GLM</td>
<td align="left">多任务统一处理</td>
<td align="left">通用AI助手</td>
</tr>
<tr>
<td align="left"><strong>多模态模型</strong></td>
<td align="left">GPT-4V、Flamingo</td>
<td align="left">跨模态理解生成</td>
<td align="left">图文问答、视频描述生成</td>
</tr>
</tbody></table>
<h4 id="关键差异点："><a href="#关键差异点：" class="headerlink" title="关键差异点："></a>关键差异点：</h4><ol>
<li><strong>注意力机制</strong>：<ul>
<li>BERT：双向注意力（能看到全文上下文）</li>
<li>GPT：单向注意力（仅能看到左侧上下文）</li>
</ul>
</li>
<li><strong>训练目标</strong>：<ul>
<li>BERT：掩码语言建模（Masked Language Modeling）</li>
<li>GPT：自回归语言建模（Autoregressive Modeling）</li>
</ul>
</li>
<li><strong>输出能力</strong>：<ul>
<li>BERT：输出文本的语义表示（适合做特征提取）</li>
<li>GPT：直接生成连贯文本</li>
</ul>
</li>
</ol>
<h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><h4 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a><strong>生成式模型</strong></h4><ul>
<li><strong>优势</strong>：<ul>
<li>可生成新数据样本</li>
<li>能处理缺失数据（通过生成填补）</li>
<li>适合无监督&#x2F;半监督学习</li>
</ul>
</li>
<li><strong>劣势</strong>：<ul>
<li>训练复杂度高（需建模完整分布）</li>
<li>生成结果可能不精确（如GPT的”幻觉”问题）</li>
<li>计算资源消耗大（如训练175B参数的GPT-3）</li>
</ul>
</li>
</ul>
<h4 id="判别式模型"><a href="#判别式模型" class="headerlink" title="判别式模型"></a><strong>判别式模型</strong></h4><ul>
<li><strong>优势</strong>：<ul>
<li>训练效率高（直接优化目标函数）</li>
<li>分类准确率通常更高</li>
<li>推理速度快（如BERT的实时分类）</li>
</ul>
</li>
<li><strong>劣势</strong>：<ul>
<li>无法生成新数据</li>
<li>对数据不平衡敏感</li>
<li>需要清晰的任务定义（如固定类别标签）</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="3-用LangChain快速构建基于“易速鲜花”本地知识库的智能问答系统"><a href="#3-用LangChain快速构建基于“易速鲜花”本地知识库的智能问答系统" class="headerlink" title="3. 用LangChain快速构建基于“易速鲜花”本地知识库的智能问答系统"></a>3. 用LangChain快速构建基于“易速鲜花”本地知识库的智能问答系统</h1><p><strong>开发框架：</strong></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502251126770.jpeg" alt="基于数据源的文档问答系统开发框架"></p>
<ul>
<li>数据源（Data Sources）：数据可以有很多种，包括PDF在内的非结构化的数据（Unstructured Data）、SQL在内的结构化的数据（Structured Data），以及Python、Java之类的代码（Code）。在这个示例中，我们聚焦于对非结构化数据的处理。</li>
<li>大模型应用（Application，即LLM App）：以大模型为逻辑引擎，生成我们所需要的回答。</li>
<li>用例（Use-Cases）：大模型生成的回答可以构建出QA&#x2F;聊天机器人等系统。</li>
</ul>
<p><strong>核心实现机制：</strong> 这个项目的核心实现机制是下图所示的数据处理管道（Pipeline）。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502251129361.jpeg" alt="文档问答系统的数据处理管道"></p>
<ol>
<li>Loading：文档加载器把Documents <strong>加载</strong>为以LangChain能够读取的形式。</li>
<li>Splitting：文本分割器把Documents <strong>切分</strong>为指定大小的分割，我把它们称为“文档块”或者“文档片”。</li>
<li>Storage：将上一步中分割好的“文档块”以“嵌入”（Embedding）的形式<strong>存储</strong>到向量数据库（Vector DB）中，形成一个个的“嵌入片”。</li>
<li>Retrieval：应用程序从存储中<strong>检索</strong>分割后的文档（例如通过比较余弦相似度，找到与输入问题类似的嵌入片）。</li>
<li>Output：把问题和相似的嵌入片传递给语言模型（LLM），使用包含问题和检索到的分割的提示<strong>生成答案</strong>。</li>
</ol>
<h2 id="数据的准备和载入"><a href="#数据的准备和载入" class="headerlink" title="数据的准备和载入"></a>数据的准备和载入</h2><p>在这一步中，我们从 pdf、word 和 txt 文件中加载文本，然后将这些文本存储在一个列表中（documents &#x3D; []）。（注意：可能需要安装PyPDF、Docx2txt等库）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;你的Open AI API Key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.Load 导入Document Loaders</span></span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> PyPDFLoader</span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> Docx2txtLoader</span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> TextLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载Documents</span></span><br><span class="line">base_dir = <span class="string">&#x27;.\OneFlower&#x27;</span> <span class="comment"># 文档的存放目录</span></span><br><span class="line">documents = []</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(base_dir): </span><br><span class="line">    <span class="comment"># 构建完整的文件路径</span></span><br><span class="line">    file_path = os.path.join(base_dir, file)</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.pdf&#x27;</span>):</span><br><span class="line">        loader = PyPDFLoader(file_path)</span><br><span class="line">        documents.extend(loader.load())</span><br><span class="line">    <span class="keyword">elif</span> file.endswith(<span class="string">&#x27;.docx&#x27;</span>): </span><br><span class="line">        loader = Docx2txtLoader(file_path)</span><br><span class="line">        documents.extend(loader.load())</span><br><span class="line">    <span class="keyword">elif</span> file.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">        loader = TextLoader(file_path)</span><br><span class="line">        documents.extend(loader.load())</span><br></pre></td></tr></table></figure>

<h2 id="文本的分割"><a href="#文本的分割" class="headerlink" title="文本的分割"></a>文本的分割</h2><p>接下来需要将加载的文本分割成更小的块，以便进行嵌入和向量存储。这个步骤中，我们使用 LangChain中的RecursiveCharacterTextSplitter 来分割文本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.Split 将Documents切分成块以便后续进行嵌入和向量存储</span></span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">200</span>, chunk_overlap=<span class="number">10</span>)<span class="comment">#chunk_overlap 参数表示相邻两个文本块之间的重叠字符数。它的作用是保留一些上下文信息，避免因文本分割导致语义断裂</span></span><br><span class="line">chunked_documents = text_splitter.split_documents(documents)</span><br></pre></td></tr></table></figure>

<p>现在，我们的文档被切成了一个个200字符左右的文档块。这一步，是为把它们存储进下面的向量数据库做准备。</p>
<h2 id="向量数据库存储"><a href="#向量数据库存储" class="headerlink" title="向量数据库存储"></a>向量数据库存储</h2><p>词嵌入（Word Embedding）是自然语言处理和机器学习中的一个概念，它将文字或词语转换为一系列数字，通常是一个向量。简单地说，词嵌入就是一个为每个词分配的数字列表。这些数字不是随机的，而是捕获了这个词的含义和它在文本中的上下文。因此，语义上相似或相关的词在这个数字空间中会比较接近。  </p>
<p>举个例子，通过某种词嵌入技术，我们可能会得到： “国王” -&gt; [1.2, 0.5, 3.1, …] “皇帝” -&gt; [1.3, 0.6, 2.9, …] “苹果” -&gt; [0.9, -1.2, 0.3, …]  </p>
<p>从这些向量中，我们可以看到“国王”和“皇帝”这两个词的向量在某种程度上是相似的，而与“苹果”这个词相比，它们的向量则相差很大，因为这两个概念在语义上是不同的。  </p>
<p>词嵌入的优点是，它提供了一种将文本数据转化为计算机可以理解和处理的形式，同时保留了词语之间的语义关系。这在许多自然语言处理任务中都是非常有用的，比如文本分类、机器翻译和情感分析等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubaoEmbeddings</span>(BaseModel, Embeddings):</span><br><span class="line">    client: Ark = <span class="literal">None</span></span><br><span class="line">    api_key: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    model: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **data: <span class="type">Any</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(**data)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.api_key == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.api_key = os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>]</span><br><span class="line">        <span class="variable language_">self</span>.client = Ark(</span><br><span class="line">            base_url=os.environ[<span class="string">&quot;OPENAI_BASE_URL&quot;</span>],</span><br><span class="line">            api_key=<span class="variable language_">self</span>.api_key</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">embed_query</span>(<span class="params">self, text: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成输入文本的 embedding.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            texts (str): 要生成 embedding 的文本.</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            embeddings (List[float]): 输入文本的 embedding，一个浮点数值列表.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        embeddings = <span class="variable language_">self</span>.client.embeddings.create(model=<span class="variable language_">self</span>.model, <span class="built_in">input</span>=text)</span><br><span class="line">        <span class="keyword">return</span> embeddings.data[<span class="number">0</span>].embedding</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">embed_documents</span>(<span class="params">self, texts: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:<span class="comment">#得到list格式文档的embedding</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="variable language_">self</span>.embed_query(text) <span class="keyword">for</span> text <span class="keyword">in</span> texts]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">        arbitrary_types_allowed = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>向量数据库，也称为矢量数据库或者向量搜索引擎，是一种专门用于存储和搜索向量形式的数据的数据库。在众多的机器学习和人工智能应用中，尤其是自然语言处理和图像识别这类涉及大量非结构化数据的领域，将数据转化为高维度的向量是常见的处理方式。这些向量可能拥有数百甚至数千个维度，是对复杂的非结构化数据如文本、图像的一种数学表述，从而使这些数据能被机器理解和处理。然而，传统的关系型数据库在存储和查询如此高维度和复杂性的向量数据时，往往面临着效率和性能的问题。因此，向量数据库被设计出来以解决这一问题，它具备高效存储和处理高维向量数据的能力，从而更好地支持涉及非结构化数据处理的人工智能应用。</p>
<p>我们将这些分割后的文本转换成嵌入的形式，并将其存储在一个向量数据库中。在这个例子中，我们使用了 OpenAIEmbeddings 来生成嵌入，然后使用 Qdrant 这个向量数据库来存储嵌入（这里需要pip install qdrant-client）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.Store 将分割嵌入并存储在矢量数据库Qdrant中</span></span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Qdrant</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line">vectorstore = Qdrant.from_documents(</span><br><span class="line">    documents=chunked_documents,  <span class="comment"># 已分块的文档</span></span><br><span class="line">    embedding=DoubaoEmbeddings(</span><br><span class="line">        model=os.environ[<span class="string">&quot;EMBEDDING_MODELEND&quot;</span>],</span><br><span class="line">    ),  <span class="comment"># 用OpenAI的Embedding Model做嵌入</span></span><br><span class="line">    location=<span class="string">&quot;:memory:&quot;</span>,  <span class="comment"># in-memory 存储</span></span><br><span class="line">    collection_name=<span class="string">&quot;my_documents&quot;</span>, <span class="comment"># 指定collection_name</span></span><br><span class="line">)  </span><br></pre></td></tr></table></figure>

<p>目前，易速鲜花的所有内部文档，都以“文档块嵌入片”的格式被存储在向量数据库里面了。那么，我们只需要查询这个向量数据库，就可以找到大体上相关的信息了。</p>
<h2 id="相关信息的获取"><a href="#相关信息的获取" class="headerlink" title="相关信息的获取"></a>相关信息的获取</h2><p>当内部文档存储到向量数据库之后，我们需要根据问题和任务来提取最相关的信息。此时，信息提取的基本方式就是<strong>把问题也转换为向量</strong>，然后去和向量数据库中的各个向量进行比较，提取最接近的信息。</p>
<p>向量之间的比较通常基于向量的距离或者相似度。在高维空间中，常用的向量距离或相似度计算方法有欧氏距离和余弦相似度。</p>
<ul>
<li><strong>欧氏距离</strong>：这是最直接的距离度量方式，就像在二维平面上测量两点之间的直线距离那样。在高维空间中，两个向量的欧氏距离就是各个对应维度差的平方和的平方根。</li>
<li><strong>余弦相似度</strong>：在很多情况下，我们更关心向量的方向而不是它的大小。例如在文本处理中，一个词的向量可能会因为文本长度的不同，而在大小上有很大的差距，但方向更能反映其语义。余弦相似度就是度量向量之间方向的相似性，它的值范围在-1到1之间，值越接近1，表示两个向量的方向越相似。</li>
</ul>
<p>简单来说，关心数量等大小差异时用欧氏距离，关心文本等语义差异时用余弦相似度。</p>
<p>具体来说，欧氏距离度量的是绝对距离，它能很好地反映出向量的绝对差异。当我们关心数据的绝对大小，例如在物品推荐系统中，用户的购买量可能反映他们的偏好强度，此时可以考虑使用欧氏距离。同样，在数据集中各个向量的大小相似，且数据分布大致均匀时，使用欧氏距离也比较适合。</p>
<p>余弦相似度度量的是方向的相似性，它更关心的是两个向量的角度差异，而不是它们的大小差异。在处理文本数据或者其他高维稀疏数据的时候，余弦相似度特别有用。比如在信息检索和文本分类等任务中，文本数据往往被表示为高维的词向量，词向量的方向更能反映其语义相似性，此时可以使用余弦相似度。</p>
<p>在这里，我们正在处理的是文本数据，目标是建立一个问答系统，需要从语义上理解和比较问题可能的答案。因此，我建议使用余弦相似度作为度量标准。通过比较问题和答案向量在语义空间中的方向，可以找到与提出的问题最匹配的答案。</p>
<p>在这一步的代码部分，我们会创建一个聊天模型。然后需要创建一个 RetrievalQA 链，它是一个检索式问答模型，用于生成问题的答案。</p>
<p>在RetrievalQA 链中有下面两大重要组成部分。</p>
<ul>
<li>LLM是大模型，负责回答问题。</li>
<li>retriever（vectorstore.as_retriever()）负责根据问题检索相关的文档，找到具体的“嵌入片”。这些“嵌入片”对应的“文档块”就会作为知识信息，和问题一起传递进入大模型。本地文档中检索而得的知识很重要，因为<strong>从互联网信息中训练而来的大模型不可能拥有“易速鲜花”作为一个私营企业的内部知识</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Retrieval 准备模型和Retrieval链</span></span><br><span class="line"><span class="keyword">import</span> logging <span class="comment"># 导入Logging工具</span></span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI <span class="comment"># ChatOpenAI模型</span></span><br><span class="line"><span class="keyword">from</span> langchain.retrievers.multi_query <span class="keyword">import</span> MultiQueryRetriever <span class="comment"># MultiQueryRetriever工具</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA <span class="comment"># RetrievalQA链</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Logging</span></span><br><span class="line">logging.basicConfig()</span><br><span class="line">logging.getLogger(<span class="string">&#x27;langchain.retrievers.multi_query&#x27;</span>).setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个大模型工具 - OpenAI的GPT-3.5</span></span><br><span class="line">llm = ChatOpenAI(model_name=<span class="string">&quot;gpt-3.5-turbo&quot;</span>, temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个MultiQueryRetriever</span></span><br><span class="line">retriever_from_llm = MultiQueryRetriever.from_llm(retriever=vectorstore.as_retriever(), llm=llm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个RetrievalQA链</span></span><br><span class="line">qa_chain = RetrievalQA.from_chain_type(llm,retriever=retriever_from_llm)</span><br></pre></td></tr></table></figure>

<h2 id="生成回答并展示"><a href="#生成回答并展示" class="headerlink" title="生成回答并展示"></a>生成回答并展示</h2><p>这一步是问答系统应用的主要UI交互部分，这里会创建一个 Flask 应用（需要安装Flask包）来接收用户的问题，并生成相应的答案，最后通过 index.html 对答案进行渲染和呈现。</p>
<p>在这个步骤中，我们使用了之前创建的 RetrievalQA 链来获取相关的文档和生成答案。然后，将这些信息返回给用户，显示在网页上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Output 问答系统的UI实现</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template</span><br><span class="line">app = Flask(__name__)  <span class="comment"># Flask APP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="comment"># 接收用户输入作为问题</span></span><br><span class="line">        question = request.form.get(<span class="string">&quot;question&quot;</span>)</span><br><span class="line">        <span class="comment"># RetrievalQA链 - 读入问题，生成答案（调上面的qa_chain，属于RAG，检索+生成）</span></span><br><span class="line">        result = qa_chain(&#123;<span class="string">&quot;query&quot;</span>: question&#125;)</span><br><span class="line">        <span class="comment"># 把大模型的回答结果返回网页进行渲染</span></span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, result=result)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<p>总结：我们先把本地知识切片后做Embedding，存储到向量数据库中，然后把用户的输入和从向量数据库中检索到的本地知识传递给大模型，最终生成所想要的回答。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502251302779.jpeg" alt="img"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502251306944.jpeg" alt="img"></p>
<h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><p>请你用自己的话简述一下这个基于文档的QA（问答）系统的实现流程？</p>
<ol>
<li>加载PDF、Word、TXT文档，将长文本进行递归分割成文档块，存储到向量数据库作为本地知识库</li>
<li>RAG：检索+生成，GPT结合检索结果生成答案</li>
<li>交互界面：Flask框架</li>
</ol>
</li>
<li><p>LangChain支持很多种向量数据库，你能否用另一种常用的向量数据库Chroma来实现这个任务？</p>
<ol>
<li><pre><code class="python"># 3.Store 将分割嵌入并存储在矢量数据库Chroma中
from langchain_chroma import Chroma  # 替换Qdrant为Chroma

# 删除原Qdrant相关代码，替换为以下Chroma初始化逻辑
vectorstore = Chroma.from_documents(
    documents=chunked_documents,  # 已分块的文档
    embedding=DoubaoEmbeddings(   # 使用相同的自定义Embeddings
        model=os.environ[&quot;EMBEDDING_MODELEND&quot;],
    ),
    collection_name=&quot;my_documents&quot;,  # 集合名称（类似Qdrant）
    # persist_directory=&quot;./chroma_db&quot;  # 可选：持久化到磁盘（默认内存）
)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      | 原代码（Qdrant）               | 新代码（Chroma） | 说明                       |</span><br><span class="line">      | :----------------------------- | :--------------- | :------------------------- |</span><br><span class="line">      | 依赖 `qdrant-client`           | 依赖 `chromadb`  | Chroma更轻量，适合本地开发 |</span><br><span class="line">      | 内存存储 `location=&quot;:memory:&quot;` | 默认内存存储     | Chroma无需显式配置内存模式 |</span><br><span class="line">      | 需单独启动Qdrant服务           | 无需额外服务     | Chroma直接嵌入Python环境   |</span><br><span class="line"></span><br><span class="line">3. LangChain支持很多种大语言模型，你能否用HuggingFace网站提供的开源模型 [google/flan-t5-x1](https://link.juejin.cn/?target=https%3A%2F%2Fhuggingface.co%2Fgoogle%2Fflan-t5-xl) 代替GPT-3.5完成这个任务？</span><br><span class="line"></span><br><span class="line">   1. ### **改动点说明**</span><br><span class="line">      | 原代码（OpenAI）        | 新代码（HuggingFace） | 说明                          |</span><br><span class="line">      | ----------------------- | --------------------- | ----------------------------- |</span><br><span class="line">      | 依赖 `langchain-openai` | 依赖 `transformers`   | 需安装PyTorch/HuggingFace库   |</span><br><span class="line">      | 调用API                 | 本地加载模型          | 需GPU资源（建议至少16GB显存） |</span><br><span class="line">      | `ChatOpenAI`            | `HuggingFacePipeline` | 使用pipeline包装模型          |</span><br><span class="line"></span><br><span class="line">      ---</span><br><span class="line"></span><br><span class="line">      ### **完整修改后的代码（仅展示改动部分）**</span><br><span class="line">      ```python</span><br><span class="line">      # 4. Retrieval 准备模型和Retrieval链（替换为HuggingFace模型）</span><br><span class="line">      from transformers import AutoModelForSeq2SeqLM, AutoTokenizer, pipeline</span><br><span class="line">      from langchain.llms import HuggingFacePipeline  # 替换ChatOpenAI</span><br><span class="line">      </span><br><span class="line">      # 实例化HuggingFace模型 - flan-t5-xl</span><br><span class="line">      model_name = &quot;google/flan-t5-xl&quot;</span><br><span class="line">      tokenizer = AutoTokenizer.from_pretrained(model_name)</span><br><span class="line">      model = AutoModelForSeq2SeqLM.from_pretrained(model_name, device_map=&quot;auto&quot;)  # 自动分配GPU/CPU</span><br><span class="line">      </span><br><span class="line">      # 创建文本生成pipeline</span><br><span class="line">      flan_t5_pipeline = pipeline(</span><br><span class="line">          task=&quot;text2text-generation&quot;,</span><br><span class="line">          model=model,</span><br><span class="line">          tokenizer=tokenizer,</span><br><span class="line">          max_new_tokens=200,  # 控制生成长度</span><br><span class="line">          temperature=0.1      # 降低随机性</span><br><span class="line">      )</span><br><span class="line">      </span><br><span class="line">      # 将pipeline封装为LangChain的LLM对象</span><br><span class="line">      llm = HuggingFacePipeline(pipeline=flan_t5_pipeline)</span><br><span class="line">      </span><br><span class="line">      # 后续MultiQueryRetriever和RetrievalQA链代码无需修改！</span><br></pre></td></tr></table></figure>

---

### **配套操作步骤**
1. **安装依赖**  
   先卸载OpenAI依赖，安装HuggingFace相关包：
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall langchain-openai</span><br><span class="line">pip install transformers torch accelerate</span><br></pre></td></tr></table></figure>

2. **运行验证**  
   由于flan-t5-xl模型较大（约11GB），首次运行会自动下载：
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python app.py</span><br></pre></td></tr></table></figure>

---

### **关键差异对比**
| **特性**         | **flan-t5-xl**             | **GPT-3.5**      |
| ---------------- | -------------------------- | ---------------- |
| **模型类型**     | 开源文本生成模型           | 闭源Chat优化模型 |
| **部署方式**     | 本地加载（需GPU）          | API调用          |
| **上下文窗口**   | 512 tokens                 | 16k tokens       |
| **私有数据安全** | 完全本地化，无数据外传风险 | 依赖OpenAI服务器 |
| **推理速度**     | 较慢（依赖硬件性能）       | 快（云端优化）   |

---

### **需要关注的适配问题**
1. **提示词格式调整**  
   flan-t5-xl 是**纯文本生成模型**（非Chat模型），需调整问答模板：
   
   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始问题：&quot;易速鲜花的退货政策是什么？&quot;</span></span><br><span class="line"><span class="comment"># 输入模板应改为：</span></span><br><span class="line"><span class="string">&quot;请根据以下上下文回答问题：\n上下文：&#123;context&#125;\n问题：&#123;question&#125;&quot;</span></span><br></pre></td></tr></table></figure>
   
2. **性能优化建议**  
   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整分块策略（flan-t5-xl适合短上下文）</span></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    chunk_size=<span class="number">150</span>,  <span class="comment"># 减少分块长度</span></span><br><span class="line">    chunk_overlap=<span class="number">20</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

3. **量化加载（节省显存）**  
   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model = AutoModelForSeq2SeqLM.from_pretrained(</span><br><span class="line">    model_name,</span><br><span class="line">    device_map=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    load_in_8bit=<span class="literal">True</span>  <span class="comment"># 8位量化加载</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

---

### **效果验证**
访问 `http://localhost:5000` 提问测试：
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户问题：易速鲜花支持哪些支付方式？</span><br><span class="line">flan-t5-xl生成过程：</span><br><span class="line">1. 检索到《支付流程文档》中的&quot;支持支付宝、微信、银联&quot;</span><br><span class="line">2. 拼接提示词：&quot;请回答：易速鲜花支持哪些支付方式？上下文：...支持支付宝、微信、银联...&quot;</span><br><span class="line">3. 输出：&quot;根据文档，支持支付宝、微信和银联支付&quot;</span><br></pre></td></tr></table></figure>

---

### **适用场景建议**
- ✅ 适合对数据隐私要求高、需要完全本地化的场景
- ✅ 适合研究/实验性质项目
- ❌ 不适合需要长上下文理解的任务（如整文档摘要）
- ❌ 不适合实时性要求高的生产环境

通过这种替换，系统从依赖云端API转变为完全本地化运行，虽然牺牲了部分性能，但获得了更高的数据可控性。
</code></pre>
</li>
</ol>
</li>
</ol>
<h1 id="基础篇：深入6大组件"><a href="#基础篇：深入6大组件" class="headerlink" title="基础篇：深入6大组件"></a>基础篇：深入6大组件</h1><blockquote>
<p>LangChain中的具体组件包括：</p>
<ul>
<li><strong>模型（Models）</strong>，包含各大语言模型的LangChain接口和调用细节，以及输出解析机制。</li>
<li><strong>提示模板（Prompts）</strong>，使提示工程流线化，进一步激发大语言模型的潜力。</li>
<li><strong>数据检索（Indexes）</strong>，构建并操作文档的方法，接受用户的查询并返回最相关的文档，轻松搭建本地知识库。</li>
<li><strong>记忆（Memory）</strong>，通过短时记忆和长时记忆，在对话过程中存储和检索数据，让ChatBot记住你是谁。</li>
<li><strong>链（Chains）</strong>，是LangChain中的核心机制，以特定方式封装各种功能，并通过一系列的组合，自动而灵活地完成常见用例。</li>
<li><strong>代理（Agents）</strong>，是另一个LangChain中的核心机制，通过“代理”让大模型自主调用外部工具和内部工具，使强大的“智能化”自主Agent成为可能！<strong>你的</strong> <strong>App</strong> <strong>将产生自驱力！</strong></li>
</ul>
<p>这些组件是LangChain的基石，是赋予其智慧和灵魂的核心要素，它们相互协作，形成一个强大而灵活的系统。在基础篇中，我们将深入探索这些组件的工作原理和使用方法，并给出大量用例，夯实你对这些组件的理解和应用能力。</p>
</blockquote>
<h1 id="4-模型I-O：输入提示、调用模型、解析输出"><a href="#4-模型I-O：输入提示、调用模型、解析输出" class="headerlink" title="4. 模型I&#x2F;O：输入提示、调用模型、解析输出"></a>4. 模型I&#x2F;O：输入提示、调用模型、解析输出</h1><p>可以把对模型的使用过程拆解成三块，分别是<strong>输入提示</strong>（对应图中的Format）、<strong>调用模型</strong>（对应图中的Predict）和<strong>输出解析</strong>（对应图中的Parse）。这三块形成了一个整体，因此在LangChain中这个过程被统称为 <strong>Model I&#x2F;O</strong>（Input&#x2F;Output）。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502251507768.webp" alt="Model I/O：从输入到输出"></p>
<p>在模型 I&#x2F;O的每个环节，LangChain都为咱们提供了模板和工具，快捷地形成调用各种语言模型的接口。</p>
<ol>
<li><strong>提示模板</strong>：使用模型的第一个环节是把提示信息输入到模型中，你可以创建LangChain模板，根据实际需求动态选择不同的输入，针对特定的任务和应用调整输入。</li>
<li><strong>语言模型</strong>：LangChain允许你通过通用接口来调用语言模型。这意味着无论你要使用的是哪种语言模型，都可以通过同一种方式进行调用，这样就提高了灵活性和便利性。</li>
<li><strong>输出解析</strong>：LangChain还提供了从模型输出中提取信息的功能。通过输出解析器，你可以精确地从模型的输出中获取需要的信息，而不需要处理冗余或不相关的数据，更重要的是还可以把大模型给回的非结构化文本，转换成程序可以处理的结构化数据。</li>
</ol>
<h2 id="提示模板"><a href="#提示模板" class="headerlink" title="提示模板"></a>提示模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建原始模板 f-string 有占位符</span></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;您是一位专业的鲜花店文案撰写员。\n</span></span><br><span class="line"><span class="string">对于售价为 &#123;price&#125; 元的 &#123;flower_name&#125; ，您能提供一个吸引人的简短描述吗？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 根据原始模板创建LangChain提示模板 直接从一个字符串模板中创建一个PromptTemplate对象</span></span><br><span class="line">prompt = PromptTemplate.from_template(template)</span><br><span class="line"><span class="comment"># 打印LangChain提示模板的内容</span></span><br><span class="line"><span class="built_in">print</span>(prompt)</span><br></pre></td></tr></table></figure>

<p>PromptTemplate对象的内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input_variables=[<span class="string">&#x27;flower_name&#x27;</span>, <span class="string">&#x27;price&#x27;</span>] <span class="comment">#输入的变量</span></span><br><span class="line">output_parser=<span class="literal">None</span> partial_variables=&#123;&#125; <span class="comment">#输出解析器</span></span><br><span class="line">template=<span class="string">&#x27;/\n您是一位专业的鲜花店文案撰写员。</span></span><br><span class="line"><span class="string">\n对于售价为 &#123;price&#125; 元的 &#123;flower_name&#125; ，您能提供一个吸引人的简短描述吗？\n&#x27;</span></span><br><span class="line">template_format=<span class="string">&#x27;f-string&#x27;</span> <span class="comment">#模板的格式</span></span><br><span class="line">validate_template=<span class="literal">True</span> <span class="comment">#是否验证模板</span></span><br></pre></td></tr></table></figure>

<h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><p>LangChain中支持的模型有三大类。</p>
<ol>
<li>大语言模型（LLM） ，也叫Text Model，这些模型将文本字符串作为输入，并返回文本字符串作为输出。Open AI的text-davinci-003、Facebook的LLaMA、ANTHROPIC的Claude，都是典型的LLM。</li>
<li>聊天模型（Chat Model），主要代表Open AI的ChatGPT系列模型。这些模型通常由语言模型支持，但它们的 <strong>API 更加结构化</strong>。具体来说，这些模型将<strong>聊天消息列表</strong>作为输入，并返回聊天消息。</li>
<li>文本嵌入模型（Embedding Model），这些模型将文本作为输入并返回浮点数列表，也就是Embedding。而文本嵌入模型如OpenAI的text-embedding-ada-002，我们之前已经见过了。文本嵌入模型负责<strong>把文档存入向量数据库</strong>，和我们这里探讨的提示工程关系不大。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置OpenAI API Key</span></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入LangChain中的OpenAI模型接口</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI, ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line"><span class="comment"># model = OpenAI(model_name=&#x27;gpt-3.5-turbo-instruct&#x27;)</span></span><br><span class="line">model = ChatOpenAI(model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>))</span><br><span class="line"><span class="comment"># 输入提示</span></span><br><span class="line"><span class="built_in">input</span> = prompt.<span class="built_in">format</span>(flower_name=[<span class="string">&quot;玫瑰&quot;</span>], price=<span class="string">&quot;50&quot;</span>)<span class="comment">#该prompt也可以循环复用</span></span><br><span class="line"><span class="comment"># 得到模型的输出</span></span><br><span class="line">output = model.invoke(<span class="built_in">input</span>)</span><br><span class="line"><span class="comment"># 打印输出内容</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>

<p>LangChain相比直接使用Open AI API的优势：在提示模板中，只需定义一次模板，还整合了output_parser、template_format 以及是否需要validate_template等功能。还可以很方便地把程序切换到不同的模型，而不需要修改任何提示相关的代码。</p>
<p>因此，使用LangChain和提示模板的好处是：</p>
<ol>
<li>代码的可读性：使用模板的话，提示文本更易于阅读和理解，特别是对于复杂的提示或多变量的情况。</li>
<li>可复用性：模板可以在多个地方被复用，让你的代码更简洁，不需要在每个需要生成提示的地方重新构造提示字符串。</li>
<li>维护：如果你在后续需要修改提示，使用模板的话，只需要修改模板就可以了，而不需要在代码中查找所有使用到该提示的地方进行修改。</li>
<li>变量处理：如果你的提示中涉及到多个变量，模板可以自动处理变量的插入，不需要手动拼接字符串。</li>
<li>参数化：模板可以根据不同的参数生成不同的提示，这对于个性化生成文本非常有用。</li>
</ol>
<h2 id="输出解析"><a href="#输出解析" class="headerlink" title="输出解析"></a>输出解析</h2><p>通过LangChain的输出解析器来重构程序，让模型有能力生成结构化的回应，同时对其进行解析，直接将解析好的数据存入CSV文档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">本文件是【模型I/O：输入提示、调用模型、解析输出】章节的配套代码，课程链接：https://juejin.cn/book/7387702347436130304/section/7396583376915005480</span></span><br><span class="line"><span class="string">您可以点击最上方的“运行“按钮，直接运行该文件；更多操作指引请参考Readme.md文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 导入OpenAI Key</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入LangChain中的提示模板</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建提示模板</span></span><br><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;您是一位专业的鲜花店文案撰写员。</span></span><br><span class="line"><span class="string">对于售价为 &#123;price&#125; 元的 &#123;flower_name&#125; ，您能提供一个吸引人的简短描述吗？</span></span><br><span class="line"><span class="string">&#123;format_instructions&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过LangChain调用模型</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAI, ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line"><span class="comment"># model = OpenAI(model_name=&#x27;gpt-3.5-turbo-instruct&#x27;)</span></span><br><span class="line">model = ChatOpenAI(model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入结构化输出解析器和ResponseSchema</span></span><br><span class="line"><span class="keyword">from</span> langchain.output_parsers <span class="keyword">import</span> StructuredOutputParser, ResponseSchema</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义我们想要接收的响应模式</span></span><br><span class="line">response_schemas = [</span><br><span class="line">    ResponseSchema(name=<span class="string">&quot;description&quot;</span>, description=<span class="string">&quot;鲜花的描述文案&quot;</span>),</span><br><span class="line">    ResponseSchema(name=<span class="string">&quot;reason&quot;</span>, description=<span class="string">&quot;问什么要这样写这个文案&quot;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 创建输出解析器</span></span><br><span class="line">output_parser = StructuredOutputParser.from_response_schemas(response_schemas)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取格式指示</span></span><br><span class="line">format_instructions = output_parser.get_format_instructions()</span><br><span class="line"><span class="comment"># 根据模板创建提示，同时在提示中加入输出解析器的说明</span></span><br><span class="line">prompt = PromptTemplate.from_template(</span><br><span class="line">    prompt_template, partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">flowers = [<span class="string">&quot;玫瑰&quot;</span>, <span class="string">&quot;百合&quot;</span>, <span class="string">&quot;康乃馨&quot;</span>]</span><br><span class="line">prices = [<span class="string">&quot;50&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;20&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的DataFrame用于存储结果</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(columns=[<span class="string">&quot;flower&quot;</span>, <span class="string">&quot;price&quot;</span>, <span class="string">&quot;description&quot;</span>, <span class="string">&quot;reason&quot;</span>])  <span class="comment"># 先声明列名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> flower, price <span class="keyword">in</span> <span class="built_in">zip</span>(flowers, prices):</span><br><span class="line">    <span class="comment"># 根据提示准备模型的输入</span></span><br><span class="line">    <span class="built_in">input</span> = prompt.<span class="built_in">format</span>(flower_name=flower, price=price)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取模型的输出</span></span><br><span class="line">    output = model.invoke(<span class="built_in">input</span>)</span><br><span class="line">    <span class="comment"># 解析模型的输出（这是一个字典结构）</span></span><br><span class="line">    parsed_output = output_parser.parse(output.content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在解析后的输出中添加“flower”和“price”</span></span><br><span class="line">    parsed_output[<span class="string">&quot;flower&quot;</span>] = flower</span><br><span class="line">    parsed_output[<span class="string">&quot;price&quot;</span>] = price</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将解析后的输出添加到DataFrame中</span></span><br><span class="line">    df.loc[<span class="built_in">len</span>(df)] = parsed_output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(df.to_dict(orient=<span class="string">&quot;records&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存DataFrame到CSV文件</span></span><br><span class="line">df.to_csv(<span class="string">&quot;flowers_with_descriptions.csv&quot;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><p>请你用自己的理解，简述LangChain调用大语言模型来做应用开发的优势。</p>
<ol>
<li><strong>抽象层封装</strong>：LangChain封装了不同模型提供商的API差异，开发者无需关注底层API调用细节，只需统一接口调用（如<code>model.invoke()</code>）</li>
<li><strong>输入输出标准化</strong>：提供Prompt模板机制统一管理提示词，通过输出解析器（OutputParser）自动结构化模型输出，避免手工处理非结构化文本</li>
<li><strong>开发效率提升</strong>：内置的模板、解析器等组件大幅减少重复代码，例如示例中仅用<code>output_parser.parse()</code>即可将文本输出转为结构化字典</li>
<li><strong>模块化设计</strong>：各组件（模板、模型、解析器）可独立替换，如切换GPT-3到Claude只需修改模型初始化代码，业务逻辑无需改动</li>
</ol>
</li>
<li><p>在上面的示例中，format_instructions，也就是输出格式是怎样用output_parser构建出来的，又是怎样传递到提示模板中的？</p>
<ol>
<li><p><code>format_instructions</code>值为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The output should be a markdown code snippet formatted <span class="keyword">in</span> the following schema, including the leading <span class="keyword">and</span> trailing <span class="string">&quot;```json&quot;</span> <span class="keyword">and</span> <span class="string">&quot;```&quot;</span>:</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: string  // 鲜花的描述文案</span><br><span class="line">        <span class="string">&quot;reason&quot;</span>: string  // 问什么要这样写这个文案</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>通过partial_variables将格式说明注入模板</p>
</li>
</ol>
</li>
<li><p>加入了partial_variables，也就是输出解析器指定的format_instructions之后的提示，为什么能够让模型生成结构化的输出？你可以打印出这个提示，一探究竟。</p>
<ol>
<li><pre><code>您是一位专业的鲜花店文案撰写员。
对于售价为 50 元的 玫瑰 ，您能提供一个吸引人的简短描述吗？
The output should be a markdown code snippet formatted in the following schema, including the leading and trailing &quot;```json&quot; and &quot;```&quot;:

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> string  <span class="comment">// 鲜花的描述文案</span></span><br><span class="line">        <span class="attr">&quot;reason&quot;</span><span class="punctuation">:</span> string  <span class="comment">// 问什么要这样写这个文案</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>partial_variables在prompt后面加了一段话，这样的提示让模型清晰地知道需要以特定的 JSON 格式输出，并且明确了每个字段的含义和要求，从而生成结构化的输出。提示指出，模型需要根据一个schema来格式化输出文本，这个 schema 从 `&#96;&#96;json 开始，到 &#96;&#96;&#96; 结束。</p>
</li>
</ol>
</li>
<li><p>使用输出解析器后，调用模型时有没有可能仍然得不到所希望的输出？也就是说，模型有没有可能仍然返回格式不够完美的输出？</p>
<ol>
<li>有可能，跟模型特性、提示设计、语言生成任务复杂均有关</li>
</ol>
</li>
</ol>
<h1 id="5-提示工程（上）：用少样本FewShotTemplate和ExampleSelector创建应景文案"><a href="#5-提示工程（上）：用少样本FewShotTemplate和ExampleSelector创建应景文案" class="headerlink" title="5. 提示工程（上）：用少样本FewShotTemplate和ExampleSelector创建应景文案"></a>5. 提示工程（上）：用少样本FewShotTemplate和ExampleSelector创建应景文案</h1><p>这个提示框架中：</p>
<ul>
<li><strong>指令</strong>（Instuction）告诉模型这个任务大概要做什么、怎么做，比如如何使用提供的外部信息、如何处理查询以及如何构造输出。这通常是一个提示模板中比较固定的部分。一个常见用例是告诉模型“你是一个有用的XX助手”，这会让他更认真地对待自己的角色。</li>
<li><strong>上下文</strong>（Context）则充当模型的额外知识来源。这些信息可以手动插入到提示中，通过矢量数据库检索得来，或通过其他方式（如调用API、计算器等工具）拉入。一个常见的用例时是把从向量数据库查询到的知识作为上下文传递给模型。</li>
<li><strong>提示输入</strong>（Prompt Input）通常就是具体的问题或者需要大模型做的具体事情，这个部分和“指令”部分其实也可以合二为一。但是拆分出来成为一个独立的组件，就更加结构化，便于复用模板。这通常是作为变量，在调用模型之前传递给提示模板，以形成具体的提示。</li>
<li><strong>输出指示器</strong>（Output Indicator）标记要生成的文本的开始。这就像我们小时候的数学考卷，先写一个“解”，就代表你要开始答题了。如果生成 Python 代码，可以使用 “import” 向模型表明它必须开始编写 Python 代码（因为大多数 Python 脚本以import开头）。这部分在我们和ChatGPT对话时往往是可有可无的，当然LangChain中的代理在构建提示模板时，经常性的会用一个“Thought：”（思考）作为引导词，指示模型开始输出自己的推理（Reasoning）。</li>
</ul>
<p>LangChain中提供String（StringPromptTemplate）和Chat（BaseChatPromptTemplate）两种基本类型的模板，并基于它们构建了不同类型的提示模板：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502251708652.jpeg" alt="img"></p>
<h2 id="使用-PromptTemplate"><a href="#使用-PromptTemplate" class="headerlink" title="使用 PromptTemplate"></a>使用 PromptTemplate</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">你是业务咨询顾问。</span></span><br><span class="line"><span class="string">你给一个销售&#123;product&#125;的电商公司，起一个好的名字？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">prompt = PromptTemplate.from_template(template)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(product=<span class="string">&quot;鲜花&quot;</span>))<span class="comment">#补充占位符</span></span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;product&quot;</span>, <span class="string">&quot;market&quot;</span>],<span class="comment">#提示模板类的构造函数</span></span><br><span class="line">    template=<span class="string">&quot;你是业务咨询顾问。对于一个面向&#123;market&#125;市场的，专注于销售&#123;product&#125;的公司，你会推荐哪个名字？&quot;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(product=<span class="string">&quot;鲜花&quot;</span>, market=<span class="string">&quot;高端&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="使用-ChatPromptTemplate"><a href="#使用-ChatPromptTemplate" class="headerlink" title="使用 ChatPromptTemplate"></a>使用 ChatPromptTemplate</h2><p>OpenAI的Chat Model中的各种消息角色：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.ChatCompletion.create(</span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">  messages=[</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;You are a helpful assistant.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Who won the world series in 2020?&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;The Los Angeles Dodgers won the World Series in 2020.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Where was it played?&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消息必须是消息对象的数组，其中每个对象都有一个角色（系统、用户或助理）和内容。对话可以短至一条消息，也可以来回多次。  </p>
<p>通常，对话首先由系统消息格式化，然后是交替的用户消息和助理消息。  </p>
<p>系统消息有助于设置助手的行为。例如，你可以修改助手的个性或提供有关其在整个对话过程中应如何表现的具体说明。但请注意，系统消息是可选的，并且没有系统消息的模型的行为可能类似于使用通用消息，例如“你是一个有用的助手”。  </p>
<p>用户消息提供助理响应的请求或评论。  </p>
<p>助理消息存储以前的助理响应，但也可以由你编写以给出所需行为的示例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入聊天消息类模板</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> (</span><br><span class="line">    ChatPromptTemplate,</span><br><span class="line">    SystemMessagePromptTemplate,</span><br><span class="line">    HumanMessagePromptTemplate,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模板的构建</span></span><br><span class="line">template = <span class="string">&quot;你是一位专业顾问，负责为专注于&#123;product&#125;的公司起名。&quot;</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(template)<span class="comment">#系统</span></span><br><span class="line">human_template = <span class="string">&quot;公司主打产品是&#123;product_detail&#125;。&quot;</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)<span class="comment">#用户</span></span><br><span class="line">prompt_template = ChatPromptTemplate.from_messages(</span><br><span class="line">    [system_message_prompt, human_message_prompt]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化提示消息生成提示</span></span><br><span class="line">prompt = prompt_template.format_prompt(</span><br><span class="line">    product=<span class="string">&quot;鲜花装饰&quot;</span>, product_detail=<span class="string">&quot;创新的鲜花设计。&quot;</span></span><br><span class="line">).to_messages()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面调用模型，把提示消息传入模型，生成结果</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">chat = ChatOpenAI(</span><br><span class="line">    model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>),</span><br><span class="line">)</span><br><span class="line">result = chat(prompt)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h2 id="使用-FewShotPromptTemplate"><a href="#使用-FewShotPromptTemplate" class="headerlink" title="使用 FewShotPromptTemplate"></a>使用 FewShotPromptTemplate</h2><p>Zero-Shot：第一次听说就知道什么是毅力，“顿悟”，从知识积累和当前语境中就能够推知新词的涵义。聪明的大模型，某些情况下也是能够做到的。</p>
<p>Few-Shot（少样本）、One-Shot（单样本）和与之对应的 Zero-Shot（零样本）的概念都起源于机器学习。如何让机器学习模型在极少量甚至没有示例的情况下学习到新的概念或类别，对于许多现实世界的问题是非常有价值的，因为我们往往无法获取到大量的标签化数据。</p>
<p>提示工程（Prompt Engineering）中，Few-Shot 和 Zero-Shot 学习的概念也被广泛应用。</p>
<ul>
<li>在Few-Shot学习设置中，模型会被给予几个示例，以帮助模型理解任务，并生成正确的响应。</li>
<li>在Zero-Shot学习设置中，模型只根据任务的描述生成响应，不需要任何示例。</li>
</ul>
<p>GPT-3模型，作为一个大型的自我监督学习模型，通过提升模型规模，实现了出色的Few-Shot学习性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建一些示例</span></span><br><span class="line">samples = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;flower_type&quot;</span>: <span class="string">&quot;玫瑰&quot;</span>,<span class="comment">#花的类型</span></span><br><span class="line">        <span class="string">&quot;occasion&quot;</span>: <span class="string">&quot;爱情&quot;</span>,<span class="comment">#适合的场合</span></span><br><span class="line">        <span class="string">&quot;ad_copy&quot;</span>: <span class="string">&quot;玫瑰，浪漫的象征，是你向心爱的人表达爱意的最佳选择。&quot;</span>,<span class="comment">#对应的广告文案</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;flower_type&quot;</span>: <span class="string">&quot;康乃馨&quot;</span>,</span><br><span class="line">        <span class="string">&quot;occasion&quot;</span>: <span class="string">&quot;母亲节&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ad_copy&quot;</span>: <span class="string">&quot;康乃馨代表着母爱的纯洁与伟大，是母亲节赠送给母亲的完美礼物。&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;flower_type&quot;</span>: <span class="string">&quot;百合&quot;</span>,</span><br><span class="line">        <span class="string">&quot;occasion&quot;</span>: <span class="string">&quot;庆祝&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ad_copy&quot;</span>: <span class="string">&quot;百合象征着纯洁与高雅，是你庆祝特殊时刻的理想选择。&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;flower_type&quot;</span>: <span class="string">&quot;向日葵&quot;</span>,</span><br><span class="line">        <span class="string">&quot;occasion&quot;</span>: <span class="string">&quot;鼓励&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ad_copy&quot;</span>: <span class="string">&quot;向日葵象征着坚韧和乐观，是你鼓励亲朋好友的最好方式。&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&quot;pysqlite3&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.modules[<span class="string">&quot;sqlite3&quot;</span>] = sys.modules.pop(<span class="string">&quot;pysqlite3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建一个提示模板</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts.prompt <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">prompt_sample = PromptTemplate(<span class="comment">#模板跟示例一样</span></span><br><span class="line">    input_variables=[<span class="string">&quot;flower_type&quot;</span>, <span class="string">&quot;occasion&quot;</span>, <span class="string">&quot;ad_copy&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;鲜花类型: &#123;flower_type&#125;\n场合: &#123;occasion&#125;\n文案: &#123;ad_copy&#125;&quot;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(prompt_sample.<span class="built_in">format</span>(**samples[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建一个FewShotPromptTemplate对象</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts.few_shot <span class="keyword">import</span> FewShotPromptTemplate</span><br><span class="line"></span><br><span class="line">prompt = FewShotPromptTemplate(</span><br><span class="line">    examples=samples,<span class="comment">#这里放示例</span></span><br><span class="line">    example_prompt=prompt_sample,<span class="comment">#这里放提示模板</span></span><br><span class="line">    suffix=<span class="string">&quot;鲜花类型: &#123;flower_type&#125;\n场合: &#123;occasion&#125;&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;flower_type&quot;</span>, <span class="string">&quot;occasion&quot;</span>],</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(flower_type=<span class="string">&quot;野玫瑰&quot;</span>, occasion=<span class="string">&quot;爱情&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 把提示传递给大模型</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&quot;OPENAI_API_KEY&quot;] = &#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">model = ChatOpenAI(</span><br><span class="line">    model=os.environ.get(<span class="string">&quot;LLM_MODELEND&quot;</span>),</span><br><span class="line">)</span><br><span class="line">result = model(prompt.<span class="built_in">format</span>(flower_type=<span class="string">&quot;野玫瑰&quot;</span>, occasion=<span class="string">&quot;爱情&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>如果我们的示例很多，那么一次性把所有示例发送给模型是不现实而且低效的。另外，每次都包含太多的Token也会浪费流量（OpenAI是按照Token数来收取费用）。</p>
<p>LangChain给我们提供了示例选择器，来选择最合适的样本。（注意，因为示例选择器使用向量相似度比较的功能，此处需要安装向量数据库，这里我使用的是开源的Chroma，你也可以选择之前用过的Qdrant。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化示例选择器</span></span><br><span class="line">example_selector = SemanticSimilarityExampleSelector.from_examples(</span><br><span class="line">    samples,</span><br><span class="line">    DoubaoEmbeddings(</span><br><span class="line">        model=os.environ.get(<span class="string">&quot;EMBEDDING_MODELEND&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Chroma,</span><br><span class="line">    k=<span class="number">1</span>,<span class="comment">#根据语义相似性选择最相关的示例，如红玫瑰-&gt;玫瑰</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个使用示例选择器的FewShotPromptTemplate对象</span></span><br><span class="line">prompt = FewShotPromptTemplate(</span><br><span class="line">    example_selector=example_selector,</span><br><span class="line">    example_prompt=prompt_sample,</span><br><span class="line">    suffix=<span class="string">&quot;鲜花类型: &#123;flower_type&#125;\n场合: &#123;occasion&#125;&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;flower_type&quot;</span>, <span class="string">&quot;occasion&quot;</span>],</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(flower_type=<span class="string">&quot;红玫瑰&quot;</span>, occasion=<span class="string">&quot;爱情&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>在这个步骤中，它首先创建了一个SemanticSimilarityExampleSelector对象，这个对象可以根据语义相似性选择最相关的示例。然后，它创建了一个新的FewShotPromptTemplate对象，这个对象使用了上一步创建的选择器来选择最相关的示例生成提示。</p>
<p>然后，我们又用这个模板生成了一个新的提示，因为我们的提示中需要创建的是红玫瑰的文案，所以，示例选择器example_selector会根据语义的相似度（余弦相似度）找到最相似的示例，也就是“玫瑰”，并用这个示例构建了FewShot模板。</p>
<p>这样，我们就避免了把过多的无关模板传递给大模型，以节省Token的用量。</p>
<p>总的来说，提供示例对于解决某些任务至关重要，通常情况下，FewShot的方式能够显著提高模型回答的质量。不过，当少样本提示的效果不佳时，这可能表示模型在任务上的学习不足。在这种情况下，我们建议对模型进行微调或尝试更高级的提示技术。</p>
<h2 id="思考题-3"><a href="#思考题-3" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>如果你观察LangChain中的prompt.py中的PromptTemplate的实现代码，你会发现除了我们使用过的input_variables、template等初始化参数之外，还有template_format、validate_template等参数。举例来说，template_format可以指定除了f-string之外，其它格式的模板，比如jinja2。请你查看LangChain文档，并尝试使用这些参数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template_format: <span class="built_in">str</span> = <span class="string">&quot;f-string&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;The format of the prompt template. Options are: &#x27;f-string&#x27;, &#x27;jinja2&#x27;.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">validate_template: <span class="built_in">bool</span> = <span class="literal">True</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Whether or not to try validating the template.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>请你尝试使用PipelinePromptTemplate和自定义Template。  </li>
<li>请你构想一个关于鲜花店运营场景中客户服务对话的少样本学习任务。在这个任务中，模型需要根据提供的示例，学习如何解答客户的各种问题，包括询问花的价格、推荐鲜花、了解鲜花的保养方法等。最好是用ChatModel完成这个任务。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.chat <span class="keyword">import</span> (</span><br><span class="line">    ChatPromptTemplate,</span><br><span class="line">    SystemMessagePromptTemplate,</span><br><span class="line">    AIMessagePromptTemplate,</span><br><span class="line">    HumanMessagePromptTemplate)</span><br></pre></td></tr></table></figure>

<h1 id="6-提示工程（下）：用思维链和思维树提升模型思考质量"><a href="#6-提示工程（下）：用思维链和思维树提升模型思考质量" class="headerlink" title="6. 提示工程（下）：用思维链和思维树提升模型思考质量"></a>6. 提示工程（下）：用思维链和思维树提升模型思考质量</h1><h2 id="CoT"><a href="#CoT" class="headerlink" title="CoT"></a>CoT</h2><p>Few-Shot CoT 简单的在提示中提供了一些链式思考示例（Chain-of-Thought Prompting），足够大的语言模型的推理能力就能够被增强。简单说，就是给出一两个示例，然后在<strong>示例中写清楚推导的过程</strong>。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502261927072.png" alt="图片来源论文"></p>
<p>整体指导：你需要跟着下面的步骤一步步的推理。</p>
<ol>
<li>问题理解：首先，AI需要理解用户的需求。例如，用户可能会说：“今天要参加朋友的生日Party，想送束花祝福她。”我们可以给AI一个提示模板，里面包含示例：“<em><strong>遇到XX问题，我先看自己有</strong></em><em><strong>没有</strong></em><em><strong>相关知识，有的话，就提供答案；没有，就调用工具搜索，有了知识后再试图解决。</strong></em>”—— 这就是给了AI一个思维链的示例。  </li>
<li>信息搜索：接下来，AI需要搜索相关信息。例如，它可能需要查找哪些花最适合生日派对。  </li>
<li>决策制定：基于收集到的信息，AI需要制定一个决策。我们可以通过思维链让他详细思考决策的流程，先做什么后做什么。例如，我们可以给它一个示例：“<em><strong>遇到生日派对送花的情况，我先考虑用户的需求，然后查看鲜花的库存，最后决定推荐一些玫瑰和百合，因为这些花通常适合生日派对。</strong></em>”—— 那么有了生日派对这个场景做示例，大模型就能把类似的思维流程运用到其它场景。  </li>
<li>生成销售列表：最后，AI使用OutputParser生成一个销售列表，包括推荐的花和价格。</li>
</ol>
<p>图中的（d）示例非常非常有意思，在Zero-Shot CoT中，你只要简单地告诉模型“<strong>让我们一步步的思考（Let’s think step by step）</strong>”，模型就能够给出更好的答案！</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502261933142.png" alt="image-20250226193309979"></p>
<p>简单总结一下：Few-Shot CoT，指的就是在带有示例的提示过程中，加入思考的步骤，从而引导模型给出更好的结果。而Zero-Shot CoT，就是直接告诉模型要一步一步地思考，慢慢地推理。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量和API密钥</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;你的OpenAI API Key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建聊天模型</span></span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定 AI 的角色和目标</span></span><br><span class="line">role_template = <span class="string">&quot;你是一个为花店电商公司工作的AI助手, 你的目标是帮助客户根据他们的喜好做出明智的决定&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CoT 的关键部分，AI 解释推理过程，并加入一些先前的对话示例（Few-Shot Learning）</span></span><br><span class="line">cot_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">作为一个为花店电商公司工作的AI助手，我的目标是帮助客户根据他们的喜好做出明智的决定。 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我会按部就班的思考，先理解客户的需求，然后考虑各种鲜花的涵义，最后根据这个需求，给出我的推荐。</span></span><br><span class="line"><span class="string">同时，我也会向客户解释我这样推荐的原因。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 1:</span></span><br><span class="line"><span class="string">  人类：我想找一种象征爱情的花。</span></span><br><span class="line"><span class="string">  AI：首先，我理解你正在寻找一种可以象征爱情的花。在许多文化中，红玫瑰被视为爱情的象征，这是因为它们的红色通常与热情和浓烈的感情联系在一起。因此，考虑到这一点，我会推荐红玫瑰。红玫瑰不仅能够象征爱情，同时也可以传达出强烈的感情，这是你在寻找的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 2:</span></span><br><span class="line"><span class="string">  人类：我想要一些独特和奇特的花。</span></span><br><span class="line"><span class="string">  AI：从你的需求中，我理解你想要的是独一无二和引人注目的花朵。兰花是一种非常独特并且颜色鲜艳的花，它们在世界上的许多地方都被视为奢侈品和美的象征。因此，我建议你考虑兰花。选择兰花可以满足你对独特和奇特的要求，而且，兰花的美丽和它们所代表的力量和奢侈也可能会吸引你。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> ChatPromptTemplate, HumanMessagePromptTemplate, SystemMessagePromptTemplate</span><br><span class="line">system_prompt_role = SystemMessagePromptTemplate.from_template(role_template)</span><br><span class="line">system_prompt_cot = SystemMessagePromptTemplate.from_template(cot_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户的询问</span></span><br><span class="line">human_template = <span class="string">&quot;&#123;human_input&#125;&quot;</span></span><br><span class="line">human_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将以上所有信息结合为一个聊天提示</span></span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages([system_prompt_role, system_prompt_cot, human_prompt])</span><br><span class="line"></span><br><span class="line">prompt = chat_prompt.format_prompt(human_input=<span class="string">&quot;我想为我的女朋友购买一些花。她喜欢粉色和紫色。你有什么建议吗?&quot;</span>).to_messages()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收用户的询问，返回回答结果</span></span><br><span class="line">response = llm(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<h2 id="Tree-of-Thought（ToT）"><a href="#Tree-of-Thought（ToT）" class="headerlink" title="Tree of Thought（ToT）"></a>Tree of Thought（ToT）</h2><p>ToT是一种解决复杂问题的框架，它在需要多步骤推理的任务中，引导语言模型搜索一棵由连贯的语言序列（解决问题的中间步骤）组成的思维树，而不是简单地生成一个答案。ToT框架的核心思想是：让模型生成和评估其思维的能力，并将其与搜索算法（如广度优先搜索和深度优先搜索）结合起来，进行系统性地探索和验证。</p>
<p>和CoT相比就是有更具体的思维步骤（像深度思考）</p>
<p>ToT 框架为<strong>每个任务定义具体的思维步骤和每个步骤的候选项数量</strong>。例如，要解决一个数学推理任务，先把它分解为3个思维步骤，并为每个步骤提出多个方案，并保留最优的5个候选方案。然后在多条思维路径中搜寻最优的解决方案。</p>
<p>下面我们应用ToT的思想，给出一个鲜花运营方面的示例。</p>
<blockquote>
<p>假设一个顾客在鲜花网站上询问：“我想为我的妻子购买一束鲜花，但我不确定应该选择哪种鲜花。她喜欢淡雅的颜色和花香。”  </p>
<p>AI（使用ToT框架）：  </p>
<p><strong>思维步骤1</strong>：理解顾客的需求。</p>
<p>顾客想为妻子购买鲜花。</p>
<p>顾客的妻子喜欢淡雅的颜色和花香。  </p>
<p><strong>思维步骤2</strong>：考虑可能的鲜花选择。</p>
<p>候选1：百合，因为它有淡雅的颜色和花香。</p>
<p>候选2：玫瑰，选择淡粉色或白色，它们通常有花香。</p>
<p>候选3：紫罗兰，它有淡雅的颜色和花香。</p>
<p>候选4：桔梗，它的颜色淡雅但不一定有花香。</p>
<p>候选5：康乃馨，选择淡色系列，它们有淡雅的花香。  </p>
<p><strong>思维步骤3</strong>：根据顾客的需求筛选最佳选择。</p>
<p>百合和紫罗兰都符合顾客的需求，因为它们都有淡雅的颜色和花香。</p>
<p>淡粉色或白色的玫瑰也是一个不错的选择。</p>
<p>桔梗可能不是最佳选择，因为它可能没有花香。</p>
<p>康乃馨是一个可考虑的选择。  </p>
<p><strong>思维步骤4</strong>：给出建议。</p>
<p>“考虑到您妻子喜欢淡雅的颜色和花香，我建议您可以选择百合或紫罗兰。淡粉色或白色的玫瑰也是一个很好的选择。希望这些建议能帮助您做出决策！”</p>
</blockquote>
<h2 id="思考题-4"><a href="#思考题-4" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>我们的CoT实战示例中使用的是Few-Shot CoT提示，请你把它换为Zero-Shot CoT，跑一下程序，看看结果。</li>
<li>请你设计一个你工作场景中的任务需求，然后用ToT让大语言模型帮你解决问题。</li>
</ol>
<h1 id="7-调用模型：使用OpenAI-API还是微调开源Llama2-ChatGLM？"><a href="#7-调用模型：使用OpenAI-API还是微调开源Llama2-ChatGLM？" class="headerlink" title="7. 调用模型：使用OpenAI API还是微调开源Llama2&#x2F;ChatGLM？"></a>7. 调用模型：使用OpenAI API还是微调开源Llama2&#x2F;ChatGLM？</h1><h2 id="大语言模型发展史"><a href="#大语言模型发展史" class="headerlink" title="大语言模型发展史"></a>大语言模型发展史</h2><p>Transformer是几乎所有预训练模型的核心底层架构。基于Transformer预训练所得的大规模语言模型也被叫做“基础模型”（Foundation Model 或Base Model）。</p>
<p>在这个过程中，模型学习了词汇、语法、句子结构以及上下文信息等丰富的语言知识。这种在大量数据上学到的知识，为后续的下游任务（如情感分析、文本分类、命名实体识别、问答系统等）提供了一个通用的、丰富的语言表示基础，为解决许多复杂的NLP问题提供了可能。</p>
<p>在预训练模型出现的早期，BERT毫无疑问是最具代表性的，也是影响力最大的模型。BERT通过同时学习文本的前向和后向上下文信息，实现对句子结构的深入理解。BERT之后，各种大型预训练模型如雨后春笋般地涌现，自然语言处理（NLP）领域进入了一个新时代。这些模型推动了NLP技术的快速发展，解决了许多以前难以应对的问题，比如翻译、文本总结、聊天对话等等，提供了强大的工具。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262004504.png" alt="image-20250226200457389"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262005585.png" alt="image-20250226200522511"></p>
<p>预训练模型本身肯定只有企业能负担得起。</p>
<h2 id="预训练-微调的模式"><a href="#预训练-微调的模式" class="headerlink" title="预训练+微调的模式"></a>预训练+微调的模式</h2><p>经过预训练的大模型中所习得的语义信息和所蕴含的语言知识，能够非常容易地向下游任务迁移。NLP应用人员可以对模型的头部或者部分参数根据自己的需要进行适应性的调整，这通常涉及在相对较小的<strong>有标注数据集</strong>上进行有监督学习，让模型适应特定任务的需求。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262008370.png" alt="image-20250226200847310"></p>
<ul>
<li><strong>预训练</strong>：在大规模无标注文本数据上进行模型的训练，目标是让模型学习自然语言的基础表达、上下文信息和语义知识，为后续任务提供一个通用的、丰富的语言表示基础。  </li>
<li><strong>微调</strong>：在预训练模型的基础上，可以根据特定的下游任务对模型进行微调。现在你经常会听到各行各业的人说：<em>我们的优势就是领域知识嘛！我们比不过国内外大模型，我们可以拿开源模型做垂直领域嘛！做垂类模型！</em>—— 啥叫垂类？指的其实就是根据领域数据微调开源模型这件事儿。</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>Meta（Facebook）推出的Llama2</p>
<p>在HuggingFace的Model中，找到 <a href="https://link.juejin.cn/?target=https://huggingface.co/meta-llama/Llama-2-7b">meta-llama&#x2F;Llama-2-7b</a>。注意，各种各样版本的Llama2模型多如牛毛，我们这里用的是最小的7B版。此外，还有13b\70b\chat版以及各种各样的非Meta官方版。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的库</span></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer, AutoModelForCausalLM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练模型的分词器</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;meta-llama/Llama-2-7b-chat-hf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载预训练的模型</span></span><br><span class="line"><span class="comment"># 使用 device_map 参数将模型自动加载到可用的硬件设备上，例如GPU</span></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(</span><br><span class="line">          <span class="string">&quot;meta-llama/Llama-2-7b-chat-hf&quot;</span>, </span><br><span class="line">          device_map = <span class="string">&#x27;auto&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个提示，希望模型基于此提示生成故事</span></span><br><span class="line">prompt = <span class="string">&quot;请给我讲个玫瑰的爱情故事?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用分词器将提示转化为模型可以理解的格式，并将其移动到GPU上</span></span><br><span class="line">inputs = tokenizer(prompt, return_tensors=<span class="string">&quot;pt&quot;</span>).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型生成文本，设置最大生成令牌数为2000</span></span><br><span class="line">outputs = model.generate(inputs[<span class="string">&quot;input_ids&quot;</span>], max_new_tokens=<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成的令牌解码成文本，并跳过任何特殊的令牌，例如[CLS], [SEP]等</span></span><br><span class="line">response = tokenizer.decode(outputs[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印生成的响应</span></span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<p>这段程序是一个很典型的HuggingFace的Transformers库的用例，该库提供了大量预训练的模型和相关的工具。</p>
<ul>
<li>导入AutoTokenizer：这是一个用于自动加载预训练模型的相关分词器的工具。分词器负责将文本转化为模型可以理解的数字格式。</li>
<li>导入AutoModelForCausalLM：这是用于加载因果语言模型（用于文本生成）的工具。</li>
<li>使用from_pretrained方法来加载预训练的分词器和模型。其中，<code>device_map = &#39;auto&#39;</code> 是为了自动地将模型加载到可用的设备上，例如GPU。</li>
<li>然后，给定一个提示（prompt）：<code>&quot;请给我讲个玫瑰的爱情故事?&quot;</code>，并使用分词器将该提示转换为模型可以接受的格式，<code>return_tensors=&quot;pt&quot;</code> 表示返回PyTorch张量。语句中的 <code>.to(&quot;cuda&quot;)</code> 是<strong>GPU设备格式转换</strong>，因为我在GPU上跑程序，不用这个的话会报错，如果你使用CPU，可以试一下删掉它。</li>
<li>最后使用模型的 <code>.generate()</code> 方法生成响应。<code>max_new_tokens=2000</code> 限制生成的文本的长度。使用分词器的 <code>.decode() </code>方法将输出的数字转化回文本，并且跳过任何特殊的标记。</li>
</ul>
<p>把HuggingFace里面的模型接入LangChain：</p>
<p>第一种集成方式，是通过HuggingFace Hub。HuggingFace Hub 是一个开源模型中心化存储库，主要用于分享、协作和存储预训练模型、数据集以及相关组件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入HuggingFace API Token</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;HUGGINGFACEHUB_API_TOKEN&#x27;</span>] = <span class="string">&#x27;你的HuggingFace API Token&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入必要的库</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate, HuggingFaceHub, LLMChain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化HF LLM 指定模型名称，下载到cache目录</span></span><br><span class="line">llm = HuggingFaceHub(</span><br><span class="line">    repo_id=<span class="string">&quot;google/flan-t5-small&quot;</span>,</span><br><span class="line">    <span class="comment">#repo_id=&quot;meta-llama/Llama-2-7b-chat-hf&quot;,</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建简单的question-answering提示模板</span></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;Question: &#123;question&#125;</span></span><br><span class="line"><span class="string">              Answer: &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Prompt          </span></span><br><span class="line">prompt = PromptTemplate(template=template, input_variables=[<span class="string">&quot;question&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用LLM Chain --- 我们以后会详细讲LLM Chain</span></span><br><span class="line">llm_chain = LLMChain(</span><br><span class="line">    prompt=prompt,</span><br><span class="line">    llm=llm</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备问题</span></span><br><span class="line">question = <span class="string">&quot;Rose is which type of flower?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用模型并返回结果</span></span><br><span class="line"><span class="built_in">print</span>(llm_chain.run(question))</span><br></pre></td></tr></table></figure>

<p>既然HuggingFace Hub还不能完成Llama-2的测试，让我们来尝试另外一种方法，HuggingFace Pipeline。HuggingFace 的 Pipeline 是一种高级工具，它简化了多种常见自然语言处理（NLP）任务的使用流程，使得用户不需要深入了解模型细节，也能够很容易地利用预训练模型来做任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定预训练模型的名称</span></span><br><span class="line">model = <span class="string">&quot;meta-llama/Llama-2-7b-chat-hf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从预训练模型中加载词汇器</span></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个文本生成的管道</span></span><br><span class="line"><span class="keyword">import</span> transformers</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">pipeline = transformers.pipeline(</span><br><span class="line">    <span class="string">&quot;text-generation&quot;</span>,</span><br><span class="line">    model=model,</span><br><span class="line">    torch_dtype=torch.float16,</span><br><span class="line">    device_map=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    max_length = <span class="number">1000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建HuggingFacePipeline实例</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> HuggingFacePipeline</span><br><span class="line">llm = HuggingFacePipeline(pipeline = pipeline, </span><br><span class="line">                          model_kwargs = &#123;<span class="string">&#x27;temperature&#x27;</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入模板，该模板用于生成花束的描述</span></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              为以下的花束生成一个详细且吸引人的描述：</span></span><br><span class="line"><span class="string">              花束的详细信息：</span></span><br><span class="line"><span class="string">              ```&#123;flower_details&#125;```</span></span><br><span class="line"><span class="string">           &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模板创建提示</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate,  LLMChain</span><br><span class="line">prompt = PromptTemplate(template=template, </span><br><span class="line">                     input_variables=[<span class="string">&quot;flower_details&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建LLMChain实例</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate</span><br><span class="line">llm_chain = LLMChain(prompt=prompt, llm=llm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要生成描述的花束的详细信息</span></span><br><span class="line">flower_details = <span class="string">&quot;12支红玫瑰，搭配白色满天星和绿叶，包装在浪漫的红色纸中。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印生成的花束描述</span></span><br><span class="line"><span class="built_in">print</span>(llm_chain.run(flower_details))</span><br></pre></td></tr></table></figure>

<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262021000.png" alt="image-20250226202129916"></p>
<h2 id="用-LangChain-调用自定义语言模型"><a href="#用-LangChain-调用自定义语言模型" class="headerlink" title="用 LangChain 调用自定义语言模型"></a>用 LangChain 调用自定义语言模型</h2><p>假设你就是想训练属于自己的模型。而且出于商业秘密的原因，不想开源它，不想上传到HuggingFace，就是要在本机运行模型。此时应该如何利用LangChain的功能？</p>
<p>我们可以创建一个LLM的衍生类，自己定义模型。而LLM这个基类，则位于langchain.llms.base中，通过from langchain.llms.base import LLM语句导入。</p>
<p>这个自定义的LLM类只需要实现一个方法：</p>
<ul>
<li>_call方法：用于接收输入字符串并返回响应字符串。</li>
</ul>
<p>以及一个可选方法：</p>
<ul>
<li>_identifying_params方法：用于帮助打印此类的属性。</li>
</ul>
<p>假设已经有了一个自己微调后的模型llama-2-7b-chat.ggmlv3.q4_K_S.bin，CustomLLM类的构建和使用，类内部通过Llama类来实现大模型的推理功能，然后直接返回模型的回答。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入需要的库</span></span><br><span class="line"><span class="keyword">from</span> llama_cpp <span class="keyword">import</span> Llama</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">List</span>, Mapping, <span class="type">Any</span></span><br><span class="line"><span class="keyword">from</span> langchain.llms.base <span class="keyword">import</span> LLM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型的名称和路径常量</span></span><br><span class="line">MODEL_NAME = <span class="string">&#x27;llama-2-7b-chat.ggmlv3.q4_K_S.bin&#x27;</span></span><br><span class="line">MODEL_PATH = <span class="string">&#x27;/home/huangj/03_Llama/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的LLM类，继承自基础LLM类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomLLM</span>(<span class="title class_ inherited__">LLM</span>):</span><br><span class="line">    model_name = MODEL_NAME</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 该方法使用Llama库调用模型生成回复</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_call</span>(<span class="params">self, prompt: <span class="built_in">str</span>, stop: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]] = <span class="literal">None</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        prompt_length = <span class="built_in">len</span>(prompt) + <span class="number">5</span></span><br><span class="line">        <span class="comment"># 初始化Llama模型，指定模型路径和线程数</span></span><br><span class="line">        llm = Llama(model_path=MODEL_PATH+MODEL_NAME, n_threads=<span class="number">4</span>)</span><br><span class="line">        <span class="comment"># 使用Llama模型生成回复</span></span><br><span class="line">        response = llm(<span class="string">f&quot;Q: <span class="subst">&#123;prompt&#125;</span> A: &quot;</span>, max_tokens=<span class="number">256</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从返回的回复中提取文本部分</span></span><br><span class="line">        output = response[<span class="string">&#x27;choices&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;text&#x27;</span>].replace(<span class="string">&#x27;A: &#x27;</span>, <span class="string">&#x27;&#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回生成的回复，同时剔除了问题部分和额外字符</span></span><br><span class="line">        <span class="keyword">return</span> output[prompt_length:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回模型的标识参数，这里只是返回模型的名称</span></span><br><span class="line">    @<span class="built_in">property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_identifying_params</span>(<span class="params">self</span>) -&gt; Mapping[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;name_of_model&quot;</span>: <span class="variable language_">self</span>.model_name&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回模型的类型，这里是&quot;custom&quot;</span></span><br><span class="line">    @<span class="built_in">property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_llm_type</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;custom&quot;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化自定义LLM类</span></span><br><span class="line">llm = CustomLLM()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义LLM生成一个回复</span></span><br><span class="line">result = llm(<span class="string">&quot;昨天有一个客户抱怨他买了花给女朋友之后，两天花就枯了，你说作为客服我应该怎么解释？&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印生成的回复</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>你已经知道大模型训练涉及在大量数据上使用深度学习算法，通常需要大量计算资源和时间。训练后，模型可能不完全适合特定任务，因此需要微调，即在特定数据集上继续训练，以使模型更适应该任务。为了减小部署模型的大小和加快推理速度，模型还会经过量化，即将模型参数从高精度格式减少到较低精度。</p>
<p>如果你想继续深入学习大模型，那么有几个工具你不得不接着研究。</p>
<ul>
<li>PyTorch是一个流行的深度学习框架，常用于模型的训练和微调。</li>
<li>HuggingFace是一个开源社区，提供了大量预训练模型和微调工具，尤其是NLP任务。</li>
<li>LangChain则擅长于利用大语言模型的推理功能，开发新的工具或应用，完成特定的任务。</li>
</ul>
<p>这些工具和库在AI模型的全生命周期中起到关键作用，使研究者和开发者更容易开发和部署高效的AI系统。</p>
<h2 id="思考题-5"><a href="#思考题-5" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>现在请你再回答一下，什么时候应该使用OpenAI的API？什么时候应该使用开源模型？或者自己开发&#x2F;微调的模型？ 提示：的确，文中没有给出这个问题的答案。因为这个问题并没有标准答案。 </li>
<li>请你使用HuggingFace的Transformers库，下载新的模型进行推理，比较它们的性能。  </li>
<li>请你在LangChain中，使用HuggingFaceHub和HuggingFace Pipeline这两种接口，调用当前最流行的大语言模型。 提示：HuggingFace Model 页面，有模型下载量的当月排序，当月下载最多的模型就是最流行的模型。</li>
</ol>
<h1 id="8-输出解析：用OutputParser生成鲜花推荐列表"><a href="#8-输出解析：用OutputParser生成鲜花推荐列表" class="headerlink" title="8. 输出解析：用OutputParser生成鲜花推荐列表"></a>8. 输出解析：用OutputParser生成鲜花推荐列表</h1><p>输出解析器是<strong>一种专用于处理和构建语言模型响应的类</strong>。一个基本的输出解析器类通常需要实现两个核心方法。</p>
<ul>
<li>get_format_instructions：这个方法需要返回一个字符串，用于指导如何格式化语言模型的输出，告诉它应该如何组织并构建它的回答。</li>
<li>parse：这个方法接收一个字符串（也就是语言模型的输出）并将其解析为特定的数据结构或格式。这一步通常用于确保模型的输出符合我们的预期，并且能够以我们需要的形式进行后续处理。</li>
</ul>
<p>还有一个可选的方法。</p>
<ul>
<li>parse_with_prompt：这个方法接收一个字符串（也就是语言模型的输出）和一个提示（用于生成这个输出的提示），并将其解析为特定的数据结构。这样，你可以根据原始提示来修正或重新解析模型的输出，确保输出的信息更加准确和贴合要求。</li>
</ul>
<p>在LangChain中，通过实现get_format_instructions、parse 和 parse_with_prompt 这些方法，针对不同的使用场景和目标，设计了各种输出解析器。让我们来逐一认识一下。</p>
<ol>
<li>列表解析器（List Parser）：这个解析器用于处理模型生成的输出，当需要模型的输出是一个列表的时候使用。例如，如果你询问模型“列出所有鲜花的库存”，模型的回答应该是一个列表。</li>
<li>日期时间解析器（Datetime Parser）：这个解析器用于处理日期和时间相关的输出，确保模型的输出是正确的日期或时间格式。</li>
<li>枚举解析器（Enum Parser）：这个解析器用于处理预定义的一组值，当模型的输出应该是这组预定义值之一时使用。例如，如果你定义了一个问题的答案只能是“是”或“否”，那么枚举解析器可以确保模型的回答是这两个选项之一。</li>
<li>结构化输出解析器（Structured Output Parser）：这个解析器用于处理复杂的、结构化的输出。如果你的应用需要模型生成具有特定结构的复杂回答（例如一份报告、一篇文章等），那么可以使用结构化输出解析器来实现。</li>
<li>Pydantic（JSON）解析器：这个解析器用于处理模型的输出，当模型的输出应该是一个符合特定格式的JSON对象时使用。它使用Pydantic库，这是一个数据验证库，可以用于构建复杂的数据模型，并确保模型的输出符合预期的数据模型。</li>
<li>自动修复解析器（Auto-Fixing Parser）：这个解析器可以自动修复某些常见的模型输出错误。例如，如果模型的输出应该是一段文本，但是模型返回了一段包含语法或拼写错误的文本，自动修复解析器可以自动纠正这些错误。</li>
<li>重试解析器（RetryWithErrorOutputParser）：这个解析器用于在模型的初次输出不符合预期时，尝试修复或重新生成新的输出。例如，如果模型的输出应该是一个日期，但是模型返回了一个字符串，那么重试解析器可以重新提示模型生成正确的日期格式。</li>
</ol>
<p>这一节主要介绍567，我没怎么看，不过代码是有的。</p>
<h2 id="思考题-6"><a href="#思考题-6" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>到目前为止，我们已经使用了哪些LangChain输出解析器？请你说一说它们的用法和异同。同时也请你尝试使用其他类型的输出解析器，并把代码与大家分享。</li>
<li>为什么大模型能够返回JSON格式的数据，输出解析器用了什么魔法让大模型做到了这一点？</li>
<li>自动修复解析器的“修复”功能具体来说是怎样实现的？请做debug，研究一下LangChain在调用大模型之前如何设计“提示”。</li>
<li>重试解析器的原理是什么？它主要实现了解析器类的哪个可选方法？</li>
</ol>
<h1 id="9-链（上）：写一篇完美鲜花推文？用SequencialChain链接不同的组件"><a href="#9-链（上）：写一篇完美鲜花推文？用SequencialChain链接不同的组件" class="headerlink" title="9. 链（上）：写一篇完美鲜花推文？用SequencialChain链接不同的组件"></a>9. 链（上）：写一篇完美鲜花推文？用SequencialChain链接不同的组件</h1><p>Chain：链在内部把一系列的功能进行封装，而链的外部则又可以组合串联。<strong>链其实可以被视为LangChain中的一种基本功能单元。</strong></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262111706.png" alt="image-20250226211117589"></p>
<h2 id="LLMChain"><a href="#LLMChain" class="headerlink" title="LLMChain"></a>LLMChain</h2><p>LLMChain围绕着语言模型推理功能又添加了一些功能，整合了PromptTemplate、语言模型（LLM或聊天模型）和 Output Parser，相当于把Model I&#x2F;O放在一个链中整体操作。它使用提示模板格式化输入，将格式化的字符串传递给 LLM，并返回 LLM 输出。</p>
<p>如果使用链，代码结构则显得更简洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate, OpenAI, LLMChain</span><br><span class="line"><span class="comment"># 原始字符串模板</span></span><br><span class="line">template = <span class="string">&quot;&#123;flower&#125;的花语是?&quot;</span></span><br><span class="line"><span class="comment"># 创建模型实例</span></span><br><span class="line">llm = OpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 创建LLMChain</span></span><br><span class="line">llm_chain = LLMChain(</span><br><span class="line">    llm=llm,</span><br><span class="line">    prompt=PromptTemplate.from_template(template))</span><br><span class="line"><span class="comment"># 调用LLMChain，返回结果</span></span><br><span class="line">result = llm_chain(<span class="string">&quot;玫瑰&quot;</span>)<span class="comment">#等价于llm_chain.run(&quot;玫瑰&quot;)，llm_chain.predict(&quot;玫瑰&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>除了直接调用、run、predict，apply方法允许我们针对输入列表运行链，一次处理多个输入。generate方法类似于apply，只不过它返回一个LLMResult对象，而不是字符串。LLMResult通常包含模型生成文本过程中的一些相关信息，例如令牌数量、模型名称等。</p>
<h2 id="Sequential-Chain：顺序链"><a href="#Sequential-Chain：顺序链" class="headerlink" title="Sequential Chain：顺序链"></a>Sequential Chain：顺序链</h2><p>通过两个LLM链和一个顺序链，生成了一篇完美的文案</p>
<ul>
<li>第一步，我们假设大模型是一个植物学家，让他给出某种特定鲜花的知识和介绍。</li>
<li>第二步，我们假设大模型是一个鲜花评论者，让他参考上面植物学家的文字输出，对鲜花进行评论。</li>
<li>第三步，我们假设大模型是易速鲜花的社交媒体运营经理，让他参考上面植物学家和鲜花评论者的文字输出，来写一篇鲜花运营文案。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是总的链，我们按顺序运行这三个链</span></span><br><span class="line">overall_chain = SequentialChain(</span><br><span class="line">    chains=[introduction_chain, review_chain, social_post_chain],</span><br><span class="line">    input_variables=[<span class="string">&quot;name&quot;</span>, <span class="string">&quot;color&quot;</span>],</span><br><span class="line">    output_variables=[<span class="string">&quot;introduction&quot;</span>,<span class="string">&quot;review&quot;</span>,<span class="string">&quot;social_post_text&quot;</span>],</span><br><span class="line">    verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行链，并打印结果</span></span><br><span class="line">result = overall_chain(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;玫瑰&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;黑色&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h2 id="思考题-7"><a href="#思考题-7" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>在<a target="_blank" rel="noopener" href="https://juejin.cn/book/7387702347436130304/section/7396583376915005480">第4课</a>中，我们曾经用提示模板生成过一段鲜花的描述，代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> flower, price <span class="keyword">in</span> <span class="built_in">zip</span>(flowers, prices):</span><br><span class="line">    <span class="comment"># 根据提示准备模型的输入</span></span><br><span class="line">    <span class="built_in">input</span> = prompt.<span class="built_in">format</span>(flower_name=flower, price=price)</span><br><span class="line">    <span class="comment"># 获取模型的输出</span></span><br><span class="line">    output = model(<span class="built_in">input</span>)    </span><br><span class="line">    <span class="comment"># 解析模型的输出</span></span><br><span class="line">    parsed_output = output_parser.parse(output)</span><br></pre></td></tr></table></figure>

<p>请你使用LLMChain重构提示的format和获取模型输出部分，完成相同的功能。</p>
<p>提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">llm_chain = LLMChain(</span><br><span class="line">        llm=model,</span><br><span class="line">        prompt=prompt)</span><br></pre></td></tr></table></figure>

<ol>
<li>上一道题目中，我要求你把提示的format和获取模型输出部分整合到LLMChain中，其实你还可以更进一步，把output_parser也整合到LLMChain中，让程序结构进一步简化，请你尝试一下。</li>
</ol>
<p>提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">llm_chain = LLMChain(</span><br><span class="line">        llm=model,</span><br><span class="line">        prompt=prompt,</span><br><span class="line">        output_parser=output_parser)</span><br></pre></td></tr></table></figure>

<ol>
<li>选择一个LangChain中的链（我们没用到的类型），尝试使用它解决一个问题，并分享你的用例和代码。</li>
</ol>
<h1 id="10-链（下）：想学“育花”还是“插花”？用RouterChain确定客户意图"><a href="#10-链（下）：想学“育花”还是“插花”？用RouterChain确定客户意图" class="headerlink" title="10. 链（下）：想学“育花”还是“插花”？用RouterChain确定客户意图"></a>10. 链（下）：想学“育花”还是“插花”？用RouterChain确定客户意图</h1><p>RouterChain，也叫路由链，能<strong>动态选择</strong>用于给定输入的下一个链。我们会根据用户的问题内容，首先使用路由器链确定问题更适合哪个处理模板，然后将问题发送到该处理模板进行回答。如果问题不适合任何已定义的处理模板，它会被发送到默认链。</p>
<p>在这里，我们会用LLMRouterChain和MultiPromptChain（也是一种路由链）组合实现路由功能，该MultiPromptChain会调用LLMRouterChain选择与给定问题最相关的提示，然后使用该提示回答问题。</p>
<p><strong>具体步骤如下：</strong></p>
<ol>
<li>构建处理模板：为鲜花护理和鲜花装饰<strong>分别定义</strong>两个字符串模板。</li>
<li>提示信息：使用一个列表来组织和存储这两个处理模板的关键信息，如模板的键、描述和实际内容。</li>
<li>初始化语言模型：导入并实例化语言模型。</li>
<li>构建目标链：根据提示信息中的每个模板构建了对应的LLMChain，并存储在一个字典中。</li>
<li>构建LLM路由链：这是决策的核心部分。首先，它根据提示信息构建了一个路由模板，然后使用这个模板创建了一个LLMRouterChain。（引导模型选择最适合的模型提示）</li>
<li>构建默认链：如果输入不适合任何已定义的处理模板，这个默认链会被触发。（没找到合适的链就用这个处理）</li>
<li>构建多提示链：使用MultiPromptChain将LLM路由链、目标链和默认链组合在一起，形成一个完整的决策系统。</li>
</ol>
<p><strong>MultiPromptChain中有三个关键元素。</strong></p>
<ul>
<li>router_chain（类型RouterChain）：这是用于决定目标链和其输入的链。当给定某个输入时，这个router_chain决定哪一个destination_chain应该被选中，以及传给它的具体输入是什么。</li>
<li>destination_chains（类型Mapping[str, LLMChain]）：这是一个映射，将名称映射到可以将输入路由到的候选链。例如，你可能有多种处理文本输入的方法（或“链”），每种方法针对特定类型的问题。destination_chains可以是这样一个字典：<code>&#123;&#39;weather&#39;: weather_chain, &#39;news&#39;: news_chain&#125;</code>。在这里，weather_chain可能专门处理与天气相关的问题，而news_chain处理与新闻相关的问题。</li>
<li>default_chain（类型LLMChain）：当 router_chain 无法将输入映射到destination_chains中的任何一个链时，LLMChain 将使用此默认链。这是一个备选方案，确保即使路由器不能决定正确的链，也总有一个链可以处理输入。</li>
</ul>
<p><strong>它的工作流程如下：</strong></p>
<ol>
<li>输入首先传递给router_chain。</li>
<li>router_chain根据某些标准或逻辑决定应该使用哪一个destination_chain。</li>
<li>输入随后被路由到选定的destination_chain，该链进行处理并返回结果。</li>
<li>如果router_chain不能决定正确的destination_chain，则输入会被传递给default_chain。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chain = MultiPromptChain(</span><br><span class="line">    router_chain=router_chain,</span><br><span class="line">    destination_chains=chain_map,</span><br><span class="line">    default_chain=default_chain,</span><br><span class="line">    verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="思考题-8"><a href="#思考题-8" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>通过verbose&#x3D;True这个选项的设定，在输出时显示了链的开始和结束日志，从而得到其相互调用流程。请你尝试把该选项设置为False，看一看输出结果有何不同。</li>
<li>在这个例子中，我们使用了ConversationChain作为default_chain，这个Chain是LLMChain的子类，你能否把这个Chain替换为LLMChain？</li>
</ol>
<h1 id="11-记忆：通过Memory记住客户上次买花时的对话细节"><a href="#11-记忆：通过Memory记住客户上次买花时的对话细节" class="headerlink" title="11. 记忆：通过Memory记住客户上次买花时的对话细节"></a>11. 记忆：通过Memory记住客户上次买花时的对话细节</h1><p>ConversationChain的对话模板：这是<strong>人类和</strong> <strong>AI</strong> <strong>之间的友好对话。AI</strong> <strong>非常健谈并从其上下文中提供了大量的具体细节。</strong> (The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. )</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The following <span class="keyword">is</span> a friendly conversation between a human <span class="keyword">and</span> an AI. The AI <span class="keyword">is</span> talkative <span class="keyword">and</span> provides lots of specific details <span class="keyword">from</span> its context. If the AI does <span class="keyword">not</span> know the answer to a question, it truthfully says it does <span class="keyword">not</span> know.</span><br><span class="line"></span><br><span class="line">Current conversation:</span><br><span class="line">&#123;history&#125; <span class="comment">#是存储会话记忆的地方，也就是人类和人工智能之间对话历史的信息。</span></span><br><span class="line">Human: &#123;<span class="built_in">input</span>&#125; <span class="comment">#新输入的地方，你可以把它看成是和ChatGPT对话时，文本框中的输入。</span></span><br><span class="line">AI:</span><br></pre></td></tr></table></figure>

<p>同时，这个提示试图通过说明以下内容来减少幻觉，也就是尽量减少模型编造的信息：</p>
<p><strong>“如果</strong> <strong>AI</strong> <strong>不知道问题的答案，它就会如实说它不知道。”</strong>（If the AI does not know the answer to a question, it truthfully says it does not know.）</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262218831.png" alt="image-20250226221832785"></p>
<p>那么当有了** <strong>{history}</strong> <strong>参数，以及</strong> <strong>Human</strong> <strong>和</strong> <strong>AI</strong>这两个前缀，我们就能够把历史对话信息存储在提示模板中，并作为新的提示内容在新一轮的对话过程中传递给模型。—— 这就是记忆机制的原理</p>
<p><strong>使用ConversationBufferMemory</strong></p>
<p>实际上，这些聊天历史信息，都被传入了ConversationChain的提示模板中的 {history} 参数，构建出了包含聊天记录的新的提示输入。</p>
<p>有了记忆机制，LLM能够了解之前的对话内容，这样简单直接地存储所有内容为LLM提供了最大量的信息，但是新输入中也包含了更多的Token（所有的聊天历史记录），这意味着响应时间变慢和更高的成本。而且，当达到LLM的令牌数（上下文窗口）限制时，太长的对话无法被记住（对于text-davinci-003和gpt-3.5-turbo，每次的最大输入限制是4096个Token）。</p>
<p><strong>使用ConversationBufferWindowMemory</strong></p>
<p>ConversationBufferWindowMemory 是<strong>缓冲窗口记忆</strong>，它的思路就是只保存最新最近的几次人类和AI的互动。因此，它在之前的“缓冲记忆”基础上增加了一个窗口值 k。这意味着我们只保留一定数量的过去互动，然后“忘记”之前的互动。</p>
<p>尽管这种方法不适合记住遥远的互动，但它非常擅长限制使用的Token数量。如果只需要记住最近的互动，缓冲窗口记忆是一个很好的选择。但是，如果需要混合远期和近期的互动信息，则还有其他选择。</p>
<p><strong>使用ConversationSummaryMemory</strong></p>
<p>上面说了，如果模型在第二轮回答的时候，能够说出“我可以帮你为你姐姐找到…”，那么在第三轮回答时，即使窗口大小 k&#x3D;1，还是能够回答出正确答案。这是为什么？因为模型<strong>在回答新问题的时候，对之前的问题进行了总结性的重述</strong>。</p>
<p>ConversationSummaryMemory（<strong>对话总结记忆</strong>）的思路就是将对话历史进行汇总，然后再传递给 {history} 参数。这种方法旨在通过对之前的对话进行汇总来避免过度使用 Token。</p>
<p>ConversationSummaryMemory有这么几个核心特点。</p>
<ol>
<li>汇总对话：此方法不是保存整个对话历史，而是每次新的互动发生时对其进行汇总，然后将其添加到之前所有互动的“运行汇总”中。</li>
<li>使用LLM进行汇总：<strong>该汇总功能由另一个LLM驱动</strong>，这意味着对话的汇总实际上是由AI自己进行的。</li>
<li>适合长对话：对于长对话，此方法的优势尤为明显。虽然最初使用的 Token 数量较多，但随着对话的进展，汇总方法的增长速度会减慢。与此同时，常规的缓冲内存模型会继续线性增长。</li>
</ol>
<p>这里，我们<strong>不仅仅利用了LLM来回答每轮问题，还利用LLM来对之前的对话进行总结性的陈述，以节约Token数量</strong>。这里，帮我们总结对话的LLM，和用来回答问题的LLM，可以是同一个大模型，也可以是不同的大模型。</p>
<p>ConversationSummaryMemory的优点是对于长对话，可以减少使用的 Token 数量，因此可以记录更多轮的对话信息，使用起来也直观易懂。不过，它的缺点是，对于较短的对话，可能会导致更高的 Token 使用。另外，对话历史的记忆完全依赖于中间汇总LLM的能力，还需要<strong>为汇总LLM使用 Token</strong>，这增加了成本，且并不限制对话长度。</p>
<p>通过对话历史的汇总来优化和管理 Token 的使用，ConversationSummaryMemory 为那些预期会有多轮的、长时间对话的场景提供了一种很好的方法。然而，这种方法仍然受到 Token 数量的限制。在一段时间后，我们仍然会超过大模型的上下文窗口限制。</p>
<p>而且，总结的过程中并<strong>没有区分</strong>近期的对话和长期的对话（通常情况下近期的对话更重要），所以我们还要继续寻找新的记忆管理方法。</p>
<p><strong>使用ConversationSummaryBufferMemory</strong></p>
<blockquote>
<p>早期的互动进行汇总+近期的互动保留原始</p>
</blockquote>
<p>我要为你介绍的最后一种记忆机制是ConversationSummaryBufferMemory，即<strong>对话总结缓冲记忆</strong>，它是一种<strong>混合记忆</strong>模型，结合了上述各种记忆机制，包括ConversationSummaryMemory 和 ConversationBufferWindowMemory的特点。这种模型旨在在对话中总结早期的互动，同时尽量保留最近互动中的原始内容。</p>
<p>它是通过max_token_limit这个参数做到这一点的。当最新的对话文字长度在300字之内的时候，LangChain会记忆原始对话内容；当对话文字超出了这个参数的长度，那么模型就会把所有超过预设长度的内容进行总结，以节省Token数量。</p>
<p>ConversationSummaryBufferMemory的优势是通过总结可以回忆起较早的互动，而且有缓冲区确保我们不会错过最近的互动信息。当然，对于较短的对话，ConversationSummaryBufferMemory也会增加Token数量。</p>
<p>总体来说，ConversationSummaryBufferMemory为我们提供了大量的灵活性。它是我们迄今为止的唯一记忆类型，可以回忆起较早的互动并完整地存储最近的互动。在节省Token数量方面，ConversationSummaryBufferMemory与其他方法相比，也具有竞争力。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262238074.png" alt="image-20250226223838035"></p>
<p>网上还有人总结了一个示意图，体现出了当对话轮次逐渐增加时，各种记忆机制对Token的消耗数量。意图向我们表达的是：有些记忆机制，比如说ConversationSummaryBufferMemory和ConversationSummaryMemory，在对话轮次较少的时候可能会浪费一些Token，但是多轮对话过后，Token的节省就逐渐体现出来了。</p>
<p>当然ConversationBufferWindowMemory对于Token的节省最为直接，但是它会完全遗忘掉K轮之前的对话内容，因此对于某些场景也不是最佳选择。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502262239528.png" alt="image-20250226223954487"></p>
<h2 id="思考题-9"><a href="#思考题-9" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>在你的客服聊天机器人设计中，你会首先告知客户：“亲，我的记忆能力有限，只能记住和你的最近10次对话哦。如果我忘了之前的对话，请你体谅我。” 当有了这样的预设，你会为你的ChatBot选择那种记忆机制？</li>
<li>尝试改变示例程序ConversationBufferWindowMemory中的k值，并增加对话轮次，看看记忆效果。</li>
<li>尝试改变示例程序ConversationSummaryBufferMemory中的max_token_limit值，看看记忆效果。</li>
</ol>
<h1 id="12-代理（上）：ReAct框架，推理与行动的协同"><a href="#12-代理（上）：ReAct框架，推理与行动的协同" class="headerlink" title="12. 代理（上）：ReAct框架，推理与行动的协同"></a>12. 代理（上）：ReAct框架，推理与行动的协同</h1><p>仅仅应用思维链推理并不能解决大模型的固有问题：<strong>无法主动更新自己的知识，导致出现事实幻觉</strong>。也就是说，因为缺乏和外部世界的接触，大模型只拥有训练时见过的知识，以及提示信息中作为上下文提供的附加知识。</p>
<p>可以让大模型先在本地知识库中进行搜索，检查一下提示中的信息的真实性，如果真实，再进行输出；如果不真实，则进行修正。如果本地知识库找不到相应的信息，可以调用工具进行外部搜索，来检查提示信息的真实性。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011307867.png" alt="image-20250301130725790"></p>
<p>每当你遇到这种需要模型做自主判断、自行调用工具、自行决定下一步行动的时候，Agent（也就是代理）就出场了。</p>
<p>代理就像一个多功能的接口，它能够接触并使用一套工具。根据用户的输入，代理会决定调用哪些工具。它不仅可以同时使用多种工具，而且可以将一个工具的输出数据作为另一个工具的输入数据。</p>
<p>在LangChain中使用代理，我们只需要理解下面三个元素。</p>
<ul>
<li><strong>大模型</strong>：提供逻辑的引擎，负责生成预测和处理输入。</li>
<li>与之交互的<strong>外部工具</strong>：可能包括数据清洗工具、搜索引擎、应用程序等。</li>
<li>控制交互的<strong>代理</strong>：调用适当的外部工具，并管理整个交互过程的流程。</li>
</ul>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011312679.png" alt="image-20250301131225630"></p>
<p>这个过程有很多地方需要大模型自主判断下一步行为（也就是操作）要做什么，如果不加引导，那大模型本身是不具备这个能力的。比如下面这一系列的操作：</p>
<ul>
<li>什么时候开始在本地知识库中搜索（这个比较简单，毕竟是第一个步骤，可以预设）？</li>
<li>怎么确定本地知识库的检索已经完成，可以开始下一步？</li>
<li>调用哪一种外部搜索工具（比如Google引擎）？</li>
<li>如何确定外部搜索工具返回了想要找的内容？</li>
<li>如何确定信息真实性的检索已经全部完成，可以开始下一步？</li>
</ul>
<h2 id="ReAct框架"><a href="#ReAct框架" class="headerlink" title="ReAct框架"></a>ReAct框架</h2><p>我会去Google上面查一查今天的鲜花成本价啊（<strong>行动</strong>），也就是我预计的进货的价格，然后我会根据这个价格的高低（<strong>观察</strong>），来确定我要加价多少（<strong>思考</strong>），最后计算出一个售价（<strong>行动</strong>）！</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011313169.png" alt="image-20250301131338137"></p>
<p>你有观察、有思考，然后才会具体行动。这里的观察和思考，我们统称为推理（Reasoning）过程，推理指导着你的行动（Acting）。</p>
<p><strong>ReAct 框架的灵感正是来自“行动”和“推理”之间的协同作用，这种协同作用使得咱们人类能够学习新任务并做出决策或推理</strong>。这个框架，也是大模型能够作为“智能代理”，自主、连续、交错地生成推理轨迹和任务特定操作的理论基础。</p>
<p><strong>大语言模型可以通过生成推理痕迹和任务特定行动来实现更大的协同作用</strong>。</p>
<p>具体来说，就是引导模型生成一个任务解决轨迹：观察环境-进行思考-采取行动，也就是观察-思考-行动。那么，再进一步进行简化，就变成了推理-行动，也就是Reasoning-Acting框架。</p>
<p>其中，Reasoning包括了对当前环境和状态的观察，并生成推理轨迹。这使模型能够诱导、跟踪和更新操作计划，甚至处理异常情况。Acting在于指导大模型采取下一步的行动，比如与外部源（如知识库或环境）进行交互并且收集信息，或者给出最终答案。</p>
<p>ReAct的每一个推理过程都会被详细记录在案，这也改善大模型解决问题时的可解释性和可信度，而且这个框架在各种语言和决策任务中都得到了很好的效果。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011327648.png" alt="image-20250301132753614"></p>
<p>将 ReAct框架和思维链（CoT）结合使用，则能够让大模型在推理过程同时使用内部知识和获取到的外部信息，从而给出更可靠和实际的回应，也提高了 LLMs 的可解释性和可信度。</p>
<p>LangChain正是通过Agent类，将ReAct框架进行了完美封装和实现，这一下子就赋予了大模型极大的自主性（Autonomy），<strong>你的大模型现在从一个仅仅可以通过自己内部知识进行对话聊天的</strong> <strong>Bot，飞升为了一个有手有脚能使用工具的智能代理</strong>。</p>
<p>ReAct框架会提示 LLMs 为任务生成推理轨迹和操作，这使得代理能系统地执行动态推理来创建、维护和调整操作计划，同时还支持与外部环境（例如Google搜索、Wikipedia）的交互，以将额外信息合并到推理中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置OpenAI和SERPAPI的API密钥</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;SERPAPI_API_KEY&quot;</span>] = (</span><br><span class="line">    <span class="string">&quot;Your SERPAPI API KEY&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载所需的库</span></span><br><span class="line"><span class="keyword">from</span> langchain_community.agent_toolkits.load_tools <span class="keyword">import</span> load_tools</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentType</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI  <span class="comment"># ChatOpenAI模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化大模型</span></span><br><span class="line">llm = ChatOpenAI(model=os.environ[<span class="string">&quot;LLM_MODELEND&quot;</span>], temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工具 serpapi（这是调用Google搜索引擎的工具）以及llm-math（这是通过LLM进行数学计算的工具）</span></span><br><span class="line">tools = load_tools([<span class="string">&quot;serpapi&quot;</span>, <span class="string">&quot;llm-math&quot;</span>], llm=llm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Agent</span></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跑起来</span></span><br><span class="line">agent.run(</span><br><span class="line">    <span class="string">&quot;目前市场上玫瑰花的平均价格是多少？如果我在此基础上加价15%卖出，应该如何定价？&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011336019.png" alt="image-20250301133652975"></p>
<p>通过ReAct框架，大模型将被引导生成一个任务解决轨迹，即观察环境-进行思考-采取行动。观察和思考阶段被统称为推理（Reasoning），而实施下一步行动的阶段被称为行动（Acting）。在每一步推理过程中，都会详细记录下来，这也改善了大模型解决问题时的可解释性和可信度。</p>
<ul>
<li>在推理阶段，模型对当前环境和状态进行观察，并生成推理轨迹，从而使模型能够诱导、跟踪和更新操作计划，甚至处理异常情况。</li>
<li>在行动阶段，模型会采取下一步的行动，如与外部源（如知识库或环境）进行交互并收集信息，或给出最终答案。</li>
</ul>
<p>ReAct框架的这些优点，使得它在未来的发展中具有巨大的潜力。随着技术的进步，我们可以期待ReAct框架将能够处理更多、更复杂的任务。特别是随着具身智能的发展，ReAct框架将能够使智能代理在虚拟或实际环境中进行更复杂的交互。例如，智能代理可能会在虚拟环境中进行导航，或者在实际环境中操作物理对象。这将大大扩展AI的应用范围，使得它们能够更好地服务于我们的生活和工作。</p>
<h2 id="思考题-10"><a href="#思考题-10" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>在ReAct框架中，推理和行动各自代表什么？其相互之间的关系如何？</li>
<li>为什么说ReAct框架能改善大模型解决问题时的可解释性和可信度？</li>
<li>你能否说一说LangChain中的代理和链的核心差异？答：在链中，一系列操作被硬编码（在代码中）。在代理中，语言模型被用作推理引擎来确定要采取哪些操作以及按什么顺序执行这些操作。</li>
</ol>
<h1 id="13-代理（中）：AgentExecutor究竟是怎样驱动模型和工具完成任务的？"><a href="#13-代理（中）：AgentExecutor究竟是怎样驱动模型和工具完成任务的？" class="headerlink" title="13. 代理（中）：AgentExecutor究竟是怎样驱动模型和工具完成任务的？"></a>13. 代理（中）：AgentExecutor究竟是怎样驱动模型和工具完成任务的？</h1><p>上节课中，你了解了ReAct框架的原理，最后我给你留了一道思考题，让你说一说LangChain中的“代理”和“链”的差异究竟是什么。</p>
<p>我的答案是：<strong>在链中，一系列操作被硬编码（在代码中）。在代理中，语言模型被用作推理引擎来确定要采取哪些操作以及按什么顺序执行这些操作。</strong></p>
<p>下面这个图，就展现出了Agent接到任务之后，自动进行推理，然后自主调用工具完成任务的过程。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011342252.png" alt="image-20250301134252208"></p>
<p>那么，你看LangChain，乃至整个大模型应用开发的核心理念就呼之欲出了。这个核心理念就是<strong>操作的序列并非硬编码在代码中，而是使用语言模型（如GPT-3或GPT-4）来选择执行的操作序列</strong>。</p>
<h2 id="Agent-的关键组件"><a href="#Agent-的关键组件" class="headerlink" title="Agent 的关键组件"></a>Agent 的关键组件</h2><p>在LangChain的代理中，有这样几个关键组件。</p>
<ol>
<li><strong>代理</strong>（Agent）：这个类决定下一步执行什么操作。它由一个语言模型和一个提示（prompt）驱动。提示可能包含<strong>代理的性格</strong>（也就是给它分配角色，让它以特定方式进行响应）、<strong>任务的背景</strong>（用于给它提供更多任务类型的上下文）以及用于激发更好推理能力的提示策略（例如ReAct）。LangChain中包含很多种不同类型的代理。  </li>
<li><strong>工具</strong>（Tools）：工具是代理调用的函数。这里有两个重要的考虑因素：一是让代理能访问到正确的工具，二是以最有帮助的方式描述这些工具。如果你没有给代理提供正确的工具，它将无法完成任务。如果你没有正确地描述工具，代理将不知道如何使用它们。LangChain提供了一系列的工具，同时你也可以定义自己的工具。  </li>
<li><strong>工具包</strong>（Toolkits）：工具包是一组用于完成特定目标的彼此相关的工具，每个工具包中<strong>包含多个工具</strong>。比如LangChain的Office365工具包中就包含连接Outlook、读取邮件列表、发送邮件等一系列工具。当然LangChain中还有很多其他工具包供你使用。  </li>
<li><strong>代理执行器</strong>（AgentExecutor）：代理执行器是代理的运行环境，它调用代理并执行代理选择的操作。执行器也负责处理多种复杂情况，包括处理代理选择了不存在的工具的情况、处理工具出错的情况、处理代理产生的无法解析成工具调用的输出的情况，以及在代理决策和工具调用进行观察和日志记录。</li>
</ol>
<p>总的来说，代理就是一种用语言模型做出决策、调用工具来执行具体操作的系统。通过设定代理的性格、背景以及工具的描述，你可以定制代理的行为，使其能够根据输入的文本做出理解和推理，从而实现自动化的任务处理。而代理执行器（AgentExecutor）就是上述机制得以实现的引擎。</p>
<p>现在，请你用你的代码编辑工具（比如VS Code）在agent.run这个语句设置一个断点，用 “Step Into” 功能深入几层LangChain内部代码，直到我们进入了 <strong>agent.py文件的AgentExecutor类的内部方法 _take_next_step</strong>。</p>
<p>这个 _take_next_step 方法掌控着下一步要调用什么的计划，你可以看到self.agent.plan方法被调用，这是计划开始之处。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011357106.png"></p>
<p><strong>第一轮思考：模型决定搜索</strong></p>
<p>在AgentExecutor 的_take_next_step 方法的驱动下，我们进一步Debug，<strong>深入self.agent.plan方法</strong>，来到了整个行为链条的第一步—— <strong>Plan</strong>，这个Plan的具体细节是由Agent类的Plan方法来完成的，你可以看到，输入的问题将会被传递给llm_chain，然后接收llm_chain调用大模型的返回结果。</p>
<ul>
<li>即这里会把agent.run(“input”)中用户的问题输入给llm_chain</li>
</ul>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011359360.png" alt="image-20250301135906306"></p>
<p>再往前进一步，我们就要开始调用大模型了，那么，LangChain到底传递给了大模型什么具体的提示信息，让大模型能够主动进行工具的选择呢？秘密在 <strong>LLMChain类的generate方法</strong>中，我们可以看到提示的具体内容。</p>
<p>在Debug过程中，你可以观察prompt，也就是提示的具体内容，这里我把这个提示Copy出来，你可以看一下。</p>
<p>我来给你详细拆解一下这个prompt。注意，下面的解释文字不是原始提示，而是我添加的说明。</p>
<blockquote>
<p>0: StringPromptValue(text&#x3D;’Answer the following questions as best you can. You have access to the following tools:\n\n</p>
</blockquote>
<p>这句提示是让模型尽量回答问题，并告诉模型拥有哪些工具。</p>
<blockquote>
<p>Search: A search engine. Useful for when you need to answer questions about current events. Input should be a search query.\n</p>
</blockquote>
<p>这是向模型介绍第一个工具：搜索。</p>
<blockquote>
<p>Calculator: Useful for when you need to answer questions about math.\n\n</p>
</blockquote>
<p>这是向模型介绍第二个工具：计算器。</p>
<blockquote>
<p>Use the following format:\n\n （指导模型使用下面的格式）</p>
<p>Question: the input question you must answer\n （问题）</p>
<p>Thought: you should always think about what to do\n （思考）</p>
<p>Action: the action to take, should be one of [Search, Calculator]\n （行动）</p>
<p>Action Input: the input to the action\n （行动的输入）</p>
<p>Observation: the result of the action\n… （观察：行动的返回结果）</p>
<p>(this Thought&#x2F;Action&#x2F;Action Input&#x2F;Observation can repeat N times)\n （上面这个过程可以重复多次）</p>
<p>Thought: I now know the final answer\n （思考：现在我知道最终答案了）</p>
<p>Final Answer: the final answer to the original input question\n\n （最终答案）</p>
</blockquote>
<p>上面，就是给模型的思考框架。具体解释可以看一下括号中的文字</p>
<blockquote>
<p>Begin!\n\n</p>
</blockquote>
<p>现在开始！</p>
<blockquote>
<p>Question: 目前市场上玫瑰花的平均价格是多少？如果我在此基础上加价15%卖出，应该如何定价？  </p>
<p>\nThought:’)</p>
</blockquote>
<p>具体问题，也就是具体任务。</p>
<p>上面我一句句拆解的这个提示词，就是Agent之所以能够趋动大模型，进行<strong>思考-行动-观察行动结果-再思考-再行动-再观察</strong>这个循环的核心秘密。有了这样的提示词，模型就会不停地思考、行动，直到模型判断出问题已经解决，给出最终答案，跳出循环。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011403583.png" alt="image-20250301140340527"></p>
<p>那么，调用大模型之后，模型具体返回了什么结果呢？在Debug过程中，我们发现调用模型之后的outputs中包含下面的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: LLMResult(generations=[[Generation(text=&#x27; I need to find the current market price of roses and then calculate the new price with a 15% markup.\n </span><br><span class="line">Action: Search\nAction Input: &quot;Average price of roses&quot;&#x27;, generation_info=&#123;&#x27;finish_reason&#x27;: &#x27;stop&#x27;, &#x27;logprobs&#x27;: None&#125;)]], </span><br><span class="line">llm_output=&#123;&#x27;token_usage&#x27;: &#123;&#x27;completion_tokens&#x27;: 36, &#x27;total_tokens&#x27;: 294, &#x27;prompt_tokens&#x27;: 258&#125;, &#x27;model_name&#x27;: &#x27;gpt-3.5-turbo-instruct&#x27;&#125;, run=None)</span><br></pre></td></tr></table></figure>

<p>把上面的内容拆解如下：</p>
<blockquote>
<p>‘text’: ‘ I need to find the current market price of roses and then calculate the new price with a 15% markup.\n （Text：问题文本）</p>
<p>Action: Search\n （行动：搜索）</p>
<p>Action Input: “Average price of roses”‘ （行动的输入：搜索玫瑰平均价格）</p>
</blockquote>
<p>看来，模型知道面对这个问题，<strong>它自己根据现有知识解决不了，下一步行动是需要选择工具箱中的搜索工具</strong>。而此时，命令行中也输出了模型的第一步计划——调用搜索工具。</p>
<p>现在模型知道了要调用什么工具，第一轮的Plan部分就结束了。下面，我们就来到了AgentExecutor 的_take_next_step 的<strong>工具调用部分。</strong></p>
<p>在这里，因为模型返回了Action为Search，OutputParse解析了这个结果之后，LangChain很清楚地知道，Search工具会被调用。</p>
<p>工具调用完成之后，我们就拥有了一个对当前工具调用的 <strong>Observation</strong>，也就是当前工具调用的结果。</p>
<p>下一步，我们要再次调用大模型，形成新的 <strong>Thought</strong>，看看任务是否已经完成了，或者仍需要再次调用工具（新的工具或者再次调用同一工具）。</p>
<p><strong>第二轮思考：模型决定计算</strong></p>
<p>因为任务尚未完成，第二轮思考开始，程序重新进入了Plan环节。</p>
<p>此时，LangChain的LLM Chain根据目前的input，也就是历史对话记录生成了新的提示信息（Thought之前与第一步一模一样，省略）</p>
<blockquote>
<p>Thought: I need to find the current market price of roses and then calculate the new price with a 15% markup.\n （思考：我需要找到玫瑰花的价格，并加入15%的加价）</p>
<p>Action: Search\nAction （行动：搜索）</p>
<p>Input: “Average price of roses”\n （行动的输入：玫瑰花的平均价格）</p>
<p>Observation: The average price for a dozen roses in the U.S. is $80.16. The state where a dozen roses cost the most is Hawaii at $108.33. That’s 35% more expensive than the national average. A dozen roses are most affordable in Pennsylvania, costing $66.15 on average.\n （观察：这里时搜索工具返回的玫瑰花价格信息）</p>
</blockquote>
<blockquote>
<p>Thought:’</p>
</blockquote>
<p>思考：后面是大模型应该进一步推理的内容。大模型根据上面这个提示，返回了下面的output信息。</p>
<p>有了上面的Thought做指引，AgentExecutor调用了第二个工具：LLMMath。现在开始计算。这个提示，我把它拷贝出来，也拆解一下。</p>
<blockquote>
<p>0: StringPromptValue(text&#x3D;’Translate a math problem into a expression that can be executed using Python’s numexpr library. Use the output of running this code to answer the question.\n\n</p>
</blockquote>
<p>指定模型用Python的数学库来编程解决数学问题，而不是自己计算。这就规避了大模型数学推理能力弱的局限。</p>
<blockquote>
<p>Question: ${Question with math problem.}\n （问题）</p>
<p>text\n${single line mathematical expression that solves the problem} n&#96;&#96;&#96;\n （问题的数学描述）</p>
<p>…numexpr.evaluate(text)…\n&#96;&#96;&#96; （通过Python库运行问题的数学描述）</p>
<p>output\n${Output of running the code}\n&#96;&#96;&#96;\n （输出的Python代码运行结果）</p>
<p>Answer: ${Answer}\n\n （问题的答案）</p>
<p>Begin.\n\n （开始）</p>
</blockquote>
<p>从这里开始是两个数学式的解题示例。</p>
<blockquote>
<p>Question: What is 37593 * 67?\n</p>
<p>`&#96;&#96;text\n37593 * 67\n&#96;&#96;&#96;</p>
<p>\n…numexpr.evaluate(“37593 * 67”)…\n</p>
<p>`&#96;&#96;output\n2518731\n&#96;&#96;&#96;\n</p>
<p>Answer: 2518731\n\n</p>
<p>Question: 37593^(1&#x2F;5)\n</p>
<p>`&#96;&#96;text\n37593**(1&#x2F;5)\n&#96;&#96;&#96;\n…</p>
<p>numexpr.evaluate(“37593**(1&#x2F;5)”)…\n</p>
<p>`&#96;&#96;output\n8.222831614237718\n&#96;&#96;&#96;\n</p>
<p>Answer: 8.222831614237718\n\n</p>
</blockquote>
<p>两个数学式的解题示例结束。</p>
<blockquote>
<p>Question: 80.16 * 1.15\n’)</p>
</blockquote>
<p>这里是玫瑰花问题的具体描述。</p>
<p><strong>第三轮思考：模型完成任务</strong></p>
<p>继续Debug，发现模型在这一轮思考之后的输出中终于包含了 “**I now know the final answer.**”，这说明模型意识到任务已经成功地完成了。</p>
<p>此时，AgentExcutor的plan方法返回一个 <strong>AgentFinish</strong> <strong>实例</strong>，这表示代理经过对输出的检查，其内部逻辑判断出任务已经完成，思考和行动的循环要结束了。</p>
<p><strong>总结</strong></p>
<p>这一课中，我们深入到AgentExecutor的代码内部，深挖其运行机制，了解了AgentExecutor是如何通过计划和工具调用，一步一步完成Thought、Action和Observation的。</p>
<p>如果我们审视一下AgentExecutor 的代码实现，会发现AgentExecutor这个类是作为链（Chain）而存在，同时也为代理执行各种工具，完成任务。它会接收代理的计划，并执行代理思考链路中每一步的行动。</p>
<p>AgentExecutor中最重要的方法是步骤处理方法，_take_next_step方法。它用于在思考-行动-观察的循环中采取单步行动。先调用代理的计划，查找代理选择的工具，然后使用选定的工具执行该计划（此时把输入传给工具），从而获得观察结果，然后继续思考，直到输出是 AgentFinish 类型，循环才会结束。</p>
<h2 id="思考题-11"><a href="#思考题-11" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>请你在 <a href="https://link.juejin.cn/?target=https://github.com/langchain-ai/langchain/blob/master/libs/langchain/langchain/agents/agent.py">agent.py</a> 文件中找到AgentExecutor类。</li>
<li>请你在AgentExecutor类中找到_take_next_step方法，对应本课的内容，分析AgentExecutor类是怎样实现Plan和工具调用的。</li>
</ol>
<h1 id="14-代理（下）：结构化工具对话、Self-Ask-with-Search以及Plan-and-execute代理"><a href="#14-代理（下）：结构化工具对话、Self-Ask-with-Search以及Plan-and-execute代理" class="headerlink" title="14. 代理（下）：结构化工具对话、Self-Ask with Search以及Plan and execute代理"></a>14. 代理（下）：结构化工具对话、Self-Ask with Search以及Plan and execute代理</h1><p>举例来说，结构化工具的示例包括：</p>
<ol>
<li>文件管理工具集：支持所有文件系统操作，如写入、搜索、移动、复制、列目录和查找。</li>
<li>Web 浏览器工具集：官方的 PlayWright 浏览器工具包，允许代理访问网站、点击、提交表单和查询数据。</li>
</ol>
<h2 id="Playwright"><a href="#Playwright" class="headerlink" title="Playwright"></a>Playwright</h2><p>Playwright是一个开源的自动化框架，它可以让你模拟真实用户操作网页，帮助开发者和测试者自动化网页交互和测试。用简单的话说，它就像一个“机器人”，可以按照你给的指令去浏览网页、点击按钮、填写表单、读取页面内容等等，就像一个真实的用户在使用浏览器一样。</p>
<p>Playwright支持多种浏览器，比如Chrome、Firefox、Safari等，这意味着你可以用它来测试你的网站或测试应用在不同的浏览器上的表现是否一致。</p>
<h2 id="使用-Self-Ask-with-Search-代理"><a href="#使用-Self-Ask-with-Search-代理" class="headerlink" title="使用 Self-Ask with Search 代理"></a>使用 Self-Ask with Search 代理</h2><p>Self-Ask with Search 也是LangChain中的一个有用的代理类型（SELF_ASK_WITH_SEARCH）。它利用一种叫做 “Follow-up Question（追问）”加“Intermediate Answer（中间答案）”的技巧，来辅助大模型寻找事实性问题的过渡性答案，从而引出最终答案。</p>
<p>其实，细心的你可能会发现，“<strong>使用玫瑰作为国花的国家的首都是哪里?<strong>”这个问题不是一个简单的问题，它其实是一个多跳问题——</strong>在问题和最终答案之间，存在中间过程</strong>。</p>
<p>多跳问题（Multi-hop question）是指为了得到最终答案，需要进行多步推理或多次查询。这种问题不能直接通过单一的查询或信息源得到答案，而是需要跨越多个信息点，或者从多个数据来源进行组合和整合。</p>
<p>也就是说，问题的答案依赖于另一个子问题的答案，这个子问题的答案可能又依赖于另一个问题的答案。这就像是一连串的问题跳跃，对于人类来说，解答这类问题可能需要从不同的信息源中寻找一系列中间答案，然后结合这些中间答案得出最终结论。</p>
<p>“使用玫瑰作为国花的国家的首都是哪里？”这个问题并不直接询问哪个国家使用玫瑰作为国花，也不是直接询问英国的首都是什么。而是先要推知使用玫瑰作为国花的国家（英国）之后，进一步询问这个国家的首都。这就需要多跳查询。</p>
<p>为什么 Self-Ask with Search 代理适合解决多跳问题呢？有下面几个原因。</p>
<ol>
<li><strong>工具集合</strong>：代理包含解决问题所必须的搜索工具，可以用来查询和验证多个信息点。这里我们在程序中为代理武装了SerpAPIWrapper工具。</li>
<li><strong>逐步逼近</strong>：代理可以根据第一个问题的答案，提出进一步的问题，直到得到最终答案。这种逐步逼近的方式可以确保答案的准确性。</li>
<li><strong>自我提问与搜索</strong>：代理可以自己提问并搜索答案。例如，首先确定哪个国家使用玫瑰作为国花，然后确定该国家的首都是什么。</li>
<li><strong>决策链</strong>：代理通过一个决策链来执行任务，使其可以跟踪和处理复杂的多跳问题，这对于解决需要多步推理的问题尤为重要。</li>
</ol>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011558191.png" alt="image-20250301155840150"></p>
<h2 id="使用-Plan-and-execute-代理"><a href="#使用-Plan-and-execute-代理" class="headerlink" title="使用 Plan and execute 代理"></a>使用 Plan and execute 代理</h2><p>计划和执行代理通过首先计划要做什么，然后执行子任务来实现目标。这个想法是受到 <a href="https://link.juejin.cn/?target=https://arxiv.org/abs/2305.04091">Plan-and-Solve</a> 论文的启发。论文中提出了计划与解决（Plan-and-Solve）提示。它由两部分组成：首先，制定一个计划，并将整个任务划分为更小的子任务；然后按照该计划执行子任务。</p>
<p>这种代理的独特之处在于，它的计划和执行不再是由同一个代理所完成，而是：</p>
<ul>
<li>计划由一个大语言模型代理（负责推理）完成。</li>
<li>执行由另一个大语言模型代理（负责调用工具）完成。</li>
</ul>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011602192.png" alt="image-20250301160202146"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011603173.png" alt="image-20250301160309128" style="zoom: 50%;" /><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011603501.png" alt="image-20250301160322658" style="zoom: 50%;" /></p>
<p>图中的 Indexes，到底是什么，其实这个Indexes是LangChang早期版本的一个组件，现在已经被整合到Retrieval（数据检索）这个单元中了。而Retrieval（包括Indexes），讲的其实就是如何把离散的文档及其他信息做嵌入，存储到向量数据库中，然后再提取的过程。</p>
<h2 id="思考题-12"><a href="#思考题-12" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>在结构化工具对话代理的示例中，请你打印出PlayWrightBrowserToolkit中的所有具体工具名称的列表。</li>
</ol>
<p>提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tools = toolkit.get_tools()</span><br><span class="line"><span class="built_in">print</span>(tools)</span><br></pre></td></tr></table></figure>

<ol>
<li>在Plan and execute代理的示例中，请你分析PlanAndExecute、AgentExecutor和LLMMathChain链的调用流程以及代理的思考过程。</li>
</ol>
<h1 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h1><blockquote>
<p>在这个模块中，我们会展示如何将LangChain组件应用到实际场景中。你将学会如何使用LangChain的工具和接口，进行嵌入式存储，连接数据库，引入异步通信机制，通过智能代理进行各种角色扮演、头脑风暴，并进行自主搜索，制定自动策略，尝试不同方案完成任务。</p>
<p>我们将不仅仅是讲解这些组件的功能，还会通过实际应用场景来展示它们是如何互相配合，共同完成复杂任务的。本模块中的很多机制都来源于最新论文，其中对AI智能代理机制的各种使用方式将令你大开脑洞，或许你会哈哈一笑，或许你会击节赞叹，钦佩设计者思路之清奇。</p>
</blockquote>
<h1 id="15-工具和工具箱：LangChain中的Tool和Toolkits一览"><a href="#15-工具和工具箱：LangChain中的Tool和Toolkits一览" class="headerlink" title="15. 工具和工具箱：LangChain中的Tool和Toolkits一览"></a>15. 工具和工具箱：LangChain中的Tool和Toolkits一览</h1><p>LangChain通过提供一个统一的框架来集成功能的具体实现。在这个框架中，每个功能都被封装成一个工具。每个工具都有自己的输入和输出，以及处理这些输入和生成输出的方法。</p>
<p>当代理接收到一个任务时，它会根据任务的类型和需求，通过大模型的推理，来选择合适的工具处理这个任务。这个选择过程可以基于各种策略，例如基于工具的性能，或者基于工具处理特定类型任务的能力。</p>
<p>一旦选择了合适的工具，LangChain就会将任务的输入传递给这个工具，然后工具会处理这些输入并生成输出。这个输出又经过大模型的推理，可以被用作其他工具的输入，或者作为最终结果，被返回给用户。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011638152.jpeg" alt="img"></p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011642536.jpeg" alt="img" style="zoom:67%;" />

<p>arXiv本身就是一个论文研究的利器，里面的论文数量比AI顶会还早、还多、还全。那么把它以工具的形式集成到LangChain中，能让你在研究学术最新进展时如虎添翼。</p>
<ul>
<li>通过Gmail工具箱，你可以通过LangChain应用检查邮件、删除垃圾邮件，甚至让它帮你撰写邮件草稿。</li>
<li>通过Office365工具箱，你可以让LangChain应用帮你读写文档、总结文档，甚至做PPT。</li>
<li>通过GitHub工具箱，你可以指示LangChain应用来检查最新的代码，Commit Changes、Merge Branches，甚至尝试让大模型自动回答 Issues 中的问题——反正大模型解决代码问题的能力本来就更强。</li>
</ul>
<p>学到现在，你应该对LangChain 的核心价值有了更深的感悟吧。它的价值，在于它将模型运行和交互的复杂性进行了封装和抽象化，为开发者提供了一个更简单、更直观的接口来利用大模型。</p>
<ul>
<li><strong>集成多模型和多策略：</strong> LangChain 提供了一种方法，使得多个模型或策略能够在一个统一的框架下工作。例如，arXiv 是一个单独的工具，它负责处理特定的任务。这种工具可以与其他工具（例如用于处理自然语言查询或者数据库查询的工具）一起作为一个集成的系统存在。这样，你可以轻松地创建一个系统，该系统可以处理多种类型的输入并执行多种任务，而不必为每个任务单独写代码。  </li>
<li><strong>更易于交互和维护：</strong> 通过 LangChain，你可以更方便地管理和维护你的工具和模型。LangChain 提供的工具和代理（Agent）抽象使得开发者可以将关注点从底层实现细节转向实现应用的高层逻辑。而且，LangChain封装了像模型的加载、输入输出的处理、工具的调度等底层任务，使得开发者能够更专注于如何组合这些工具以解决实际问题。  </li>
<li><strong>适应性：</strong> LangChain 提供的架构允许你轻松地添加新的工具或模型，或者替换现有的工具或模型。这种灵活性使得你的系统可以很容易地适应新的需求或改变。  </li>
<li><strong>可解释性：</strong> LangChain 还提供了对模型决策的可解释性。在你的示例中，LangChain 提供的对话历史和工具选择的记录可以帮助理解系统做出某些决策的原因。</li>
</ul>
<p>总的来说，尽管直接调用模型可能对于单一任务或简单应用来说足够了，但是当你需要处理更复杂的场景，例如需要协调多个模型或工具，或者需要处理多种类型的输入时，使用像 LangChain 这样的框架可以大大简化你的工作。</p>
<h2 id="思考题-13"><a href="#思考题-13" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>上面Gmail的示例中我只是展示了邮件读取功能，你能否让你的AI助理帮你写邮件的草稿甚至发送邮件？  </li>
<li>你可否尝试使用GitHub工具开发一些App来自动完成一部分GitHub任务，比如查看Issues、Merge Branches之类的事儿。</li>
</ol>
<p>提示：参考此<a href="https://link.juejin.cn/?target=https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app">链接</a>创建 GitHub App，以及LangChain的<a href="https://link.juejin.cn/?target=https://python.langchain.com/docs/integrations/toolkits/github">参考文档</a>。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011649719.jpeg" alt="img"> <img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011649546.jpeg" alt="img"></p>
<h1 id="16-检索增强生成：通过RAG助力鲜花运营"><a href="#16-检索增强生成：通过RAG助力鲜花运营" class="headerlink" title="16. 检索增强生成：通过RAG助力鲜花运营"></a>16. 检索增强生成：通过RAG助力鲜花运营</h1><p>什么是RAG？其全称为Retrieval-Augmented Generation，即检索增强生成，它结合了检索和生成的能力，为文本序列生成任务引入外部知识。RAG将传统的语言生成模型与大规模的外部知识库相结合，使模型在生成响应或文本时可以动态地从这些知识库中检索相关信息。这种结合方法旨在增强模型的生成能力，使其能够产生更为丰富、准确和有根据的内容，特别是在需要具体细节或外部事实支持的场合。</p>
<p>RAG 的工作原理可以概括为几个步骤。</p>
<ol>
<li><strong>检索</strong>：对于给定的输入（问题），模型首先使用检索系统从大型文档集合中查找相关的文档或段落。这个检索系统通常基于密集向量搜索，例如ChromaDB、Faiss这样的向量数据库。</li>
<li><strong>上下文编码</strong>：找到相关的文档或段落后，模型将它们与原始输入（问题）一起编码。</li>
<li><strong>生成</strong>：使用编码的上下文信息，模型生成输出（答案）。这通常当然是通过大模型完成的。</li>
</ol>
<p>RAG 的一个关键特点是，它不仅仅依赖于训练数据中的信息，还可以从大型外部知识库中检索信息。这使得RAG模型特别适合处理在训练数据中未出现的问题。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011655244.webp" alt="RAG 的 Pipeline"></p>
<h2 id="文档加载"><a href="#文档加载" class="headerlink" title="文档加载"></a><strong>文档加载</strong></h2><p>RAG的第一步是文档加载。LangChain 提供了多种类型的文档加载器，以加载各种类型的文档（HTML、PDF、代码），并与该领域的其他主要提供商如 Airbyte 和 Unstructured.IO 进行了集成。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011655118.webp" alt="img"></p>
<h2 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a><strong>文本转换</strong></h2><p>加载文档后，下一个步骤是对文本进行转换，而最常见的文本转换就是把长文档分割成更小的块（或者是片，或者是节点），以适合模型的上下文窗口。LangChain 有许多内置的文档转换器，可以轻松地拆分、组合、过滤和以其他方式操作文档。</p>
<h3 id="文本分割器"><a href="#文本分割器" class="headerlink" title="文本分割器"></a><strong>文本分割器</strong></h3><p>把长文本分割成块听起来很简单，其实也存在一些细节。文本分割的质量会影响检索的结果质量。理想情况下，我们希望将语义相关的文本片段保留在一起。</p>
<p>LangChain中，文本分割器的工作原理如下：</p>
<ol>
<li>将文本分成小的、具有语义意义的块（通常是句子）。</li>
<li>开始将这些小块组合成一个更大的块，直到达到一定的大小。</li>
<li>一旦达到该大小，一个块就形成了，可以开始创建新文本块。这个新文本块和刚刚生成的块要有一些重叠，以保持块之间的上下文。</li>
</ol>
<p>因此，LangChain提供的各种文本拆分器可以帮助你从下面几个角度设定你的分割策略和参数：</p>
<ol>
<li>文本如何分割</li>
<li>块的大小</li>
<li>块之间重叠文本的长度</li>
</ol>
<p>这些文本分割器的说明和示例如下：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011657385.webp" alt="img"></p>
<p>你可能会关心，文本分割在实践，有哪些具体的考量因素，我总结了下面几点。</p>
<p><strong>首先，就是LLM 的具体限制</strong>。GPT-3.5-turbo支持的上下文窗口为4096个令牌，这意味着输入令牌和生成的输出令牌的总和不能超过4096，否则会出错。为了保证不超过这个限制，我们可以预留约2000个令牌作为输入提示，留下约2000个令牌作为返回的消息。这样，如果你提取出了五个相关信息块，那么每个片的大小不应超过400个令牌。</p>
<p><strong>此外，文本分割策略的选择和任务类型相关。</strong></p>
<ul>
<li>需要细致查看文本的任务，最好使用较小的分块。例如，拼写检查、语法检查和文本分析可能需要识别文本中的单个单词或字符。垃圾邮件识别、查找剽窃和情感分析类任务，以及搜索引擎优化、主题建模中常用的关键字提取任务也属于这类细致任务。</li>
<li>需要全面了解文本的任务，则使用较大的分块。例如，机器翻译、文本摘要和问答任务需要理解文本的整体含义。而自然语言推理、问答和机器翻译需要识别文本中不同部分之间的关系。还有创意写作，都属于这种粗放型的任务。</li>
</ul>
<p><strong>最后，你也要考虑所分割的文本的性质</strong>。例如，如果文本结构很强，如代码或HTML，你可能想使用较大的块，如果文本结构较弱，如小说或新闻文章，你可能想使用较小的块。</p>
<h3 id="其他形式的文本转换"><a href="#其他形式的文本转换" class="headerlink" title="其他形式的文本转换"></a><strong>其他形式的文本转换</strong></h3><p>除拆分文本之外，LangChain中还集成了各种工具对文档执行的其他类型的转换。下面让我们对其进行逐点分析。</p>
<ol>
<li><strong>过滤冗余</strong>的文档：使用 EmbeddingsRedundantFilter 工具可以识别相似的文档并过滤掉冗余信息。这意味着如果你有多份高度相似或几乎相同的文档，这个功能可以帮助识别并删除这些多余的副本，从而节省存储空间并提高检索效率。</li>
<li><strong>翻译</strong>文档：通过与工具 doctran 进行集成，可以将文档从一种语言翻译成另一种语言。</li>
<li>提取元数据：通过与工具 doctran 进行集成，可以从文档内容中提取关键信息（如日期、作者、关键字等），并将其存储为<strong>元数据</strong>。元数据是描述文档属性或内容的数据，这有助于更有效地管理、分类和检索文档。</li>
<li><strong>转换对话格式</strong>：通过与工具 doctran 进行集成，可以将对话式的文档内容转化为问答（Q&#x2F;A）格式，从而更容易地提取和查询特定的信息或回答。这在处理如访谈、对话或其他交互式内容时非常有用。</li>
</ol>
<p>所以说，文档转换不仅限于简单的文本拆分，还可以包含附加的操作，这些操作的目的都是更好地准备和优化文档，以供后续生成更好的索引和检索功能。</p>
<h2 id="文本嵌入"><a href="#文本嵌入" class="headerlink" title="文本嵌入"></a><strong>文本嵌入</strong></h2><p>文本块形成之后，我们就通过LLM来做嵌入（Embeddings），将文本转换为数值表示，使得计算机可以更容易地处理和比较文本。OpenAI、Cohere、Hugging Face 中都有能做文本嵌入的模型。</p>
<p>Embeddings 会创建一段文本的向量表示，让我们可以在向量空间中思考文本，并执行语义搜索之类的操作，在向量空间中查找最相似的文本片段。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011701840.webp" alt="图片来源网络"></p>
<p>它提供两种方法：</p>
<ol>
<li>第一种是 embed_documents 方法，为文档创建嵌入。这个方法接收多个文本作为输入，意味着你可以一次性将多个文档转换为它们的向量表示。</li>
<li>第二种是 embed_query 方法，为查询创建嵌入。这个方法只接收一个文本作为输入，通常是用户的搜索查询。</li>
</ol>
<p><strong>为什么需要两种方法</strong>？虽然看起来这两种方法都是为了文本嵌入，但是LangChain将它们分开了。原因是一些嵌入提供者对于文档和查询使用的是不同的嵌入方法。文档是要被搜索的内容，而查询是实际的搜索请求。这两者可能因为其性质和目的，而需要不同的处理或优化。</p>
<h2 id="存储嵌入"><a href="#存储嵌入" class="headerlink" title="存储嵌入"></a><strong>存储嵌入</strong></h2><p>计算嵌入可能是一个时间消耗大的过程。为了加速这一过程，我们可以将计算出的嵌入存储或临时缓存，这样在下次需要它们时，就可以直接读取，无需重新计算。</p>
<h3 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a><strong>缓存存储</strong></h3><p>CacheBackedEmbeddings是一个支持缓存的嵌入式包装器，它可以将嵌入缓存在键值存储中。具体操作是：对文本进行哈希处理，并将此哈希值用作缓存的键。</p>
<p>要初始化一个CacheBackedEmbeddings，主要的方式是使用from_bytes_store。其需要以下参数：</p>
<ul>
<li>underlying_embedder：实际计算嵌入的嵌入器。</li>
<li>document_embedding_cache：用于存储文档嵌入的缓存。</li>
<li>namespace（可选）：用于文档缓存的命名空间，避免与其他缓存发生冲突。</li>
</ul>
<p><strong>不同的缓存策略如下：</strong></p>
<ol>
<li>InMemoryStore：在内存中缓存嵌入。主要用于单元测试或原型设计。如果需要长期存储嵌入，请勿使用此缓存。</li>
<li>LocalFileStore：在本地文件系统中存储嵌入。适用于那些不想依赖外部数据库或存储解决方案的情况。</li>
<li>RedisStore：在Redis数据库中缓存嵌入。当需要一个高速且可扩展的缓存解决方案时，这是一个很好的选择。</li>
</ol>
<p>在内存中缓存嵌入的示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入内存存储库，该库允许我们在RAM中临时存储数据</span></span><br><span class="line"><span class="keyword">from</span> langchain.storage <span class="keyword">import</span> InMemoryStore</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个InMemoryStore的实例</span></span><br><span class="line">store = InMemoryStore()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入与嵌入相关的库。OpenAIEmbeddings是用于生成嵌入的工具，而CacheBackedEmbeddings允许我们缓存这些嵌入</span></span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings, CacheBackedEmbeddings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个OpenAIEmbeddings的实例，这将用于实际计算文档的嵌入</span></span><br><span class="line">underlying_embeddings = OpenAIEmbeddings()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个CacheBackedEmbeddings的实例。</span></span><br><span class="line"><span class="comment"># 这将为underlying_embeddings提供缓存功能，嵌入会被存储在上面创建的InMemoryStore中。</span></span><br><span class="line"><span class="comment"># 我们还为缓存指定了一个命名空间，以确保不同的嵌入模型之间不会出现冲突。</span></span><br><span class="line">embedder = CacheBackedEmbeddings.from_bytes_store(</span><br><span class="line">    underlying_embeddings,  <span class="comment"># 实际生成嵌入的工具</span></span><br><span class="line">    store,  <span class="comment"># 嵌入的缓存位置</span></span><br><span class="line">    namespace=underlying_embeddings.model  <span class="comment"># 嵌入缓存的命名空间</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用embedder为两段文本生成嵌入。</span></span><br><span class="line"><span class="comment"># 结果，即嵌入向量，将被存储在上面定义的内存存储中。</span></span><br><span class="line">embeddings = embedder.embed_documents([<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;智能鲜花客服&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>解释下这段代码。首先我们在内存中设置了一个存储空间，然后初始化了一个嵌入工具，该工具将实际生成嵌入。之后，这个嵌入工具被包装在一个缓存工具中，用于为两段文本生成嵌入。</p>
<h3 id="向量数据库（向量存储）"><a href="#向量数据库（向量存储）" class="headerlink" title="向量数据库（向量存储）"></a><strong>向量数据库（向量存储）</strong></h3><p>更常见的存储向量的方式是通过向量数据库（Vector Store）来保存它们。LangChain支持非常多种向量数据库，其中有很多是开源的，也有很多是商用的。比如Elasticsearch、Faiss、Chroma和Qdrant等等。因为选择实在是太多了，我也给你列出来了一个表。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011711462.webp" alt="img"></p>
<p>那么问题来了，面对这么多种类的向量数据库，应该如何选择呢？这就涉及到许多技术和业务层面的考量，你应该<strong>根据具体需求进行选型</strong>。</p>
<ol>
<li>数据规模和速度需求：考虑你的数据量大小以及查询速度的要求。一些向量数据库在处理大规模数据时更加出色，而另一些在低延迟查询中表现更好。</li>
<li>持久性和可靠性：根据你的应用场景，确定你是否需要数据的高可用性、备份和故障转移功能。</li>
<li>易用性和社区支持：考虑向量数据库的学习曲线、文档的完整性以及社区的活跃度。</li>
<li>成本：考虑总体拥有成本，包括许可、硬件、运营和维护成本。</li>
<li>特性：考虑你是否需要特定的功能，例如多模态搜索等。</li>
<li>安全性：确保向量数据库符合你的安全和合规要求。</li>
</ol>
<p>在进行向量数据库的评测时，进行<strong>性能基准测试</strong>是了解向量数据库实际表现的关键。这可以帮助你评估查询速度、写入速度、并发性能等。</p>
<h2 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h2><p>Retriever，也就是检索器，是数据检索模块的核心入口，它通过非结构化查询返回相关的文档。</p>
<h3 id="向量存储检索器"><a href="#向量存储检索器" class="headerlink" title="向量存储检索器"></a><strong>向量存储检索器</strong></h3><p>向量存储检索器是最常见的，它主要支持向量检索。当然LangChain也有支持其他类型存储格式的检索器。</p>
<p>下面实现一个端到端的数据检索功能，我们通过VectorstoreIndexCreator来创建索引，并在索引的query方法中，通过vectorstore类的as_retriever方法，把向量数据库（Vector Store）直接作为检索器，来完成检索任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置OpenAI的API密钥</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="string">&#x27;Your OpenAI Key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入文档加载器模块，并使用TextLoader来加载文本文件</span></span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> TextLoader</span><br><span class="line">loader = TextLoader(<span class="string">&#x27;LangChainSamples/OneFlower/易速鲜花花语大全.txt&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用VectorstoreIndexCreator来从加载器创建索引</span></span><br><span class="line"><span class="keyword">from</span> langchain.indexes <span class="keyword">import</span> VectorstoreIndexCreator</span><br><span class="line">index = VectorstoreIndexCreator().from_loaders([loader])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义查询字符串, 使用创建的索引执行查询</span></span><br><span class="line">query = <span class="string">&quot;玫瑰花的花语是什么？&quot;</span></span><br><span class="line">result = index.query(query)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 打印查询结果</span></span><br></pre></td></tr></table></figure>

<p>你可能会觉得，这个数据检索过程太简单了。这就要归功于LangChain的强大封装能力。如果我们审视一下位于vectorstore.py中的VectorstoreIndexCreator类的代码，你就会发现，它其中封装了vectorstore、embedding以及text_splitter，甚至document loader（如果你使用from_documents方法的话）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VectorstoreIndexCreator</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Logic for creating indexes.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    vectorstore_cls: <span class="type">Type</span>[VectorStore] = Chroma</span><br><span class="line">    embedding: Embeddings = Field(default_factory=OpenAIEmbeddings)</span><br><span class="line">    text_splitter: TextSplitter = Field(default_factory=_get_default_text_splitter)</span><br><span class="line">    vectorstore_kwargs: <span class="built_in">dict</span> = Field(default_factory=<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Configuration for this pydantic object.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        extra = Extra.forbid</span><br><span class="line">        arbitrary_types_allowed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_loaders</span>(<span class="params">self, loaders: <span class="type">List</span>[BaseLoader]</span>) -&gt; VectorStoreIndexWrapper:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a vectorstore index from loaders.&quot;&quot;&quot;</span></span><br><span class="line">        docs = []</span><br><span class="line">        <span class="keyword">for</span> loader <span class="keyword">in</span> loaders:</span><br><span class="line">            docs.extend(loader.load())</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.from_documents(docs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_documents</span>(<span class="params">self, documents: <span class="type">List</span>[Document]</span>) -&gt; VectorStoreIndexWrapper:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a vectorstore index from documents.&quot;&quot;&quot;</span></span><br><span class="line">        sub_docs = <span class="variable language_">self</span>.text_splitter.split_documents(documents)</span><br><span class="line">        vectorstore = <span class="variable language_">self</span>.vectorstore_cls.from_documents(</span><br><span class="line">            sub_docs, <span class="variable language_">self</span>.embedding, **<span class="variable language_">self</span>.vectorstore_kwargs</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> VectorStoreIndexWrapper(vectorstore=vectorstore)</span><br></pre></td></tr></table></figure>

<p>因此，上面的检索功能就相当于我们第3课中讲过的一系列工具的整合。而我们也可以用下面的代码，来显式地指定索引创建器的vectorstore、embedding以及text_splitter，并把它们替换成你所需要的工具，比如另外一种向量数据库或者别的Embedding模型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line">text_splitter = CharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line">embeddings = OpenAIEmbeddings()</span><br><span class="line">index_creator = VectorstoreIndexCreator(</span><br><span class="line">    vectorstore_cls=Chroma,</span><br><span class="line">    embedding=OpenAIEmbeddings(),</span><br><span class="line">    text_splitter=CharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>那么，下一个问题是 index.query(query)，又是如何完成具体的检索及文本生成任务的呢？我们此处既没有看到大模型，又没有看到LangChain的文档检索工具（比如我们在第3课中见过的QARetrival链）。</p>
<p>秘密仍然存在于源码中，在VectorStoreIndexWrapper类的query方法中，可以看到，在调用方法的同时，RetrievalQA链被启动，以完成检索功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VectorStoreIndexWrapper</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Wrapper around a vectorstore for easy access.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    vectorstore: VectorStore</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Configuration for this pydantic object.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        extra = Extra.forbid</span><br><span class="line">        arbitrary_types_allowed = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        question: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        llm: <span class="type">Optional</span>[BaseLanguageModel] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        retriever_kwargs: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **kwargs: <span class="type">Any</span></span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Query the vectorstore.&quot;&quot;&quot;</span></span><br><span class="line">        llm = llm <span class="keyword">or</span> OpenAI(temperature=<span class="number">0</span>)</span><br><span class="line">        retriever_kwargs = retriever_kwargs <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">        chain = RetrievalQA.from_chain_type(</span><br><span class="line">            llm, retriever=<span class="variable language_">self</span>.vectorstore.as_retriever(**retriever_kwargs), **kwargs</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> chain.run(question)</span><br></pre></td></tr></table></figure>

<p>上面我们用到的向量存储检索器，是向量存储类的轻量级包装器，使其符合检索器接口。它使用向量存储中的搜索方法（例如相似性搜索和 MMR）来查询向量存储中的文本。</p>
<h3 id="各种类型的检索器"><a href="#各种类型的检索器" class="headerlink" title="各种类型的检索器"></a>各种类型的检索器</h3><p>除向量存储检索器之外，LangChain中还提供很多种其他的检索工具。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011731913.webp" alt="img"></p>
<p>这些检索工具，各有其功能特点，你可以查找它们的文档说明，并尝试使用。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是一种高效地管理和定位文档信息的方法，确保每个文档具有唯一标识并便于检索。</p>
<p>尽管在<a target="_blank" rel="noopener" href="https://juejin.cn/book/7387702347436130304/section/7388069933021986856">第3课</a>的示例中，我们并没有显式的使用到索引就完成了一个RAG任务，但在复杂的信息检索任务中，有效地管理和索引文档是关键的一步。LangChain 提供的索引 API 为开发者带来了一个高效且直观的解决方案。具体来说，它的优势包括：</p>
<ul>
<li>避免重复内容：确保你的向量存储中不会有冗余数据。</li>
<li>只更新更改的内容：能检测哪些内容已更新，避免不必要的重写。</li>
<li>省时省钱：不对未更改的内容重新计算嵌入，从而减少了计算资源的消耗。</li>
<li>优化搜索结果：减少重复和不相关的数据，从而提高搜索的准确性。</li>
</ul>
<p>LangChain 利用了记录管理器（RecordManager）来跟踪哪些文档已经被写入向量存储。</p>
<p>在进行索引时，API 会对每个文档进行哈希处理，确保每个文档都有一个唯一的标识。这个哈希值不仅仅基于文档的内容，还考虑了文档的元数据。</p>
<p>一旦哈希完成，以下信息会被保存在记录管理器中：</p>
<ul>
<li>文档哈希：基于文档内容和元数据计算出的唯一标识。</li>
<li>写入时间：记录文档何时被添加到向量存储中。</li>
<li>源 ID：这是一个元数据字段，表示文档的原始来源。</li>
</ul>
<p>这种方法确保了即使文档经历了多次转换或处理，也能够精确地跟踪它的状态和来源，确保文档数据被正确管理和索引。</p>
<p><strong>总结</strong></p>
<p>通过检索增强生成来存储和搜索非结构化数据的最常见方法是，给这些非结构化的数据做嵌入并存储生成的嵌入向量，然后在查询时给要查询的文本也做嵌入，并检索与嵌入查询“最相似”的嵌入向量。向量数据库则负责存储嵌入数据，并为你执行向量的搜索。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011738861.webp" alt="img"></p>
<p>你看，RAG实际上是为非结构化数据创建了一个“地图”。当用户有查询请求时，该查询同样被嵌入，然后你的应用程序会在这个“地图”中寻找与之最匹配的位置，从而快速准确地检索信息。</p>
<p>在我们的鲜花运营场景中，RAG当然可以在很多方面发挥巨大的作用。你的鲜花有各种各样的品种、颜色和花语，这些数据往往是自然的、松散的，也就是非结构化的。使用RAG，你可以通过嵌入向量，把库存的鲜花与相关的非结构化信息（如花语、颜色、产地等）关联起来。当客户或者员工想要查询某种鲜花的信息时，系统可以快速地提供准确的答案。</p>
<p>此外，RAG还可以应用于<strong>订单管理</strong>。每个订单，无论是客户的姓名、地址、购买的鲜花种类，还是订单状态，都可以被视为非结构化数据。通过RAG，我们可以轻松地嵌入并检索这些订单，为客户提供实时的订单更新、跟踪和查询服务。</p>
<p>当然，对于订单这样的信息，更常见的情况仍是把它们组织成结构化的数据，存储在数据库中（至少也是CSV或者Excel表中），以便高效、精准地查询。那么，LLM能否帮助我们查询数据库表中的条目呢？在下一课中，我将为你揭晓答案。</p>
<h2 id="思考题-14"><a href="#思考题-14" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>请你尝试使用一种文本分割器来给你的文档分块。</li>
<li>请你尝试使用一种新的向量数据库来存储你的文本嵌入。</li>
<li>请你尝试使用一种新的检索器来提取信息。</li>
</ol>
<h1 id="17-连接数据库：通过链和代理查询鲜花信息"><a href="#17-连接数据库：通过链和代理查询鲜花信息" class="headerlink" title="17. 连接数据库：通过链和代理查询鲜花信息"></a>17. 连接数据库：通过链和代理查询鲜花信息</h1><p>一直以来，在计算机编程和数据库管理领域，所有的操作都需要通过严格、专业且结构化的语法来完成。这就是结构化查询语言（SQL）。当你想从一个数据库中提取信息或进行某种操作时，你需要使用这种特定的语言明确地告诉计算机你的要求。这不仅需要我们深入了解正在使用的技术，还需要对所操作的数据有充分的了解。<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011930076.png" alt="图片来源网络"></p>
<p>现在，我们正进入一个<strong>全新的编程范式</strong>，其中机器学习和自然语言处理技术使得与计算机的交互变得更加自然。这意味着，我们可以用更加接近我们日常话语的自然语言来与计算机交流。例如，不用复杂的SQL语句查询数据库，我们可以简单地问：“请告诉我去年的销售额是多少？” 计算机能够理解这个问题，并给出相应的答案。<strong>（就是不懂SQL也可以和计算机对话，AI帮助写sql）</strong></p>
<p>这种转变不仅使得非技术人员更容易与计算机交互，还为开发者提供了更大的便利性。简而言之，我们从“<strong>告诉计算机每一步怎么做</strong>”，转变为“<strong>告诉计算机我们想要什么</strong>”，整个过程变得更加人性化和高效。</p>
<p>下面这个图，非常清晰地解释了这个以LLM为驱动引擎，从自然语言的（模糊）询问，到自然语言的查询结果输出的流程。</p>
<p><img src="https://static001.geekbang.org/resource/image/60/26/60ffbcbe5a891ae74a12d3d5d24cf426.jpg?wh=1571x470" alt="img"></p>
<p>这种范式结合了自然语言处理和传统数据库查询的功能，为用户提供了一个更为直观和高效的交互方式。下面我来解释下这个过程。</p>
<ol>
<li>提出问题：用户用自然语言提出一个问题，例如“去年的总销售额是多少？”。</li>
<li>LLM理解并转译：LLM首先会解析这个问题，理解其背后的意图和所需的信息。接着，模型会根据解析的内容，生成相应的SQL查询语句，例如 “SELECT SUM(sales) FROM sales_data WHERE year &#x3D; ‘last_year’;”。</li>
<li>执行SQL查询：生成的SQL查询语句会被发送到相应的数据库进行执行。数据库处理这个查询，并返回所需的数据结果。</li>
<li>LLM接收并解释结果：当数据库返回查询结果后，LLM会接收到这些数据。然后，LLM会开始解析这些数据，并将其转化为更容易被人类理解的答案格式。</li>
<li>提供答案：最后，LLM将结果转化为自然语言答案，并返回给用户。例如“去年的总销售额为1,000,000元”。</li>
</ol>
<p>你看，用户不需要知道数据库的结构，也不需要具备编写SQL的技能。他们只需要用自然语言提问，然后就可以得到他们所需的答案。这大大简化了与数据库的交互过程，并为各种应用场景提供了巨大的潜力。</p>
<h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><p>这里，我们使用SQLite作为我们的示例数据库。它提供了轻量级的磁盘文件数据库，并不需要单独的服务器进程或系统，应用程序可以直接与数据库文件交互。同时，它也不需要配置、安装或管理，非常适合桌面应用、嵌入式应用或初创企业的简单需求。</p>
<p>SQLite支持ACID（原子性、一致性、隔离性、持久性），这意味着你的数据库操作即使在系统崩溃或电源失败的情况下也是安全的。虽然SQLite被认为是轻量级的，但它支持大多数SQL的标准特性，包括事务、触发器和视图。</p>
<p>因此，它也特别适用于那些不需要大型数据库系统带来的全部功能，但仍然需要数据持久性的应用程序，如移动应用或小型Web应用。当然，也非常适合我们做Demo。</p>
<p>sqlite3库，则是Python内置的轻量级SQLite数据库。通过sqlite3库，Python为开发者提供了一个简单、直接的方式来创建、查询和管理SQLite数据库。当你安装Python时，sqlite3模块已经包含在内，无需再进行额外的安装。</p>
<p>基于这个sqlite3库，创建业务数据的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sqlite3库</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到数据库</span></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;FlowerShop.db&#x27;</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行SQL命令来创建Flowers表</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        CREATE TABLE Flowers (</span></span><br><span class="line"><span class="string">            ID INTEGER PRIMARY KEY, </span></span><br><span class="line"><span class="string">            Name TEXT NOT NULL, </span></span><br><span class="line"><span class="string">            Type TEXT NOT NULL, </span></span><br><span class="line"><span class="string">            Source TEXT NOT NULL, </span></span><br><span class="line"><span class="string">            PurchasePrice REAL, </span></span><br><span class="line"><span class="string">            SalePrice REAL,</span></span><br><span class="line"><span class="string">            StockQuantity INTEGER, </span></span><br><span class="line"><span class="string">            SoldQuantity INTEGER, </span></span><br><span class="line"><span class="string">            ExpiryDate DATE,  </span></span><br><span class="line"><span class="string">            Description TEXT, </span></span><br><span class="line"><span class="string">            EntryDate DATE DEFAULT CURRENT_DATE </span></span><br><span class="line"><span class="string">        );</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入5种鲜花的数据</span></span><br><span class="line">flowers = [</span><br><span class="line">    (<span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;Flower&#x27;</span>, <span class="string">&#x27;France&#x27;</span>, <span class="number">1.2</span>, <span class="number">2.5</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="string">&#x27;2023-12-31&#x27;</span>, <span class="string">&#x27;A beautiful red rose&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Tulip&#x27;</span>, <span class="string">&#x27;Flower&#x27;</span>, <span class="string">&#x27;Netherlands&#x27;</span>, <span class="number">0.8</span>, <span class="number">2.0</span>, <span class="number">150</span>, <span class="number">25</span>, <span class="string">&#x27;2023-12-31&#x27;</span>, <span class="string">&#x27;A colorful tulip&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Flower&#x27;</span>, <span class="string">&#x27;China&#x27;</span>, <span class="number">1.5</span>, <span class="number">3.0</span>, <span class="number">80</span>, <span class="number">5</span>, <span class="string">&#x27;2023-12-31&#x27;</span>, <span class="string">&#x27;An elegant white lily&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Daisy&#x27;</span>, <span class="string">&#x27;Flower&#x27;</span>, <span class="string">&#x27;USA&#x27;</span>, <span class="number">0.7</span>, <span class="number">1.8</span>, <span class="number">120</span>, <span class="number">15</span>, <span class="string">&#x27;2023-12-31&#x27;</span>, <span class="string">&#x27;A cheerful daisy flower&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Orchid&#x27;</span>, <span class="string">&#x27;Flower&#x27;</span>, <span class="string">&#x27;Brazil&#x27;</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">50</span>, <span class="number">2</span>, <span class="string">&#x27;2023-12-31&#x27;</span>, <span class="string">&#x27;A delicate purple orchid&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> flower <span class="keyword">in</span> flowers:</span><br><span class="line">    cursor.execute(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        INSERT INTO Flowers (Name, Type, Source, PurchasePrice, SalePrice, StockQuantity, SoldQuantity, ExpiryDate, Description) </span></span><br><span class="line"><span class="string">        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>, flower)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交更改</span></span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>首先，我们连接到FlowerShop.db数据库。然后，我们创建一个名为Flowers的新表，此表将存储与每种鲜花相关的各种数据。</p>
<p>该表有以下字段：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011936717.jpeg" alt="img"></p>
<p>接着，我们创建了一个名为flowers的列表，其中包含5种鲜花的所有相关数据。使用for循环，我们遍历flowers列表，并将每种鲜花的数据插入到Flowers表中。然后提交这些更改，把它们保存到数据库中。最后，我们关闭与数据库的连接。</p>
<blockquote>
<p>和RAG相比没有经过嵌入，就是原始数据</p>
</blockquote>
<p><strong>用 Chain 查询数据库</strong></p>
<p>用db_chain.run()方法来查询多个与鲜花运营相关的问题，Chain的内部会把这些自然语言转换为SQL语句，并查询数据库表，得到查询结果之后，又通过LLM把这个结果转换成自然语言。</p>
<p>因此，Chain的输出结果是我们可以理解的，也是可以直接传递给Chatbot的人话。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011938884.png" alt="image-20250301193833834"></p>
<p>SQLDatabaseChain调用大语言模型，完美地完成了从自然语言（输入）到自然语言（输出）的新型SQL查询。</p>
<p><strong>用 Agent 查询数据库</strong></p>
<p>除了通过Chain完成数据库查询之外，LangChain 还可以通过SQL Agent来完成查询任务。相比SQLDatabaseChain，使用 SQL 代理有一些优点。</p>
<ul>
<li>它可以根据数据库的架构以及数据库的内容回答问题（例如它会检索特定表的描述）。</li>
<li>它具有纠错能力，当执行生成的查询遇到错误时，它能够捕获该错误，然后正确地重新生成并执行新的查询。</li>
</ul>
<p>LangChain使用create_sql_agent函数来初始化代理，通过这个函数创建的SQL代理包含SQLDatabaseToolkit，这个工具箱中包含以下工具：</p>
<ul>
<li>创建并执行查询</li>
<li>检查查询语法</li>
<li>检索数据表的描述</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.utilities <span class="keyword">import</span> SQLDatabase</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> create_sql_agent</span><br><span class="line"><span class="keyword">from</span> langchain.agents.agent_toolkits <span class="keyword">import</span> SQLDatabaseToolkit</span><br><span class="line"><span class="keyword">from</span> langchain.agents.agent_types <span class="keyword">import</span> AgentType</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到FlowerShop数据库</span></span><br><span class="line">db = SQLDatabase.from_uri(<span class="string">&quot;sqlite:///FlowerShop.db&quot;</span>)</span><br><span class="line">llm = OpenAI(temperature=<span class="number">0</span>, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SQL Agent</span></span><br><span class="line">agent_executor = create_sql_agent(</span><br><span class="line">    llm=llm,</span><br><span class="line">    toolkit=SQLDatabaseToolkit(db=db, llm=llm),</span><br><span class="line">    verbose=<span class="literal">True</span>,</span><br><span class="line">    agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Agent执行SQL查询</span></span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">    <span class="string">&quot;哪种鲜花的存货数量最少？&quot;</span>,</span><br><span class="line">    <span class="string">&quot;平均销售价格是多少？&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> question <span class="keyword">in</span> questions:</span><br><span class="line">    response = agent_executor.run(question)</span><br><span class="line">    <span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<p>可以看到，和Chain直接生成SQL语句不同，代理会使用 ReAct 风格的提示。首先，它思考之后，将先确定第一个action是使用工具 sql_db_list_tables，然后观察该工具所返回的表格，思考后再确定下一个 action是sql_db_schema，也就是创建SQL语句，逐层前进，直到得到答案。</p>
<p><strong>总结</strong></p>
<p>我最想强调的，仍然是从“告诉计算机要做什么”的编程范式向“告诉计算机我们想要什么”的范式的转变。</p>
<p>这种转变具有深远的意义。</p>
<ol>
<li>更大的可达性：不再需要深入的技术知识或特定的编程背景。这意味着非技术人员，比如业务分析师、项目经理甚至是终端用户，都可以直接与数据交互。</li>
<li>高效率与生产力：传统的编程方法需要大量的时间和努力，尤其是在复杂的数据操作中。自然语言处理和理解能够显著减少这种负担，使得复杂的数据操作变得更加直观。</li>
<li>错误的减少：许多编程错误源于对特定语法或结构的误解，通过使用自然语言，这些源于误解的错误将大大减少。</li>
<li>人与机器的紧密结合：在这种新范式下，机器更像是人类的合作伙伴，而不仅仅是一个工具。它们可以理解我们的需求，并为我们提供解决方案，而无需我们明确指导每一步。</li>
</ol>
<p>但这种转变也带来了挑战。</p>
<ol>
<li>模糊性的问题：自然语言本身是模糊的，机器必须能够准确地解释这种模糊性，并在必要时寻求澄清。</li>
<li>对现有系统的依赖：虽然自然语言查询看起来很有吸引力，但许多现有系统可能不支持或不兼容这种新范式。</li>
<li>过度依赖：如果过于依赖机器为我们做决策，那么我们可能会失去对数据的深入了解和对结果的质疑。</li>
</ol>
<h2 id="思考题-15"><a href="#思考题-15" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>LangChain中用Chain和Agent来查询数据库，这两种方式有什么异同？</li>
<li>你能否深入上面这两种方法的代码，看一看它们的底层实现。尤其是要看LangChain是如何做提示工程，指导模型生成 SQL 代码的。</li>
</ol>
<h1 id="18-回调函数：在AI应用中引入异步通信机制"><a href="#18-回调函数：在AI应用中引入异步通信机制" class="headerlink" title="18. 回调函数：在AI应用中引入异步通信机制"></a>18. 回调函数：在AI应用中引入异步通信机制</h1><p>回调函数，你可能并不陌生。它是函数A作为参数传给另一个函数B，然后在函数B内部执行函数A。当函数B完成某些操作后，会调用（即“回调”）函数A。这种编程模式常见于处理异步操作，如事件监听、定时任务或网络请求。</p>
<blockquote>
<p>在编程中，异步通常是指代码不必等待某个操作完成（如I&#x2F;O操作、网络请求、数据库查询等）就可以继续执行的能力。异步机制的实现涉及事件循环、任务队列和其他复杂的底层机制。这与同步编程形成对比，在同步编程中，操作必须按照它们出现的顺序完成。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">x, y, callback</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting compute...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">    result = x + y</span><br><span class="line">    callback(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finished compute...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_result</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;The result is: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">another_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting another task...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Finished another task...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main starts...&quot;</span>)</span><br><span class="line">    task1 = asyncio.create_task(compute(<span class="number">3</span>, <span class="number">4</span>, print_result))</span><br><span class="line">    task2 = asyncio.create_task(another_task())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main ends...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011956347.png" alt="image-20250301195615298"></p>
<p>这个示例中，当我们调用 asyncio.create_task(compute(3, 4, print_result))，compute函数开始执行。当它遇到 await asyncio.sleep(2) 时，它会暂停，并将控制权交还给事件循环。这时，事件循环可以选择开始执行another_task，这是另一个异步任务。这样，你可以清晰地看到，尽管compute函数还没有完成，another_task函数也得以开始执行并完成。这就是异步编程，允许你同时执行多个操作，而不需要等待一个完成后再开始另一个。</p>
<h2 id="LangChain-中的-Callback-处理器"><a href="#LangChain-中的-Callback-处理器" class="headerlink" title="LangChain 中的 Callback 处理器"></a>LangChain 中的 Callback 处理器</h2><p>LangChain 的 Callback 机制允许你在应用程序的不同阶段进行自定义操作，如日志记录、监控和数据流处理，这个机制通过 CallbackHandler（回调处理器）来实现。</p>
<p>回调处理器是LangChain中实现 CallbackHandler 接口的对象，为每类可监控的事件提供一个方法。当该事件被触发时，CallbackManager 会在这些处理器上调用适当的方法。</p>
<p>BaseCallbackHandler是最基本的回调处理器，你可以继承它来创建自己的回调处理器。它包含了多种方法，如on_llm_start&#x2F;on_chat（当 LLM 开始运行时调用）和on_llm_error（当 LLM 出现错误时调用）等。</p>
<p>LangChain 也提供了一些内置的处理器，例如 StdOutCallbackHandler，它会将所有事件记录到标准输出。还有FileCallbackHandler，会将所有的日志记录到一个指定的文件中。</p>
<p>在 LangChain 的各个组件，如 Chains、Models、Tools、Agents 等，都提供了两种类型的回调设置方法：构造函数回调和请求回调。你可以在初始化 LangChain 时将回调处理器传入，或者在单独的请求中使用回调。例如，当你想要在整个链的所有请求中进行日志记录时，可以在初始化时传入处理器；而当你只想在某个特定请求中使用回调时，可以在请求时传入。</p>
<p>这两者的区别，我给你整理了一下。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202503011958517.webp" alt="img"></p>
<p>并发是指多个任务在同一时间段内交替执行，但并不一定同时进行。换句话说，系统通过时间分片的方式，在一段时间内快速切换任务，使得这些任务看起来像是在“同时”运行。</p>
<p>并行是指多个任务真正同时执行，通常需要硬件支持（如多核 CPU 或分布式计算环境）。每个任务独立运行在不同的计算单元上，彼此互不干扰。</p>
<p>在 Python 中，<code>async</code> 和 <code>await</code> 是用于实现<strong>异步编程</strong> 的关键字。它们是 Python 3.5 引入的特性，主要用于处理 I&#x2F;O 密集型任务（如网络请求、文件读写等），从而提高程序的效率和响应速度。</p>
<p>异步编程的核心思想是：当某个任务需要等待（例如等待网络响应或文件读取完成）时，程序不会阻塞，而是可以切换到其他任务继续执行，从而充分利用 CPU 时间。</p>
<p><code>async</code> 关键字用于定义一个<strong>异步函数</strong> （也称为协程函数）。异步函数与普通函数的主要区别在于：</p>
<ul>
<li>异步函数返回的是一个<strong>协程对象</strong> （coroutine object），而不是直接执行函数体。</li>
<li>协程对象需要通过事件循环（event loop）来驱动执行。</li>
</ul>
<p><code>await</code> 关键字用于<strong>暂停</strong> 当前协程的执行，直到等待的操作完成。它只能在异步函数中使用，并且后面必须跟一个<strong>可等待对象</strong> （awaitable object），例如：</p>
<ul>
<li>另一个协程</li>
<li><code>asyncio.Future</code> 对象</li>
<li>其他实现了 <code>__await__</code> 方法的对象</li>
</ul>
<p>事件循环是异步编程的核心机制，负责调度和执行协程。Python 提供了 <code>asyncio</code> 模块来管理事件循环。</p>
<p><strong>总结</strong></p>
<p>回调函数是计算机科学中一个重要和广泛应用的概念，它允许我们在特定的时间或条件下执行特定的代码。</p>
<p>回调函数在开发过程中有很多应用场景。</p>
<ol>
<li>异步编程：在JavaScript中，回调函数常常用于异步编程。例如，当你发送一个AJAX请求到服务器时，你可以提供一个回调函数，这个函数将在服务器的响应到达时被调用。</li>
<li>事件处理：在许多编程语言和框架中，回调函数被用作事件处理器。例如，你可能会写一个回调函数来处理用户的点击事件，当用户点击某个按钮时，这个函数就会被调用。</li>
<li>定时器：你可以使用回调函数来创建定时器。例如，你可以使用JavaScript的setTimeout或setInterval函数，并提供一个回调函数，这个函数会在指定的时间过后被调用。</li>
</ol>
<p>在 LangChain 中，回调机制同样为用户提供了灵活性和自定义能力，以便更好地控制和响应事件。CallbackHandler允许开发者在链的特定阶段或条件下注入自定义的行为，例如异步编程中的响应处理、事件驱动编程中的事件处理等。这为 LangChain 提供了灵活性和扩展性，使其能够适应各种应用场景。</p>
<h2 id="思考题-16"><a href="#思考题-16" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>我通过get_openai_callback重构了ConversationBufferMemory的程序，你能否把这个令牌计数器实现到其他记忆机制中？  </li>
<li>在LangChain开发过程中，可以在构造函数中引入回调机制，我给出了一个示例，你能否尝试在请求过程（run&#x2F;apply方法）中引入回调机制？</li>
</ol>
<p>提示：请求回调常用在流式传输的实现中。在传统的传输中，我们必须等待这个函数生成所有数据后才能开始处理。在流式传输中，我们可以在数据被生成时立即开始处理。如果你想将单个请求的输出流式传输到一个WebSocket，你可以将一个Callback处理器传递给 call() 方法。</p>
<h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><blockquote>
<p>你将学习如何部署一个鲜花网络电商的人脉工具，并开发一个易速鲜花聊天客服机器人。从模型的调用细节，到数据连接的策略，再到记忆的存储与检索，每一个环节都是为了打造出一个更加智能、更加人性化的系统。</p>
<p>至此，你将能够利用LangChain构建出属于自己的智能问答系统，不论是用于企业的应用开发，还是个人的日常应用，都能够得心应手，游刃有余。</p>
</blockquote>
<h1 id="19-CAMEL：通过角色扮演脑暴一个鲜花营销方案"><a href="#19-CAMEL：通过角色扮演脑暴一个鲜花营销方案" class="headerlink" title="19. CAMEL：通过角色扮演脑暴一个鲜花营销方案"></a>19. CAMEL：通过角色扮演脑暴一个鲜花营销方案</h1><ul>
<li><strong>交流式代理</strong> Communicative Agents，是一种可以与人类或其他代理进行交流的计算机程序。这些代理可以是聊天机器人、智能助手或任何其他需要与人类交流的软件。为了使这些代理能够更好地与人类交流，研究人员一直在寻找方法来提高它们的交流能力。</li>
<li><strong>角色扮演</strong> role-playing，则是这篇论文提出的主要思路，它允许交流代理扮演不同的角色，以更好地与人类或其他代理交流。这意味着代理可以模仿人类的行为，理解人类的意图，并据此做出反应。</li>
<li><strong>启示式提示</strong> inception prompting，是一种指导代理完成任务的方法。通过给代理提供一系列的提示或指示，代理可以更好地理解它应该如何行动。这种方法可以帮助代理更好地与人类交流，并完成与人类的合作任务。</li>
</ul>
<p>智能代理在未来世界中将扮演越来越重要的角色。为了使这些代理能够更好地为人类服务，我们需要找到方法来提高它们的交流能力。CAMEL这篇论文提供了一个全新的视角来看待交流代理的发展。通过使用“角色扮演”框架，可以开发出更加智能和人性化的交流代理，这将为我们的日常生活带来更多的便利。</p>
<p>同时，我们也回顾一下CAMEL框架的实现，以及在这个实现中提示设计的特别之处。</p>
<ol>
<li>角色扮演：每个代理都被赋予了一个角色，且每个角色都有清晰的责任和行为准则。比如，Python程序员（助手）的角色是根据股票交易员（用户）的指示提供具体的解决方案，而股票交易员的角色是提供详细的任务指示。这种角色扮演机制有助于模拟人类之间的交互过程，更加真实地完成任务。</li>
<li>任务的具体化：为了使AI更好地理解和执行任务，提出了将抽象任务具体化的步骤。这可以帮助AI更清晰地理解任务需求，更准确地给出解决方案。</li>
<li>初始提示的设定：为了启动会话并提供合适的引导，系统初始化时会提供两个初始提示，一条是助手角色的提示，另一条是用户角色的提示。这两条提示分别描述了各自角色的行为准则和任务细节，为整个对话过程提供了框架和指引。</li>
<li>交互规范：该代码实现中有明确的交互规范，如一次只能给出一个指令，解决方案必须具有详细的解释，使用 “Solution: ” 开始输出解决方案，等等。这些规范有助于保持对话的清晰性和高效性。</li>
</ol>
<p>与传统的提示设计不同，CAMEL中提示的设计更加复杂和细致，更像是一种交互协议或规范。这种设计在一定程度上提高了AI与AI之间自主合作的能力，并能更好地模拟人类之间的交互过程。</p>
<h2 id="思考题-17"><a href="#思考题-17" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>在你的业务需求中，有什么需要细化、具体化的业务场景吗？不妨套用这里的CAMEL代码模板，做一次头脑风暴。</li>
<li>对于这个AI交流代理指导框架和提示模板的设计，你能否说说其优劣之处？有没有能进一步改进的地方？</li>
</ol>
<h1 id="20-BabyAGI：根据气候变化自动制定鲜花存储策略"><a href="#20-BabyAGI：根据气候变化自动制定鲜花存储策略" class="headerlink" title="20. BabyAGI：根据气候变化自动制定鲜花存储策略"></a>20. BabyAGI：根据气候变化自动制定鲜花存储策略</h1><p>随着ChatGPT的崭露头角，我们迎来了一种新型的代理——Autonomous Agents（自治代理或自主代理）。这些代理的设计初衷就是能够独立地执行任务，并持续地追求长期目标。在LangChain的代理、工具和记忆这些组件的支持下，<strong>它们能够在无需外部干预的情况下自主运行，这在真实世界的应用中具有巨大的价值。</strong></p>
<h2 id="思考题-18"><a href="#思考题-18" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>请你阅读 <a href="https://link.juejin.cn/?target=https://github.com/Significant-Gravitas/AutoGPT">AutoGPT</a> 的细节，并构造自己的AI代理。</li>
<li>请你阅读 <a href="https://link.juejin.cn/?target=https://arxiv.org/pdf/2303.17580.pdf">HuggingGPT</a> 的细节，并构造自己的AI代理。</li>
</ol>
<h1 id="21-部署一个鲜花网络电商的人脉工具（上）"><a href="#21-部署一个鲜花网络电商的人脉工具（上）" class="headerlink" title="21. 部署一个鲜花网络电商的人脉工具（上）"></a>21. 部署一个鲜花网络电商的人脉工具（上）</h1><p>这节课我们完成了前两步的工作。分别是，找到适合推广某种鲜花的大V的微博UID，并且爬取了大V的资料。这为我们后续生成文本、进一步链接大V打下了良好的基础。</p>
<p>其中，我们用到了大量之前学习过的LangChain组件，具体包括：</p>
<ol>
<li>用提示模板告诉大模型我们要找到内容（UID）。</li>
<li>调用LLM。</li>
<li>使用Chain。</li>
<li>使用Agent。</li>
<li>在Agent中，我们使用了一个Customized Tool，因为LangChain内置的SerpAPI Tool不能完全满足我们的需要。这给了我们一个好机会创建自己的“私人定制” Tool。</li>
</ol>
<h2 id="思考题-19"><a href="#思考题-19" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>如果Agent不返回UID，而是返回URL，是不是也能够完成这个任务？你可以尝试重构提示模板以及后续逻辑，返回URL，然后手动从URL中解析出UID。</li>
<li>研究一下SerpAPIWrapper类的_process_response中的代码，看看这个方法具体是怎么设计的，用来实现了什么功能？</li>
</ol>
<h1 id="22-部署一个鲜花网络电商的人脉工具（下）"><a href="#22-部署一个鲜花网络电商的人脉工具（下）" class="headerlink" title="22. 部署一个鲜花网络电商的人脉工具（下）"></a>22. 部署一个鲜花网络电商的人脉工具（下）</h1><p><strong>第一步：</strong> 通过LangChain的搜索工具，以模糊搜索的方式，帮助运营人员找到微博中有可能对相关鲜花推广感兴趣的大V（比如喜欢牡丹花的大V），并返回UID。</p>
<p><strong>第二步：</strong> 根据微博UID，通过爬虫工具拿到相关大V的微博公开信息，并以JSON格式返回大V的数据。</p>
<p><strong>第三步：</strong> 通过LangChain调用LLM，通过信息整合以及文本生成功能，根据大V的个人信息，写一篇热情洋溢的介绍型文章，谋求与该大V的合作。</p>
<p><strong>第四步：</strong> 把LangChain输出解析功能加入进来，让LLM生成可以嵌入提示模板的格式化数据结构。</p>
<p><strong>第五步：</strong> 添加HTML、CSS，并用Flask创建一个App，在网络上部署及发布这个鲜花电商人脉工具，供市场营销部门的人员使用。</p>
<h2 id="思考题-20"><a href="#思考题-20" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>修改提示模板，让LLM为你生成更多更有创意、业务上更实用的文案。</li>
<li>试试爬取其他网站（比如豆瓣）上的公开数据，制作更全面的人脉工具。</li>
<li>你或许已经发现，我的这个程序不够鲁棒。这里，我用了牡丹、月季进行了测试，程序都找到了相关的UID，但是当我使用其他一些花的时候，比如玫瑰、野菊花，会出现各种各样的错误。你能否修改程序（比如提示模板、输出解析、整体结构），让程序更健壮？</li>
</ol>
<h1 id="23-易速鲜花聊天客服机器人的开发（上）"><a href="#23-易速鲜花聊天客服机器人的开发（上）" class="headerlink" title="23. 易速鲜花聊天客服机器人的开发（上）"></a>23. 易速鲜花聊天客服机器人的开发（上）</h1><p>这个项目的具体技术实现步骤，这里简述一下。</p>
<p><strong>第一步：</strong> 通过LangChain的ConversationChain，实现一个最基本的聊天对话工具。</p>
<p><strong>第二步：</strong> 通过LangChain中的记忆功能，让这个聊天机器人能够记住用户之前所说的话。</p>
<p><strong>第三步：</strong> 通过LangChain中的检索功能，整合易速鲜花的内部文档资料，让聊天机器人不仅能够基于自己的知识，还可以基于易速鲜花的业务流程，给出专业的回答。</p>
<p><strong>第四步（可选）：</strong> 通过LangChain中的数据库查询功能，让用户可以输入订单号来查询订单状态，或者看看有没有存货等等。</p>
<p><strong>第五步：</strong> 在网络上部署及发布这个聊天机器人，供企业内部员工和易速鲜花用户使用。</p>
<p>在上面的 5 个步骤中，我们使用到了很多LangChain技术，包括提示工程、模型、链、代理、RAG、数据库检索等。</p>
<h2 id="思考题-21"><a href="#思考题-21" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><p>如果你回忆<a target="_blank" rel="noopener" href="https://juejin.cn/book/7387702347436130304/section/7388070989826883621">第11讲</a>，会发现我当时是在ConversationChain中实现了记忆机制。在这节课的示例中，我直接把Memory应用到了LLMChain中，你能否用ConversationChain中的Memory来重构并简化代码？  </p>
<p>提示：ConversationChain实际上是对Memory和LLMChain进行了封装，简化了初始化Memory的步骤。  </p>
</li>
<li><p>我希望在聊天机器人中增加对数据库的查询能力，让用户或者业务人员知道某种鲜花的库存情况、销售情况等等。你能否参考<a target="_blank" rel="noopener" href="https://juejin.cn/book/7387702347436130304/section/7388065974408183858">第17讲</a>的内容，把这个功能整合到这个Chatbot中呢？</p>
</li>
</ol>
<h1 id="24-易速鲜花聊天客服机器人的开发（下）"><a href="#24-易速鲜花聊天客服机器人的开发（下）" class="headerlink" title="24. 易速鲜花聊天客服机器人的开发（下）"></a>24. 易速鲜花聊天客服机器人的开发（下）</h1><p>使用streamlit和Gradio部署ui</p>
<h2 id="思考题-22"><a href="#思考题-22" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>我的易速鲜花Chatbot有很多不完美的地方，比如，检索功能的设计不够细致，UI不够美观，等等。请你在这个Repo的基础上，大刀阔斧地进行改进。</li>
<li>请你用Flask框架设计自己的Chatbot UI，重构聊天机器人，实现更多、更完善的功能。</li>
<li>请你回过头去看看第 02 讲我给你留的3道思考题。那时候，你不了解LangChain，现在你已经基本掌握了它的精髓，能否把第01讲的思考题重新回答一遍呢？应该很有趣吧！</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E7%AE%97%E6%B3%95/"># 算法</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/12/01/2024%E7%A7%8B%E5%AD%A3%E3%80%8A%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">2024秋季《数字图像》课程笔记</a>
            
            
            <a class="next" rel="next" href="/2024/11/01/2024%E7%A7%8B%E5%AD%A3%E3%80%8A%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">2024秋季《数据学习》课程笔记</a>
            
        </section>


    </article>
</div>


    <div id="gitalk-container"></div>
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'blog_comment',
        owner: 'lyxx2535',
        admin: 'lyxx2535',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Annie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | 2020 - 2025
            <br>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    Total visitors:
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;|&nbsp;


<span class="site-pv">
    Total views:
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

          </span>
    </div>
</footer>

    </div>
</body>

</html>