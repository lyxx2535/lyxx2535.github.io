<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Annie">





<title>2022春季《算法》课程笔记 | Annie&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Annie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Annie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">2022春季《算法》课程笔记</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Annie</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">July 1, 2022&nbsp;&nbsp;10:51:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                        分类:
                            
                                <a href="/categories/%E6%9C%AC%E7%A7%91%E7%94%9F%E8%AF%BE%E7%A8%8B/">本科生课程</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h1><ul>
<li>m mod n &#x3D; m - [m&#x2F;n] * n</li>
</ul>
<h2 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a><strong>平均时间复杂度</strong></h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329477.png" alt="image-20220425191127109"></p>
<p>Pr(I):I的出现概率  如何获取？根据经验、简单假设、特殊场景</p>
<p>t(I):耗时</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329474.png" alt="image-20220425191536835"></p>
<h2 id="证明最优性"><a href="#证明最优性" class="headerlink" title="证明最优性"></a><strong>证明最优性</strong></h2><p>算法A是最优的 <strong>（upper &#x3D; lower）</strong></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329484.png" alt="image-20220425191823085"></p>
<h2 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h2><p>仅表示n足够大之后的关系，不表示任何时刻的大小。<br>$$<br>lgn ∈ o(n^a)   对任意a&gt;0<br>$$</p>
<p>$$<br>n^k ∈ o(c^n) 对任意 c&gt;1<br>$$</p>
<p>$$<br>n!&gt;2^n<br>$$</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329482.png" alt="image-20220425192920310"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329486.png" alt="image-20220425194202601"> </p>
<p><strong>查找问题</strong></p>
<ul>
<li>顺序查找：A&#x3D;n&#x2F;2+O(1)</li>
<li>二分查找：A&#x3D;lg(n+1)-q 用决策树证明最坏情况比较次数是lg(<em>n</em>+1):从根节点到叶结点的最长路径</li>
</ul>
<h2 id="求解时间复杂度"><a href="#求解时间复杂度" class="headerlink" title="求解时间复杂度"></a>求解时间复杂度</h2><p>用关键操作作为次数。</p>
<h4 id="替换法解递归"><a href="#替换法解递归" class="headerlink" title="替换法解递归"></a>替换法解递归</h4><h4 id="特征方程法"><a href="#特征方程法" class="headerlink" title="特征方程法"></a>特征方程法</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329494.png" alt="image-20220425201637362" style="zoom:25%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329949.png" alt="image-20220425201713104" style="zoom:25%;" />

<p>不太常用。</p>
<h4 id="guess-and-proof"><a href="#guess-and-proof" class="headerlink" title="guess and proof"></a>guess and proof</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329969.png" alt="image-20220425202024555" style="zoom:50%;" />

<p>两侧都证明一下最准。</p>
<h4 id="递推树"><a href="#递推树" class="headerlink" title="递推树"></a>递推树</h4><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329988.png" alt="image-20220425204647953"></p>
<p><strong>常用公式</strong></p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329008.png" alt="image-20220425205910796" style="zoom:50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329025.png" alt="image-20220425205955959" style="zoom:50%;" />

<h2 id="重点题"><a href="#重点题" class="headerlink" title="重点题"></a>重点题</h2><p>1、有效字符串数量 abc 不能有aa  很巧妙的分治法！</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329048.png" alt="image-20220425211550331" style="zoom:50%;" />

<p>2、guess and proof化成好证明的形式</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329686.png" alt="image-20220425214023124" style="zoom:50%;" />

<p>3、多用归纳法 多找规律</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329705.png" alt="image-20220425215258846"></p>
<h1 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329734.png" alt="image-20220426164747651" style="zoom: 25%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329760.png" alt="image-20220426164801208" style="zoom:25%;" />

<p>最差和平均时间复杂度都是O(n^2)</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>法一：不断找HighVac和LowVac，好理解但是算法比较难写</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329783.png" alt="image-20220426170714790" style="zoom:50%;" /><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329805.png" alt="image-20220426170730455"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329805.png" alt="image-20220426170730455"></p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329072.png" alt="image-20220426170004685" style="zoom: 50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329429.png" alt="image-20220426165916113" style="zoom:50%;" />

<p>通过guess and proof证明两个方向，可得时间复杂度为O(nlgn)，空间复杂度是O(n)</p>
<p>法二：partition更简明的实现</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329442.png" alt="image-20220426203351728" style="zoom:50%;" />

<p>J：指向没有排序的第一个元素</p>
<p>i：指向&lt;&#x3D;x的最后一个元素</p>
<p>i+1后指向A[j] 已知A[j]&lt;&#x3D;x 所以交换 相当于**&lt;&#x3D;x的域**增大了</p>
<p>然后再把j++，继续比较。ij之间的是&gt;&#x3D;x的元素                      </p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329470.png" alt="image-20220426173026077" style="zoom:50%;" />

<p>把两个已排序的数组合并。一个序列的元素远小于另一个序列，这样的merge如何处理？<strong>Using binary search</strong>.</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329516.png" alt="image-20220426173629374" style="zoom: 50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329535.png" alt="image-20220426173708571" style="zoom:50%;" />

<p>越平衡epl越小，所以从两个方向证明了算法的复杂度。</p>
<p>还可以不用递归，用队列迭代实现合并排序：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329647.png" alt="image-20220426175752571" style="zoom: 50%;" /><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329724.png" alt="image-20220426175759156"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329647.png" alt="image-20220426175752571" style="zoom: 50%;" /><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329724.png" alt="image-20220426175759156"></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>1.层 &#x3D; 1 + 结点与root之间边的个数</p>
<p>2.深度 &#x3D; 层 – 1 &#x3D; 结点与root之间边的个数</p>
<p>3.结点高度：与叶结点leaf的最长距离</p>
<p>4.树高度：root的height</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329014.png" alt="image-20220426181525991" style="zoom: 50%;" />

<h4 id="fixheap：θ-h-θ-logn"><a href="#fixheap：θ-h-θ-logn" class="headerlink" title="fixheap：θ(h)&#x3D;θ(logn)"></a>fixheap：θ(h)&#x3D;θ(logn)</h4><p>fixHeap：把最后一个元素设为root 然后自顶向下 最差情况：2h次比较</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329035.png" alt="image-20220426200113747" style="zoom:50%;" />

<h4 id="堆的构建θ-n"><a href="#堆的构建θ-n" class="headerlink" title="堆的构建θ(n)"></a>堆的构建θ(n)</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329063.png" alt="image-20220426200303688" style="zoom:50%;" />

<p>递归：左子树是堆，右子树是堆，把K插到root，然后用fixheap修复即可</p>
<p>W(n)&#x3D;W(n-r-1)+W(r)+2lg(n)  得到线性时间θ(n)</p>
<h4 id="堆的排序θ-nlogn"><a href="#堆的排序θ-nlogn" class="headerlink" title="堆的排序θ(nlogn)"></a>堆的排序θ(nlogn)</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329128.png" alt="image-20220426200750603" style="zoom:50%;" />

<p>不断取root，然后用fixheap修复</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329152.png" alt="image-20220426200944863" style="zoom:50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329213.png" alt="image-20220426201003908" style="zoom:50%;" />

<p>利用堆数组下标的规律 堆排序的复杂度是θ(nlogn)</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329608.png" alt="image-20220426201516352" style="zoom:50%;" />

<p>利用分治思想（二分）可提高fixHeap效率，从2nlogn变成nlogn</p>
<p>堆可实现优先级队列。</p>
<p>其他排序：Shell sort&#x2F;Radix sort O(kn)&#x2F;Bucket sort在桶内排好序</p>
<p>用递归树分析，平均情况更接近best  case而不是worst case</p>
<h2 id="重点题-1"><a href="#重点题-1" class="headerlink" title="重点题"></a>重点题</h2><p>1、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329628.png" alt="image-20220426172616627" style="zoom: 50%;" />

<p>重点是用<strong>折半查找</strong>找最近的点</p>
<p>2、</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329442.png" alt="image-20220426203351728" style="zoom: 33%;" /><img src="C:\Users\84368\AppData\Roaming\Typora\typora-user-images\image-20220426204443435.png" alt="image-20220426204443435" style="zoom: 50%;" /></p>
<p>利用<strong>quciksort中的partition操作</strong>（可以有效划分颜色区域），设定 red &lt; white &lt; blue</p>
<p>1）选择white作为pivot， 那么 &lt;&#x3D; white 的为 red和white， &gt;white 的为blue</p>
<p>2）选择red或者white作为pivot，对 “&lt;&#x3D; white 的为 red和white” 部分进行排序</p>
<p>复杂度&lt;&#x3D;2(n-2) &#x3D; O(n), where n is the number of all elements in the given array</p>
<p>3、逆序对个数用归并排序</p>
<p>4、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329724.png" alt="image-20220426205223865" style="zoom:50%;" />

<p>找x&#x3D;a+b：对B排序：nlgn，排序后遍历a，通过二分查找看b——&gt;O(nlgn)</p>
<p>5、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329744.png" alt="image-20220426205333413" style="zoom:50%;" />

<p>解答：<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329792.png" alt="image-20220426210101424" style="zoom:33%;" />难点在于想到b+S和最接近！！！</p>
<p>6、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329231.png" alt="image-20220426210214918" style="zoom:50%;" />匹配螺丝螺帽问题，注意只能把螺丝和螺帽比较！</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329252.png" alt="image-20220426210458790" style="zoom:50%;" />

<p>Partition并不是排序，只是把小的和大的放两边，所以要继续递归</p>
<p>7、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329275.png" alt="image-20220426211045896" style="zoom:50%;" />

<p>寻找第k大的数 最重要的是在前k层 可以忽略后面的n-k层</p>
<p>8、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329297.png" alt="image-20220426211629910"></p>
<p>从右上角找！x&#x3D;c找到 x&lt;c 不在最后一列 x&gt;c不在第一行 时间复杂度O(m+n)空间复杂度O(1)(没用其他空间)</p>
<p>9、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329323.png" alt="image-20220426212039771" style="zoom:50%;" />

<p>找Maxima：相当于从右下角开始找小红点！i从大到小很重要</p>
<h1 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h1><h2 id="找最大值和最小值"><a href="#找最大值和最小值" class="headerlink" title="找最大值和最小值"></a>找最大值和最小值</h2><p>若只找最大值：用对手论证证明必须要n-1次比较，产生n-1个loser。</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329352.png" alt="image-20220426212528230" style="zoom:50%;" />

<p>对手论证分析：max&#x2F;min只有1个标签，其他2个 至少2n-2个标签：根据下图，至少比较n&#x2F;2+n-2次</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329836.png" alt="image-20220426212640795" style="zoom:50%;" />

<h2 id="找第二大元素"><a href="#找第二大元素" class="headerlink" title="找第二大元素"></a>找第二大元素</h2><p>只输给过max，备选元素最多有[lgn]个元素</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329864.png" alt="image-20220426213054193" style="zoom:50%;" /><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329885.png" alt="image-20220426213251713"></p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329909.png" alt="image-20220426213324541" style="zoom:50%;" />

<p>而可用对手论证迫使max和[lgn]个元素比较过：每次比较后新权重不超过旧权重的2倍</p>
<h2 id="找中位数"><a href="#找中位数" class="headerlink" title="找中位数"></a>找中位数</h2><h4 id="Select-Elinear期望线性时间"><a href="#Select-Elinear期望线性时间" class="headerlink" title="Select-Elinear期望线性时间"></a>Select-Elinear期望线性时间</h4><p>利用中位数在partition后数量多的一侧。</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329937.png" alt="image-20220426213519838" style="zoom:50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329962.png" alt="image-20220426213604927" style="zoom:33%;" />

<p>平均是O(n)，最差是O(n^2)</p>
<h4 id="Select-Wlinear最坏情况线性时间"><a href="#Select-Wlinear最坏情况线性时间" class="headerlink" title="Select-Wlinear最坏情况线性时间"></a>Select-Wlinear最坏情况线性时间</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329540.png" alt="image-20220426213812845" style="zoom:50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329570.png" alt="image-20220426214906793" style="zoom:50%;" />

<p>最差也是θ(n)</p>
<p>任何一个选择算法，必须知道每一个元素和中位数的相对大小关系</p>
<p>找中位数的<strong>Lower Bound</strong>：(n-1)&#x2F;2+(n-1)</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329587.png" alt="image-20220426230753032" style="zoom:50%;" />

<h2 id="对手论证"><a href="#对手论证" class="headerlink" title="对手论证"></a>对手论证</h2><p>1、5位数有没有111 4次够3次不够（维护11111和00000）</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329609.png" alt="image-20220426231344401" style="zoom:50%;" />

<p>2、判断是否连通：每条边都看 否则两种情况均成立</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329639.png" alt="image-20220426231845776" style="zoom:50%;" />

<h2 id="重点题-2"><a href="#重点题-2" class="headerlink" title="重点题"></a>重点题</h2><p>1、O(n)寻找名人：每次随机找两个人，淘汰一个人</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329680.png" alt="image-20220426235014522" style="zoom:50%;" />

<p>2、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329268.png" alt="image-20220427000032056" style="zoom:50%;" />

<p>最快的马：至少赛6场</p>
<p>第二快的马：直接输给过A1的马，两个候选：A2和B1</p>
<p>第三快的马：直接“输过”最快或第二快的马，共有3个候选：A3、B2、C1</p>
<p>（2）(3)综合，再比一场比赛，共7场。</p>
<p>3、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329295.png" alt="image-20220427000802334" style="zoom: 67%;" /></p>
<p>1）调用一次SORT5淘汰4个元素，所以使用[(n-1)&#x2F;4]次</p>
<p>2）直接输给过max的数量是[log5n]（类似于最大元素直接的比较次数为[log2n]）</p>
<p>4、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329319.png" alt="image-20220427000937586" style="zoom:67%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329350.png" alt="image-20220427001230631" style="zoom: 50%;" />

<p>5、带权中位数</p>
<p>O(nlgn)：先排序 然后遍历看weighted median</p>
<p>O(n)：<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329377.png" alt="image-20220427001435213" style="zoom:50%;" /></p>
<p><strong>注意partition可算wL和wG</strong></p>
<p>6、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329402.png" alt="image-20220427100308035" style="zoom:50%;" /></p>
<p>若已排序：暴力，二分查找（M&gt;n&#x2F;2：未出现数在前一半；M&#x3D;n&#x2F;2：未出现数在后一半）</p>
<p>若未排序：新开一个长为n的flag数组，进行两次遍历；也可以用找中位数的线性算法（M&gt;n&#x2F;2：未出现数在前一半；M&#x3D;n&#x2F;2：未出现数在后一半）</p>
<p>7、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329942.png" alt="image-20220427101158813" style="zoom:50%;" />3种复杂度</p>
<p>8、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329964.png" alt="image-20220427101436591" style="zoom: 67%;" /></p>
<p>法一：找中位数</p>
<ul>
<li>若确定有重元素：必然是中位数</li>
<li>不确定：用中位数扫描数组，若数量大于n&#x2F;2，则有，反之则没有</li>
</ul>
<p>法二：根据重元素&gt;n&#x2F;2，其他元素&lt;n&#x2F;2，遇见不同数字则减1  最终重元素一定次数&gt;&#x3D;1</p>
<h1 id="part4"><a href="#part4" class="headerlink" title="part4"></a>part4</h1><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329996.png" alt="image-20220427102037805" style="zoom:50%;" />

<p>二分查找</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329021.png" alt="image-20220427102146948" style="zoom:50%;" />

<p>（1）是二叉树（2）右边比根节点大，左边比根节点小</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329056.png" alt="image-20220427102355872" style="zoom:50%;" />

<p>node group 是任意连通的内部节点群</p>
<p>如果S的父节点在这个节点群中，但是S中没有任何节点在这个结点群中，那么S是一个节点群的<strong>principal</strong> <strong>subtree</strong>（概念对旋转有用）</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329080.png" alt="image-20220427102631376" style="zoom: 50%;" /><img src="C:\Users\84368\AppData\Roaming\Typora\typora-user-images\image-20220427103007320.png" alt="image-20220427103007320" style="zoom: 25%;" /></p>
<p>T是RB TREE：</p>
<p>1、二叉树</p>
<p>2、所有外部结点(叶子结点)是黑色</p>
<p>3、根节点是黑色</p>
<p>4、没有一个红色结点有红色孩子</p>
<p>5、所有叶结点的黑色高度一样：到根节点路径上黑色结点的数量一样（不包括根节点）</p>
<p>T是ARB TREE</p>
<p>1、根节点是红色</p>
<p>2、其他和RB TREE一样</p>
<p>（还有循环定义）</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329572.png" alt="image-20220427102803050" style="zoom: 50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329597.png" alt="image-20220427103409023" style="zoom:50%;" />

<p>黑色高度为h 内部节点个数为n</p>
<p>n&gt;&#x3D;2^h-1 至少有这么多结点 说明树的黑色高度有上界<strong>2lg(n+1)</strong></p>
<p>只要操作得当，<strong>增删元素的复杂度都是O(logn)</strong></p>
<h2 id="哈希O-1-α"><a href="#哈希O-1-α" class="headerlink" title="哈希O(1+α)"></a>哈希O(1+α)</h2><h4 id="闭地址-开散列"><a href="#闭地址-开散列" class="headerlink" title="闭地址&#x2F;开散列"></a>闭地址&#x2F;开散列</h4><p>用链表结构。增删：O(1) 查询：O(1+α)</p>
<h4 id="开地址-闭散列"><a href="#开地址-闭散列" class="headerlink" title="开地址&#x2F;闭散列"></a>开地址&#x2F;闭散列</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329617.png" alt="image-20220427112938304" style="zoom:50%;" />

<p>查找代价和插入代价均为：1&#x2F;(1-α) 查找成功的平均代价：<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329668.png" alt="image-20220427113222367"></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329694.png" alt="image-20220427113609069" style="zoom:50%;" />

<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329224.png" alt="image-20220427114032462"></p>
<p>n个元素，m个操作（union和find）：union操作的复杂度是O(1)find操作的复杂度是O(n) 总复杂度是<strong>O(mn)</strong></p>
<h4 id="加权并wUnion-普通查"><a href="#加权并wUnion-普通查" class="headerlink" title="加权并wUnion+普通查"></a>加权并wUnion+普通查</h4><p>易证使用wUnion后，k个结点的树高度不超过[logk]。</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329248.png" alt="image-20220427114856001" style="zoom:50%;" />

<p>改进的地方在于find最差不是O(n)，而是O([lgn]+1)。总时间复杂度是O(n+mlogn)</p>
<h4 id="加权并-路径压缩查cFind"><a href="#加权并-路径压缩查cFind" class="headerlink" title="加权并+路径压缩查cFind"></a>加权并+路径压缩查cFind</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329274.png" alt="image-20220427115405576" style="zoom:50%;" />

<p>*O((<strong>n+m</strong>)lg*(n))*：让cFind代价变小了</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329304.png" alt="image-20220427122754815" style="zoom:50%;" />

<p>数组扩容的均摊分析：</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329339.png" alt="image-20220427115755791" style="zoom:50%;" />

<h2 id="均摊分析"><a href="#均摊分析" class="headerlink" title="均摊分析"></a>均摊分析</h2><h4 id="记账法"><a href="#记账法" class="headerlink" title="记账法"></a>记账法</h4><p>1、Multi-pop栈</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329372.png" alt="image-20220427122033479" style="zoom:50%;" />



<h2 id="重点题-3"><a href="#重点题-3" class="headerlink" title="重点题"></a>重点题</h2><p>1、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329085.png" alt="image-20220427110934412" style="zoom:50%;" /></p>
<p>找轴值：当ary[mid] &gt; ary[l]时，可以知道轴值一定位于右半边，到底是[mid, r]还是[mid + 1, r]呢，由假定条件ary[mid] &gt; ary[l]可以知道ary[mid]肯定不是最小的元素所以可以区间是[mid + 1, r]。否则，即ary[mid] &lt; ary[l]，可以知道轴值位于左半边，到底是[l, mid]还是[l, mid - 1]呢？我们从这时的假定条件不能继续缩小范围，所以轴值的范围就是[l, mid]。</p>
<p>2、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329113.png" alt="image-20220427111356497" style="zoom:67%;" />

<p>注意间隔查找的方法。</p>
<p>3、<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329147.png" alt="image-20220427111725865" style="zoom:80%;" /></p>
<p><strong>比较mid index和k的关系</strong></p>
<p>1、a的mid+b的mid比k小：如果a的mid比b的mid大，舍弃b的前一半（太小了）； 否则舍弃a的前一半</p>
<p>2、比k大：如果a的mid比b的mid大，舍弃a的后一半（太大了）；否则舍弃b的后一半</p>
<p>4、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329169.png" alt="image-20220427120331938" style="zoom:50%;" />

<p>查找成功：针对这里的7个数。</p>
<p>查找不成功：对于hash到0的数：一直到6才知道不在里面（看hash到0-9的数）</p>
<p>5、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329191.png" alt="image-20220427121014178" style="zoom: 80%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329223.png" alt="image-20220427120928859" style="zoom:50%;" />

<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329732.png" alt="image-20220427120946805" style="zoom:50%;" />

<p>6、</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329750.png" alt="image-20220427122829019" style="zoom:50%;" />

<h1 id="part5"><a href="#part5" class="headerlink" title="part5"></a>part5</h1><h2 id="有向图DFS"><a href="#有向图DFS" class="headerlink" title="有向图DFS"></a>有向图DFS</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329774.png" alt="image-20220616193113696"></p>
<p>O(n+m)</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329795.png" alt="image-20220616193152025"></p>
<ul>
<li>TE：u的邻居v是白色，没有访问过</li>
<li>BE：u的邻居v被访问，且v是u是祖先</li>
<li>DE：u的邻居v被访问，且v是u的后继</li>
<li>CE：u的邻居v被访问，但没有祖先后继关系</li>
</ul>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329828.png" alt="image-20220616193657817"></p>
<p>活动区间：就是灰色的时间</p>
<ol>
<li>vw是CE（不重合，没有祖先子孙关系），<em>active</em>(<em>w</em>)先于<em>active</em>(<em>v</em>)</li>
<li>vw是DE（w是v的后继），<strong>存在x</strong>，<em>active</em>(<em>w</em>)包含于<em>active</em>(<em>x</em>)包含于<em>active</em>(<em>v</em>)</li>
<li>vw是TE，<em>active</em>(<em>w</em>)包含于<em>active</em>(<em>v</em>), 并且不存在x（直接父子关系）</li>
<li>vw是BE，<em>active</em>(<em>v</em>)包含于<em>active</em>(<em>w</em>)（直接父子关系）</li>
</ol>
<h3 id="白色路径定理"><a href="#白色路径定理" class="headerlink" title="白色路径定理"></a>白色路径定理</h3><p>v是w的祖先 iff v刚被发现时，存在一条v到w的全部由白色结点组成的路径</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329857.png" alt="image-20220616195330091">拓扑排序</h3><p>对于任何边vw，都有（v的拓扑序号）&lt;（w的拓扑序号）</p>
<p>逆拓扑排序（如图代码）：对于边vw：（v的拓扑序号）&gt;（w的拓扑序号）</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329435.png" alt="image-20220616200014998"></p>
<p>必须是DAG（有向无环图），否则有循环依赖造成“死锁”。</p>
<p> 没有BE！所以对于边vw，一直有finishTime(v)&gt;finishTime(w)</p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>假设任务是有持续时间的（AOV网络，AOE网络）</p>
<p>1。est最早开始时间：v没有依赖，est&#x3D;0；v有依赖，est&#x3D;依赖的eft</p>
<p>2。最早结束时间：eft&#x3D;est+持续时间</p>
<p>3。关键路径v0àvk：v0没有依赖；vi依赖于vi-1，vi的est&#x3D;vi-1的eft；vk的eft是所有任务的最大时间</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329457.png" alt="image-20220616200855341"></p>
<p>邻居是白色，就dfs。</p>
<p>不管所依赖的对象是不是白色，都要比较邻居w的eft和自身当前的est！</p>
<h3 id="强连通片SCC"><a href="#强连通片SCC" class="headerlink" title="强连通片SCC"></a>强连通片SCC</h3><p>强连通片：任意两个结点之间可达。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329479.png" alt="image-20220616201301509"></p>
<p>算法：1.对原图G做dfs，结点先结束先入栈。栈内时间从小到大排列。</p>
<p>2.将G转置。</p>
<p>3.依次取出栈中结点进行dfs，标记每个强连通片。</p>
<h2 id="无向图DFS"><a href="#无向图DFS" class="headerlink" title="无向图DFS"></a>无向图DFS</h2><p>只有<strong>TE和BE</strong>，没有CE和DE。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329515.png" alt="image-20220616204526604"></p>
<p>变化在于如果是白色：check TE。如果是灰色且w不是parent，check BE.</p>
<h3 id="寻找割点"><a href="#寻找割点" class="headerlink" title="寻找割点"></a>寻找割点</h3><p>判断条件：从TE vw回退时，w.back&gt;&#x3D;v.discoverTime，则v是割点。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329541.png" alt="image-20220616205222314"></p>
<p>寻找桥：从TE vw回退时，w.back&gt;v.discoverTime，则vw是桥。(只去掉了&#x3D;)</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329568.png" alt="image-20220616205349758"></p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329103.png" alt="image-20220616195447527"></p>
<p>有向图中：没有DE</p>
<p>无向图中：没有BE和DE</p>
<h3 id="判断二分图"><a href="#判断二分图" class="headerlink" title="判断二分图"></a>判断二分图</h3><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329126.png" alt="image-20220616210620184"></p>
<p>如果没访问过，颜色取反；访问过的话看颜色是否不一样</p>
<h3 id="寻找k度子图"><a href="#寻找k度子图" class="headerlink" title="寻找k度子图"></a>寻找k度子图</h3><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329152.png" alt="image-20220616211004226"></p>
<h2 id="重点题-4"><a href="#重点题-4" class="headerlink" title="重点题"></a>重点题</h2><ol>
<li><p>判断是不是森林？</p>
<ul>
<li>树是无环的连通分量，所以判断无向图无环即可，即没有<strong>BE</strong>。</li>
<li>执行DFS，复杂度为O(n)</li>
</ul>
</li>
<li><p>计算每个点的cost</p>
<ul>
<li><p>不管子节点w是什么颜色，如果w的cost更小，赋值给cost[v]</p>
</li>
<li><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329182.png" alt="image-20220616211656353"></p>
</li>
</ul>
</li>
<li><p>一条边e是否在无向图G中（假设e是边ab）</p>
<ul>
<li>删e，从a或b开始DFS，看能不能<strong>搜索到另一点</strong>（若有环，a-&gt;b至少有两条路径），复杂度为O(m+n)</li>
</ul>
</li>
<li><p>捣蛋小孩排队</p>
<ol>
<li><p>若i-&gt;j,i在j前面</p>
<ol>
<li>先判断G是否<strong>DAG</strong>（有back edge则有环，否则无环）；如果有环，则不存在符合条件的排队方法。复杂度O(n+m) </li>
<li>如果G是DAG，对他执行拓扑排序。根据拓扑排序的性质，如果i到j有边（i hates j），则i会排在j前面，因此拓扑排序是符合要求的排队方法。拓扑排序复杂度为O(n+m)。</li>
<li>综上，复杂度为O(n+m)</li>
</ol>
</li>
<li><p>若i-&gt;j，i在j前面的行</p>
<ol>
<li>对G中的每条边赋给权重1，这样，求G的一条<strong>最长路径</strong>，就是排队所需要的最少行数。</li>
<li>问题转化为求G的关键路径问题，使用关键路径算法，复杂度为O(n+m)。</li>
</ol>
</li>
</ol>
</li>
<li><p>给定一个点是否能到达其他所有点：DFS BFS均可，结束后看有没有白色点</p>
</li>
<li><p>是否存在一个点，能够到达其他所有点：</p>
<ul>
<li>首先执行强连通分支算法SCC,形成收缩图G’    <strong>O(n+m)</strong></li>
<li>对收缩图，找出G’中<strong>入度为0</strong>的点   O(n)</li>
</ul>
</li>
<li><p>供水问题：</p>
</li>
</ol>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329229.png" alt="image-20220616213502580"></p>
<ol start="8">
<li><p>端点问题：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329253.png" alt="image-20220616213702185"></p>
<ul>
<li>端点的出度必然为0，而且是<strong>唯一</strong>的，因为如果有两个出度为0的点，则相互之间不能到达，与端点定义矛盾。假设图的顶点数为n，边数为m。算法为：<ul>
<li>扫描全图，找出<strong>出度为0</strong>的点N。如果这样的点不唯一，则输出“不存在端点”。复杂度为O(n)   <ul>
<li>（这里并不代表他可以到达其他所有点，所以要下面步骤）</li>
</ul>
</li>
<li>构造该图的<strong>反向图</strong>（即让所有边的方向都反转）。复杂度为**O(n+m)**。</li>
<li>从点N开始，用DFS或BFS遍历，如果可以<strong>遍历所有节点</strong>，则N为端点，否则，输出“不存在端点”。复杂度为O(n+m)。</li>
<li>综上，复杂度为O(n+m)。</li>
</ul>
</li>
</ul>
</li>
<li><p>所有路均为单向，希望两两可达：用SCC看G是不是一个强连通分量</p>
<p>如果从某地开始，到哪里都可以返回该地：看在不在Sink SCC（出度为0，只在自己的连通片里走）里面</p>
</li>
</ol>
<h1 id="part6"><a href="#part6" class="headerlink" title="part6"></a>part6</h1><h2 id="最小生成树MST"><a href="#最小生成树MST" class="headerlink" title="最小生成树MST"></a>最小生成树MST</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>不断选相邻的最小边：难选（no cycle &amp; small weight）+好检查</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329193.png" alt="image-20220616214844155"></p>
<p>每个结点的状态从 unseen-&gt;fringe-&gt;finished不可逆</p>
<p>取最小的边对应的点加入，看新加的点v的邻居w：</p>
<p>如果w未被发现，加入Fringe;否则看是否要更新权重<br>$$<br>T(n,m) &#x3D; O(nT(getMin)+nT(deleteMin)+ nT(insert)+mT(decreaseKey))<br>$$<br><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329235.png" alt="image-20220616215354421"></p>
<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>好选（最小的边），难检查（no cycle） 不停选最小，然后看在不在一个并查集里面</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329266.png" alt="image-20220616215713218"></p>
<p>O(mlogm)&#x3D;O(mlogn)</p>
<h2 id="MCE"><a href="#MCE" class="headerlink" title="MCE"></a>MCE</h2><p>如果存在cut让e在MCE，则e一定在一个MST里面。用反证法证明。</p>
<h2 id="给定源点最短路径SSSP"><a href="#给定源点最短路径SSSP" class="headerlink" title="给定源点最短路径SSSP"></a>给定源点最短路径SSSP</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>拿最小，找邻居，更新dis（不能有负边）</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329291.png" alt="image-20220616220625417"><br>$$<br>T(n,m) &#x3D; O(nT(getMin)+nT(deleteMin)+ nT(insert)+mT(decreaseKey))<br>$$<br><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329336.png" alt="image-20220616220706507"></p>
<p>和Prim式子一样的。</p>
<p>应用1：顶点也有权重了 在newWgt那里加入即可</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329352.png" alt="image-20220616220836972"></p>
<p>应用2：水管问题 Maximize the min edge weight</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329734.png" alt="image-20220616221145113"></p>
<p>应用3：Minimize the max edge weight</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329866.png" alt="image-20220616221340450"></p>
<h1 id="part7"><a href="#part7" class="headerlink" title="part7"></a>part7</h1><h2 id="所有点对最短路径问题APSP"><a href="#所有点对最短路径问题APSP" class="headerlink" title="所有点对最短路径问题APSP"></a>所有点对最短路径问题APSP</h2><h3 id="is-there-a-shortest-path"><a href="#is-there-a-shortest-path" class="headerlink" title="is there a shortest path"></a>is there a shortest path</h3><p>传递闭包：看i-&gt;j是否可达。</p>
<p>BF1：暴力枚举所有点</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329932.png" alt="image-20220616235023527" style="zoom: 67%;" />

<p>BF2：暴力枚举所有边<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329955.png" alt="image-20220616235140181" style="zoom: 67%;" /></p>
<p>BF3：添加长度，上标表示有没有长度&lt;&#x3D;k的路径</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329973.png" alt="image-20220616235323886" style="zoom:67%;" />

<h4 id="Warshall"><a href="#Warshall" class="headerlink" title="Warshall"></a>Warshall</h4><p>O(n^3)</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329992.png" alt="image-20220616235657219" style="zoom:50%;" />

<h3 id="what-is-the-shortest-path"><a href="#what-is-the-shortest-path" class="headerlink" title="what is the shortest path"></a>what is the shortest path</h3><h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329289.png" alt="image-20220617000115405" style="zoom:50%;" />

<p>不能有负环</p>
<h3 id="Solve-SSSP-and-detect-negative-cycles"><a href="#Solve-SSSP-and-detect-negative-cycles" class="headerlink" title="Solve SSSP and detect negative cycles"></a>Solve SSSP and detect negative cycles</h3><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><p>和上面有挺大不同：除了起点初始化为0，其他初始化为正无穷。然后进行n-1次松弛计算。</p>
<p>i是指从起点开始，经过几条边。</p>
<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329308.png" alt="image-20220617000830010" style="zoom:50%;" />

<h2 id="重点题-5"><a href="#重点题-5" class="headerlink" title="重点题"></a>重点题</h2><ol>
<li><p>最优二叉搜索树：<em>A</em>(low, high, <em>r</em>) is the minimum weighted retrieval cost for subproblem (low, high) when <em>Kr</em> is chosen as the root of its binary search tree.当Kr被选成root时最小的加权代价</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329331.png" alt="image-20220617204419900"></p>
</li>
<li><p>最大子串和：分为不用l和用l两种情况<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329356.png" alt="image-20220617204629362"></p>
</li>
<li><p>硬币找零   <em>c</em>[<em>i</em>,<em>j</em>] &#x3D; min (<em>c</em>[<em>i</em>-1, <em>j</em>],1+<em>c</em>[<em>i</em>, <em>j</em>-<em>d</em>i])</p>
</li>
</ol>
<h1 id="part8"><a href="#part8" class="headerlink" title="part8"></a>part8</h1><p>P问题：f(n)&#x3D;O(poly(n))</p>
<p>NP问题：Non-deterministic P 多项式时间内可验证</p>
<ul>
<li>给一个解，可在多项式时间内验证该解是不是该问题的一个解</li>
</ul>
<h2 id="多项式规约"><a href="#多项式规约" class="headerlink" title="多项式规约"></a>多项式规约</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329378.png" alt="image-20220617211435699"></p>
<p>P-&gt;Q有转换函数T(x)，P对x的输出为YES，当且仅当Q对T(x)的输出为YES</p>
<p>NP-hard问题：每个NP问题E都可以规约到Q，则Q是NPC问题。</p>
<ul>
<li>证明：从一个NP-hard的问题规约到它即可，利用传递性。</li>
</ul>
<p>NPC问题：证明同时是NP和NPC问题。</p>
<h2 id="重点题-6"><a href="#重点题-6" class="headerlink" title="重点题"></a>重点题</h2><ol>
<li><p>注意必须要添加x，直接连接st不行<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329400.png" alt="image-20220617212732575"></p>
</li>
<li><p>发现除去最小点覆盖，剩下的点自然是独立集<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329978.png" alt="image-20220617212851679"></p>
</li>
<li><p>取补图作为CLIQUE的输入<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329007.png" alt="image-20220617212952482"></p>
</li>
<li><p>把每个clause生成3个顶点，然后取补图。<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329035.png" alt="image-20220617213147673"></p>
</li>
</ol>
<h1 id="往年题"><a href="#往年题" class="headerlink" title="往年题"></a>往年题</h1><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329061.png" alt="image-20220617220217232"></p>
<p>e1,e2,e3分别是最小、次小、第三小的边。反证法都比较有效。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502032329105.png" alt="image-20220617221833409"></p>
<p>a.边数确定 n-1条边 权值变化一样</p>
<p>b.不对 边数不一定 因为权重会+每条边*100</p>
<h1 id="考试review"><a href="#考试review" class="headerlink" title="考试review"></a>考试review</h1><p>1.CLIQUE决策性问题和证明NP</p>
<p>2.prove by subtitution（12只记了两个不会的）</p>
<p>3.bfs</p>
<p>4.拓扑排序</p>
<p>5.dijk找最小环</p>
<p>6.送分dp</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E8%AF%BE%E7%A8%8B/"># 课程</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/01/14/2022%E7%A7%8B%E5%AD%A3%E3%80%8A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">2022秋季《需求与商业模式》课程笔记</a>
            
            
            <a class="next" rel="next" href="/2022/07/01/2022%E6%98%A5%E5%AD%A3%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">2022春季《数据库概论》课程笔记</a>
            
        </section>


    </article>
</div>


    <div id="gitalk-container"></div>
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'blog_comment',
        owner: 'lyxx2535',
        admin: 'lyxx2535',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Annie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | 2020 - 2025
            <br>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    Total visitors:
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;|&nbsp;


<span class="site-pv">
    Total views:
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

          </span>
    </div>
</footer>

    </div>
</body>

</html>