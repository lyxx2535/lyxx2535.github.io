<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Annie">





<title>2023秋季《软件质量保障》课堂笔记 | Annie&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Annie&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Annie&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">2023秋季《软件质量保障》课堂笔记</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Annie</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">July 1, 2023&nbsp;&nbsp;10:51:05</a>
                        </span>
                    
                    
                        <span class="post-category">
                        分类:
                            
                                <a href="/categories/%E6%9C%AC%E7%A7%91%E7%94%9F%E8%AF%BE%E7%A8%8B/">本科生课程</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h1><h1 id="0-开始之前"><a href="#0-开始之前" class="headerlink" title="0.开始之前"></a>0.开始之前</h1><ol>
<li>项目管理<ol>
<li>什么是项目管理，项目管理的这些方法有哪些</li>
<li>那软件项目估算的时候到底该如何去做这个估算</li>
<li>对于这个计划的跟踪来说，你该如何去做这个计划的跟踪？</li>
<li>什么是配置管理？配置管理的要点是什么</li>
<li>风险管理？通常有哪些做法，比如说风险的识别风险的系数通常指的是什么？这些是一些就是围绕着项目管理的一些基本概念。</li>
</ol>
</li>
<li>质量管理<ol>
<li>怎么来做质量管理？</li>
<li>通过什么一些质量实践质量指标</li>
<li>然后怎么来进行跟踪</li>
</ol>
</li>
<li>软件过程<ol>
<li>为什么要有这个软件过程，为什么要有生命周期模型，这个过程跟这个生命周期模型之间的这个关系究竟是什么？</li>
<li>从一个人的一个过程，到一个小组的一个过程，这背后从团队的动力学角度来说，有哪些东西是要特别在意的</li>
<li>什么叫自组织的团队，自组织的团队到底有什么样一些特点</li>
</ol>
</li>
</ol>
<h2 id="十大问题"><a href="#十大问题" class="headerlink" title="十大问题"></a>十大问题</h2><ol>
<li><p>软件过程管理和软件项目管理是不是一回事？如果不是，两者差异是什么？</p>
<ol>
<li>软件过程管理更多关注的是什么？类似于做流水线的升级改造这样的一些工作，本质上它关注的是<strong>过程本身</strong>。也就是对于软件开发来说，一个企业的软件开发所使用的方法所使用的工具，这些是不是最适合的？这个工具如果不好了，我们该怎么去进行优化，你的这个方法如果不好了，该怎么去进行调整，这个其实是属于软件过程管理的概念。</li>
<li>软件项目管理是针对于特定的一个项目组，<strong>项目目标</strong>的一个实现。如一个软件项目小组或者说某一个特定软件项目的成本质量、工期、要实现的这些目标。项目管理关注的是目标的一个实现。 </li>
<li>所以软件过程管理跟软件项目管理是两个完全不一样的东西。</li>
<li>发散一下，CMMI指导的是软件过程管理、软件过程改进，而不是软件项目管理。</li>
</ol>
</li>
<li><p>软件估算过程中，项目经验&#x2F;历史数据的作用是什么？您的答案经得起细问吗？比如，能具体解释如何把项目经验&#x2F;历史数据转变成估算结果？估算结果经得起时间考验吗？比如，隔了3个月，能保证估算结果一致？</p>
<ol>
<li>充分考虑团队动力学方面，怎样有更好的激励？<ol>
<li>完成任务后价值越大，激励程度越高</li>
<li>自己所认为的成功的把握</li>
</ol>
</li>
<li>估算尽可能要细一点，建立起对结果的信心。用相对大小，有规模的描述（如历史数据），对历史数据进行适当加工变成抽象的，拥有标准和尺度的数据。</li>
</ol>
</li>
<li><p>所以，估算究竟追求的目标是什么？</p>
<ol>
<li>估算追求<strong>所有的参与者对规范结果的一个认同</strong>。而不是追求估算结果客观上的正确性（做不到）。这是互相讨论、妥协、认同的过程。如果偏的离谱也没关系，大家都认可更重要。看起来是猜测，但没关系，大家达成一致就可以。</li>
<li>一个问题：假设你的估算结果和实际结果都一样，能不能认为估算准确？从<strong>规模</strong>看，可以说准确，但从<strong>时间</strong>上看，不一定是估的准，可能只是只给了你这么多时间，所以完成。</li>
</ol>
</li>
<li><p>什么叫做XX管理？管理的要素有哪些？如何区分有管理（或者好的管理）还是没有管理（或者不好的管理）？这种判断如果只能事后从结果判断，有意义吗？</p>
<ol>
<li>三要素：<strong>有目标、状态跟踪、纠偏措施</strong>。企业里面的认知：测试、review、自动评审、代码扫描，比较混乱。三要素是核心。</li>
<li>目标：一般是高质量开发。要定义的具体，比如高质量有数据去量化、刻画（每千行的缺陷数不要超过一个）</li>
<li>状态跟踪：最终结果出来之前，比如单元测试做了，验收还没做，可以回答最终验收测试时，每千行的缺陷数不要超过一个的质量目标能否实现？当前的状态不能支持目标实现，就纠正；可以支持，就维持。</li>
<li>困难点就是状态跟踪：【状态跟踪的方法】<ol>
<li>如果构建预测模型出来（见软件定量管理和过程建模仿真），输入xy去预测z当然就可以。</li>
<li>或者做一些数据：把单元测试的代码覆盖率和最终交付的曲线密度做线性回归、或者相关性检验，如果强相关就用小的预测模型建立单元测试的代码覆盖率和最终质量水平的线性关系就可以了，无需构建复杂XYZ很多的大模型。</li>
<li>基于历史经验：质检失效比A&#x2F;FR（2.0以上）。PQI（0.4以上）达到了就说明质量目标是可以实现的。</li>
</ol>
</li>
<li>怎么支持Z？一堆Y。怎样支持Y，一堆X、Y是单元测试的某一阶段。质量管理要有这样关系的体现。【预测模型】</li>
</ol>
</li>
<li><p>接上一问题，什么叫做软件质量？当您宣称做了质量管理，实际上真的对质量有管理吗？</p>
<ol>
<li>质量的路线图：明确告诉怎样追求极高的质量，哪些先做哪些后做，跟质量概念有关。</li>
</ol>
</li>
<li><p>正确建立对敏捷宣言的理解：</p>
<ol>
<li>本质上讲有些东西是基础，而有些东西是锦上添花。</li>
<li>没有右项，左项是没有意义的。仍然要有文档、流程和工具。</li>
<li>如何判断右项如果做得足够了开始重视左项？需要经验的判断，看当前项目的状态和上下文。</li>
<li>同样瀑布模型也需要经验。首先，不是单一模型，从最简单到最复杂。根据项目的特点，越复杂越有挑战性，融入过程的元素应该越多。但很多人过低地判断了项目的难度和挑战，选择了过于简单的瀑布模型。</li>
</ol>
</li>
<li><p>从没有度量就没有管理&#x2F;改进，到软件项目度量毫无意义，到包含2200多指标项的研发效能度量，到研发效能引发血案，这是想闹哪样？究竟要不要度量？</p>
<ol>
<li>要理解度量体系的构建。GQM方法。规模越大，度量要求肯定越高。度量要服务于你管控的目标</li>
<li>Goal Question Metrics</li>
</ol>
</li>
<li><p>从极度反对CMM到自己搞开发运维一体化成熟度模型，所以，这是成熟度模型的问题？还是其他问题？</p>
<ol>
<li>成熟度模型不是软件项目管理方法，是过程改进的参考模型。</li>
<li>描述的是，过程&#x2F;企业从不成熟到成熟的路线图。只要能用过程描述的一件事情，成熟的路线图永远都是一样的。（决定了CMM和CMMI的价值）</li>
<li>一个软件&#x2F;模块开发，刚开始自己定义步骤；接下来和别人融合、借鉴、分享、提升，把过程做成标准过程；四级：通过一些数据模型做更好的管控，比如对未来结果的预测；五级：优化自己的过程，让生产效率、质量水平越来越高，叫做持续优化。</li>
<li>揭示了某种客观规律，任何一个过程，从不成熟到成熟走的路线都是一样的。</li>
</ol>
</li>
<li><p>定量管理的本质是什么？用数据就是定量管理了？DevOps模式下，还需要定量管理吗？</p>
<ol>
<li>定量管理的基本范式。</li>
<li>一定要看到定量模型，然后用构建的模型指导项目实践。</li>
<li>建模过程中，想办法提高对未来结果的预测能力：消除异常、应用统计方法、检验等。</li>
<li>用数据的简单应用不是定量管理，但数据是前提条件，一定要看到模型。</li>
<li>模型的搭建是自顶向下的过程，识别一堆Y-&gt;识别一堆X。X称之为关键子过程性能的<strong>关键影响因素</strong>。</li>
<li>定量管理的本质：把关键影响因素控制好了，期望Y、Z都能符合要求。</li>
<li>DevOps下也要做定量管理，还能做得更好。传统项目中人会介入；DevOps迭代速度快、数据更多、质量也高（人的干扰少，自动化工具产生），统计角度标准差小，数据可用性高，所以做定量管理可以更好。</li>
</ol>
</li>
<li><p>关于工程实践。需求分析究竟要解决什么问题？设计究竟要设计什么？测试的目的是什么？为实现这个目的，测试实践的重点应该是什么？</p>
<ol>
<li>严格区分客户需求和产品需求。客户需求是问题，产品需求是解决方案。</li>
<li>设计：内部外部动态静态四个象限的内容填满。设计的标准、可用性、可测试性，要在设计过程中注意。</li>
<li>测试：跟VER and VAL有关。验证(Verification)和确认(Validation)<ol>
<li>测试不是提升质量水平的手段，是帮助我们掌握质量状态的手段。</li>
<li>验证(Verification)关注<strong>产品需求</strong>有没有得到体现，解决方案从设计出来到开发完成有没有偏，有没有正确实现。</li>
<li>确认(Validation)关注<strong>客户需求</strong>有没有得到满足，客户期望解决的问题有没有很好的解决。</li>
<li>测试时的侧重点：<ol>
<li>集成测试：功能和一开始设计的是或否一样。CI（持续集成）</li>
<li>验收测试&#x2F;试运行测试：不是关注有没有错误&#x2F;功能实现，是从用户的角度，想要解决的为有没有解决好。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="软件开发的四大本质难题"><a href="#软件开发的四大本质难题" class="headerlink" title="软件开发的四大本质难题"></a>软件开发的四大本质难题</h2><h3 id="四大本质难题是什么"><a href="#四大本质难题是什么" class="headerlink" title="四大本质难题是什么"></a>四大本质难题是什么</h3><ol>
<li>复杂性：实体数量众多</li>
<li>不可见性：软件项目是一个逻辑实体</li>
<li>可变性</li>
<li>一致性</li>
</ol>
<blockquote>
<h3 id="四大本质难题之间的关系"><a href="#四大本质难题之间的关系" class="headerlink" title="四大本质难题之间的关系"></a>四大本质难题之间的关系</h3><ol>
<li>除了不可见性以外，其他三个本质难题因项目而异。</li>
<li>四大本质难题互相促进。</li>
<li>本质难题变化带动软件方法（过程）演变。</li>
</ol>
<h3 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h3><ol>
<li>软件开发四大本质难题永远存在，不可能彻底解决，在不同时期凸显程度有差异。</li>
<li>软件开发本质上是智力劳动，开发者心理方面的因素不可忽视</li>
</ol>
</blockquote>
<h2 id="软件发展"><a href="#软件发展" class="headerlink" title="软件发展"></a>软件发展</h2><p>软件发展的两个趋势：规模+比例</p>
<ol>
<li>软件项目<strong>规模</strong>日益扩大：使得软件越来越难做。</li>
<li>软件在整个系统中的<strong>比例</strong>日益增加：将软件质量问题的影响上升到前所未有的高度。</li>
</ol>
<p>软件危机：指<strong>落后的软件生产方式</strong>无法满足迅速增长的<strong>计算机软件需求</strong>，从而导致软件开发与维护过程中出现一系列严重问题的现象。</p>
<blockquote>
<p>主要体现有：</p>
<ol>
<li>软件开发费用和进度失控</li>
<li>软件可靠性差</li>
<li>生产出来的软件难以维护</li>
<li>用户对“已完成”系统不满意现象经常发现</li>
</ol>
</blockquote>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><ol>
<li>软件工程是一门研究用<strong>工程化的方法</strong>构建和维护有效的、实用的和高质量的软件的学科。</li>
<li>软件工程的两大视角<ol>
<li>管理视角：能否复制成功？</li>
<li>技术视角：是否可以将问题解决得更好？</li>
</ol>
</li>
</ol>
<h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><ol>
<li><strong>管理的三大关键要素：目标、状态（是在接近目标还是在远离目标）和纠偏</strong>。</li>
<li>大部分情况下，管理仅仅是视图复制其他地方（场景）的成功，但是这种复制一般不容易</li>
<li>软件项目管理是为了降低&#x2F;减少各种无谓的损耗来实现本该有的性能。</li>
<li>软件过程改进是为了达到更好的效能，其中质量&#x2F;缺陷是首要目标或限制。</li>
</ol>
<h4 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h4><ol>
<li><strong>典型的三大目标：成本、质量和工期</strong>。</li>
<li>定义：软件项目管理是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。<ol>
<li>软件项目管理包括估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理等等。</li>
<li>软件项目管理的对象是各类软件项目</li>
</ol>
</li>
<li>可以细分为两种管理视角：<strong>软件过程与生命周期模型</strong></li>
</ol>
<h5 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h5><p>为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合。这一组实践往往有一定的先后顺序，作为一个整体来实现事先定义的一个或者多个目标。</p>
<p>广义软件过程：</p>
<ol>
<li>理论基石：软件产品和服务的质量，很大程度上取决于生产和维护该软件或者服务的过程的质量。</li>
<li>包括：技术、人员以及狭义过程。</li>
<li>同义词：软件开发方法、软件开发过程。<ol>
<li>净室 Clean Room 方法、极限编程方法、Scrum 方法、Gate 方法<ol>
<li>clean room 工程过程和 CMM 管理过程互为补充</li>
<li>clean room 比 cmm 更注重质量，更偏向于使用一些数学工具</li>
</ol>
</li>
<li>更一般的，敏捷软件过程&#x2F;方法、轻量型过程&#x2F;方法及重型过程&#x2F;方法等描述也是恰当的。</li>
</ol>
</li>
</ol>
<h5 id="生命周期模型"><a href="#生命周期模型" class="headerlink" title="生命周期模型"></a>生命周期模型</h5><ol>
<li>生命周期模型是对软件过程的一种人为划分。</li>
<li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分</li>
<li>生命周期模型往往不包括技术实践</li>
<li>典型生命周期模型：<strong>瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等。</strong></li>
</ol>
<h4 id="软件过程管理"><a href="#软件过程管理" class="headerlink" title="软件过程管理"></a>软件过程管理</h4><ol>
<li>软件过程管理的对象是软件过程。</li>
<li>软件过程管理的<strong>目的</strong>是为了让软件过程在开发效率、质量等方面有着更好性能绩效（Performance）</li>
</ol>
<h4 id="软件过程管理与软件过程改进"><a href="#软件过程管理与软件过程改进" class="headerlink" title="软件过程管理与软件过程改进"></a>软件过程管理与软件过程改进</h4><ol>
<li>两者含义接近</li>
<li>软件过程管理参考模型 <strong>CMM&#x2F;CMMI，SPICE</strong> 等。</li>
<li>软件过程改进参考元模型<strong>PDCA、IDEAL</strong> 等。</li>
</ol>
<h2 id="思考和讨论"><a href="#思考和讨论" class="headerlink" title="思考和讨论"></a>思考和讨论</h2><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458435.png" alt="image-20240101144615962" style="zoom:50%;" />

<p>A.软件项目管理关注<strong>项目目标的实现</strong>，软件过程管理关注<strong>过程本身</strong>，这里应该改成软件项目管理。错。</p>
<p>B.过程管理和过程改进是类似的，过程管理会关注一个企业软件开发所使用的方法、工具是否适合？这个工具&#x2F;方法如果不好了，怎么去进行优化&#x2F;调整。对。</p>
<p>C.CMM和CMMI并不是软件开发方法，而是软件过程管理&#x2F;改进模型。XP是敏捷软件开发方法。错。</p>
<p>D.CMM和CMMI是软件过程管理&#x2F;改进模型，不是软件项目管理，对。</p>
<p>E.PDCA，IDEAL 是软件过程改进参考元模型，适合在敏捷环境中使用的，错。</p>
<p>F.生命周期模型是对软件过程的一种人为划分，所以可能一样，错。</p>
<p>答案：BD</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458417.png" alt="image-20240101150651440"></p>
<p>A.是的，CMMI是软件过程管理&#x2F;改进模型</p>
<p>B.CMMI不是过程优劣的标准，也不适用作公司之间的能力比较，它是每个公司自我反思改进的依据。理由:</p>
<ol>
<li>由于企业所处环境以及业务目标等的差异，过程改进模型对不同企业的<strong>含义不同</strong>。</li>
<li>（例子1）一个银行, 它的开发模型可能对软件的数据一致性、可靠性有很高的要求，它的开发模型可能会更侧重测试、原型等。而另一个嵌入式方向的公司，它的开发模型就会更关注性能。</li>
<li>（例子2）或者说一个项目每天更新100次，不一定比一个每天更新1次的项目，就更有创新或更有价值。</li>
</ol>
<p>因此，成熟度等级不应该脱离企业环境直接横向比较；处于相同的成熟度等级，也并不能说明这些企业的研发能力也是相同的。</p>
<p>C.敏捷是开发方法&#x2F;软件过程，CMMI是软件过程改进模型</p>
<blockquote>
<h3 id="软件过程管理-改进模型：CMM"><a href="#软件过程管理-改进模型：CMM" class="headerlink" title="软件过程管理&#x2F;改进模型：CMM"></a>软件过程管理&#x2F;改进模型：CMM</h3><ol>
<li>定义：CMM 是一种用于评价软件承包能力并帮助其改善软件质量的方法，侧重于软件开发过程的管理及工程能力的提高与评估。</li>
<li>级别：分为五个级别，一级为初始级，二级为可重复级，三级为已定义级，四级为已管理级，五级为优化级。</li>
</ol>
<h4 id="等级一：初始级-Initial"><a href="#等级一：初始级-Initial" class="headerlink" title="等级一：初始级 Initial"></a>等级一：初始级 Initial</h4><ol>
<li>特点：处于该级别的组织基本上没有健全的软件工程管理制度。<ol>
<li>每件事情都用特殊的方法去做：如果特定工程遇到有能力的管理员和一个优秀的软件开发组来做，则可能是成功的。</li>
<li>大多数的行动知识应付危机，而非事先计划好的任务。通常的情况是，由于缺乏健全的总体管理和详细计划，时间和费用经常超支。</li>
<li>软件过程完全取决于当前的人员配置，具有不可预测性。</li>
</ol>
</li>
<li>要精确地预测产品的开发实践和费用之类重要的项目，是不可能的。</li>
</ol>
<h4 id="等级二：可重复级-Repeatable"><a href="#等级二：可重复级-Repeatable" class="headerlink" title="等级二：可重复级 Repeatable"></a>等级二：可重复级 Repeatable</h4><ol>
<li>特点：有些基本的软件项目的管理行为、设计和管理技术是基于相似产品中的经验。<ol>
<li>采取了一些措施，这些措施是实现一个完备过程所必不可缺少的第一步。<ol>
<li>典型措施包括：仔细地追踪费用和进度。</li>
<li>不像第一级那样，在危机状态下才行动，管理人员在问题出现时便可发现，并立即采取修正行动，防止它们变成危机。</li>
</ol>
</li>
<li>关键一点：没有这些措施，要在问题变得无法收拾前发现它们是不可能的。在一个项目中财务的措施也可以为未来的项目拟定实现的期限和费用计划。</li>
</ol>
</li>
</ol>
<h4 id="等级三：已定义级-Defined"><a href="#等级三：已定义级-Defined" class="headerlink" title="等级三：已定义级 Defined"></a>等级三：已定义级 Defined</h4><ol>
<li>特点：为软件生产的过程编制了完整的文档。<ol>
<li>软件过程管理方面和技术方面已经做了明确的定义，并且按需要不断地改进过程。</li>
<li>采用评审的方法来保证软件的质量。</li>
</ol>
</li>
<li>这个级别可以引用 CASE 环境来进一步提高质量和产生率。</li>
<li>在第一级的过程中，高技术会使得该危机驱动过程更加混乱。</li>
</ol>
<h4 id="等级四：已管理级-Managed"><a href="#等级四：已管理级-Managed" class="headerlink" title="等级四：已管理级 Managed"></a>等级四：已管理级 Managed</h4><ol>
<li>特点：公司对每个项目都设定质量和生产目标。<ol>
<li>这两个量将被不断地测量，当偏离目标太多时，就采取行动来修正。</li>
<li>利用统计质量控制，管理部门能区分出随机偏离和有深刻含义的质量或生产目标的偏离。</li>
</ol>
</li>
<li>统计质量控制措施的一个简单例子：是每千行代码的错误率，相应的目标就是随时间推移减少这个量。</li>
</ol>
<h4 id="等级五：优化级-Optimizing"><a href="#等级五：优化级-Optimizing" class="headerlink" title="等级五：优化级 Optimizing"></a>等级五：优化级 Optimizing</h4><ol>
<li>目标：连续地改进软件过程。<ol>
<li>使用统计质量和过程控制技术作为指导。</li>
<li>从各方面获得的知识将被运用在以后的项目中，从而使软件过程融入正反馈循环，使生产率和质量得到稳步的改进。</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th><img src="https://eaglebear2002.github.io/8725/13.png" alt="img"></th>
<th><img src="https://eaglebear2002.github.io/8725/14.png" alt="img"></th>
</tr>
</thead>
</table>
<h3 id="软件过程管理-改进模型：CMMI-Capability-Maturity-Model-Integration-成熟度模型"><a href="#软件过程管理-改进模型：CMMI-Capability-Maturity-Model-Integration-成熟度模型" class="headerlink" title="软件过程管理&#x2F;改进模型：CMMI Capability Maturity Model Integration 成熟度模型"></a>软件过程管理&#x2F;改进模型：CMMI Capability Maturity Model Integration 成熟度模型</h3><ol>
<li>刻画了软件团队&#x2F;组织从不成熟到成熟的每个阶段的特征（也就是 roadmap)</li>
<li>等级 2 和等级 3 关注的是当前状态</li>
<li>等级 4 和等级 5 是根据结果（未来）来进行管理</li>
</ol>
<h4 id="等级一：初始级"><a href="#等级一：初始级" class="headerlink" title="等级一：初始级"></a>等级一：初始级</h4><blockquote>
<p>开发相对混乱，依赖个人英雄主义，没有过程概念，救火文化盛行</p>
</blockquote>
<ol>
<li>软件组织对项目的目标与要做的努力很清晰，项目的目标可以实现。</li>
<li>由于任务的完成带有很大的偶然性，软件组织无法保证在实施同类项目时仍然能够完成任务，项目实施是否成功主要取决于实施人员。</li>
</ol>
<h4 id="等级二：已管理级"><a href="#等级二：已管理级" class="headerlink" title="等级二：已管理级"></a>等级二：已管理级</h4><blockquote>
<p>项目小组体现出项目管理的特征，有项目计划和跟踪、需求管理、配置管理等。</p>
</blockquote>
<ol>
<li>软件组织对项目有一系列管理程序，避免了软件组织完成任务的随机性，保证了软件组织实施项目的成功率。</li>
<li>软件组织在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对项目相关的实施人员进行相应的培训，对整个流程进行监测与控制，并联合上级单位对项目与流程进行审查。</li>
<li>从 2 级升级到 3 级的原因：固化最佳实践，对小组而言是能够更快地学习其他的做法。</li>
</ol>
<h4 id="等级三：已定义级"><a href="#等级三：已定义级" class="headerlink" title="等级三：已定义级"></a>等级三：已定义级</h4><blockquote>
<p>公司层面有标准流程和相应的规范，每个项目小组可以基于此定义自己的过程，使得优秀的做法可以在公司内分享。</p>
</blockquote>
<ol>
<li>软件组织能够根据自己的特殊情况及自己的标准流程，将这套管理体系与流程予以制度化。</li>
<li>软件组织不仅能够在同类项目上成功，也可以在其他项目上成功。</li>
<li>科学管理成为软件组织的一种文化，成为软件组织的财富。</li>
</ol>
<h4 id="等级四：定量管理级"><a href="#等级四：定量管理级" class="headerlink" title="等级四：定量管理级"></a>等级四：定量管理级</h4><blockquote>
<p>构建预测模型，已统计过程控制的手段来管理过程</p>
</blockquote>
<ol>
<li>软件组织的项目管理实现了数字化。</li>
<li>通过数字化技术来实现流程的稳定性，实现管理的精度，降低项目实施在质量上的波动。</li>
<li>在这个级别我们希望能够看到一个预测模型。</li>
</ol>
<h4 id="等级五：优化级"><a href="#等级五：优化级" class="headerlink" title="等级五：优化级"></a>等级五：优化级</h4><blockquote>
<p>继续应用统计方法识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题</p>
</blockquote>
<ol>
<li>软件组织能够充分利用信息资料，对软件项目在项目实施的过程中可能出现的次品予以预防。</li>
<li>能够主动地改善流程，运用新技术，实现流程的优化。</li>
</ol>
<h4 id="一些理解"><a href="#一些理解" class="headerlink" title="一些理解"></a>一些理解</h4><ol>
<li>CMM&#x2F;CMMI 不适用于软件开发的原因<ol>
<li>CMM&#x2F;CMMI 并不是一种具体的软件过程或者软件开发方法<ol>
<li>CMM&#x2F;CMMI 建立了一组有效地描述成熟软件组织特征的准则。</li>
<li>CMMI 是过程改进模型而非软件过程或者软件过程模型：CMMI 指导软件过程改进，不指导开发。</li>
<li>按照 CMM&#x2F;CMMI 模型的要求，一个软件组织应当定义使用本软件组织特点的软件过程，并且不断优化该过程，来更好地实现软件组织的商业目标。</li>
</ol>
</li>
<li>CMM&#x2F;CMMI 并不能作为检验软件过程优劣的标准：过程改进对不同企业的含义不一样，成熟度等级无法脱离企业环境直接横向比较。</li>
<li>CMM&#x2F;CMMI 与其他软件过程或者软件开发方法的比较是没有任何意义的。</li>
</ol>
</li>
<li>一些误解：<ol>
<li>CMMI 模型需要适当裁剪以适应公司的实际情况：需要裁剪的是公司内部定义的组织级开发流程和开发规范。</li>
<li>CMMI 模型太重了，不适合互联网时代的轻量级开发：这个说法的错误之处在于，不一定是 CMMI 重或者轻，而是，CMMI 根本就不是开发模型。</li>
<li>CMMI 模型只适合大公司、大项目，不适合小项目：首先没人检验过；其次，项目的大小衡量本身也缺乏值得信赖的参考依据；最后，接受这种说法的人还是把 CMMI 当成是一种特殊的开发模型。</li>
<li>CMMI 模型只适合需求不变或者很少变化的场合，不适合需求不确定，变化很多的场合：CMMI 不是开发模型，与需求变化与否无关，谈不上适应或者不适应。</li>
</ol>
</li>
<li>CMMI 不是过程优劣的标准，也不适合用作公司之间的能力比较，说法怎么样？对的，CMMI 本身是有评级。（美国国防部订单招标要求企业至少达到 CMMI 的 3 级。因为公司的能力需要绝对东西，也就是能力强，能力弱，而 CMMI 衡量的是相对的水平，CMMI 仅仅关注在本公司的目标下的等级</li>
<li>更多讨论：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b7407257eedb">试论 CMM&#x2F;CMMI 不适合在当前软件开发当中应用的原因</a></li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/10.png" alt="img"></p>
<h3 id="软件过程管理模型：ISO-IEC-1504"><a href="#软件过程管理模型：ISO-IEC-1504" class="headerlink" title="软件过程管理模型：ISO&#x2F;IEC 1504"></a>软件过程管理模型：ISO&#x2F;IEC 1504</h3><ol>
<li>也叫 SPICE（Software Process Improvement and Capability Determination）</li>
<li>过程类别共有五种，分别是<ol>
<li>客户-供应商（CUS)过程</li>
<li>工程（ENG）过程</li>
<li>支持（SUP）过程</li>
<li>管理（MAN）过程</li>
<li>组织（ORG）过程</li>
</ol>
</li>
</ol>
<h3 id="软件过程框架：RUP"><a href="#软件过程框架：RUP" class="headerlink" title="软件过程框架：RUP"></a>软件过程框架：RUP</h3><ol>
<li>Rational 统一过程（Rational Unified Process）</li>
<li>最佳实践<ol>
<li>迭代式开发</li>
<li>管理需求</li>
<li>使用基于构件的体系结构</li>
<li>可视化建模</li>
<li>验证软件质量</li>
<li>控制软件变更</li>
</ol>
</li>
<li>RUP 软件开发生命周期<ol>
<li>初始阶段：建立业务模型，定义最终产品视图，并且确定项目的范围</li>
<li>精化阶段：设计并确定系统的体系结构，制定项目计划，确定资源需</li>
<li>构建阶段：开发出所有构件和应用程序，把它们集成为客户需要的产品，并且详尽地测试所有功能</li>
<li>移交阶段：把开发的产品提交给用户使用</li>
</ol>
</li>
</ol>
<h3 id="软件过程改进模型"><a href="#软件过程改进模型" class="headerlink" title="软件过程改进模型"></a>软件过程改进模型</h3><ol>
<li>重点关注“过程质量”，强调“持续改进”</li>
<li>获得 ISO 9000 标准认证的企业应该具有 CMM 第 2~3 级的水平</li>
</ol>
<h3 id="软件质量管理发展：软件质量大师的主要观点和贡献、工作"><a href="#软件质量管理发展：软件质量大师的主要观点和贡献、工作" class="headerlink" title="软件质量管理发展：软件质量大师的主要观点和贡献、工作"></a>软件质量管理发展：软件质量大师的主要观点和贡献、工作</h3><blockquote>
<p>描述下述质量管理大师的主要观点和贡献，工作对软件过程和项目管理的借鉴意义</p>
</blockquote>
<h4 id="Shewhart"><a href="#Shewhart" class="headerlink" title="Shewhart"></a>Shewhart</h4><ol>
<li>最早将统计控制的思想引入质量管理，是质量改进奠基人;</li>
<li>提出 PDS 模型（计划执行检查 Plan-Do-See)，后被戴明进一步发展为 PDCA。</li>
</ol>
</blockquote>
<h1 id="2-软件过程的历史演变和经典工作"><a href="#2-软件过程的历史演变和经典工作" class="headerlink" title="2.软件过程的历史演变和经典工作"></a>2.<strong>软件过程的历史演变和经典工作</strong></h1><p>软件发展的三大阶段：</p>
<ol>
<li>软硬件一体化阶段：软件完全依附于硬件，软件作坊（50 年代到 70 年代）</li>
<li>软件成为独立的产品（70 年代到 90 年代）</li>
<li>网络化和服务化（90 年代中期至今）</li>
</ol>
<h2 id="软硬件一体化阶段"><a href="#软硬件一体化阶段" class="headerlink" title="软硬件一体化阶段"></a>软硬件一体化阶段</h2><p><strong>软件完全依赖于硬件</strong></p>
<ol>
<li>软件应用典型特征：软件支持硬件完成计算任务、功能单一、复杂度有限、几乎不需要需求变更。</li>
<li>软件开发典型特征：硬件太贵、团队以硬件工程师和数学家为主。</li>
<li>典型软件过程和实践<ol>
<li>非常线性</li>
<li>三思而后行（measure twice，cut once）</li>
<li>编码+改错 Code and Fix</li>
</ol>
</li>
</ol>
<p><strong>软件作坊</strong></p>
<ol>
<li>软件应用典型特征：功能简单、规模小。</li>
<li>软件开发典型特征：很多非专业领域人员涌入软件、高级程序语言出现、质疑权威文化盛行。</li>
<li>典型软件过程和实践：<ol>
<li>Code and Fix：不适合大型软件项目开发！</li>
</ol>
</li>
</ol>
<h2 id="软件成为独立的产品"><a href="#软件成为独立的产品" class="headerlink" title="软件成为独立的产品"></a>软件成为独立的产品</h2><ol>
<li>软件应用典型特征：<ol>
<li>摆脱了硬件的束缚（OS）</li>
<li>功能强大</li>
<li>规模和复杂度剧增</li>
<li>个人电脑出现 -&gt; 普通人成为软件用户 <ol>
<li>需求多变</li>
<li>兼容性要求</li>
</ol>
</li>
<li>来自市场的压力</li>
</ol>
</li>
<li>典型软件过程和实践<ol>
<li>形式化方法：将所有的方法当作数学方法，做数学化的检验，主要解决质量和正确性问题。</li>
<li>结构化程序设计和瀑布模型<ol>
<li>自顶向下，逐步求精。</li>
<li>问题和不足（效率和质量）<ol>
<li>形式化在扩展性和可用性方面存在不足。</li>
<li>瀑布模型成为一个重文档、慢节奏的过程。</li>
</ol>
</li>
</ol>
</li>
<li>成熟度模型</li>
</ol>
</li>
</ol>
<h2 id="网络化和服务化"><a href="#网络化和服务化" class="headerlink" title="网络化和服务化"></a>网络化和服务化</h2><ol>
<li>软件应用典型特征：<ol>
<li>功能更复杂、规模更大</li>
<li>用户数量急剧增加</li>
<li>快速演化和需求不确定</li>
<li>分发方法的变化（SaaS）</li>
</ol>
</li>
<li>典型软件过程和实践：<ol>
<li><strong>迭代式</strong>大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来交付。</li>
<li>雪鸟会议和敏捷宣言<ol>
<li>个体和互动 胜过 流程和工具</li>
<li>可以工作的软件 胜过 详尽的文档</li>
<li>客户合作 胜过 合同谈判</li>
<li>响应变化 胜过 遵循计划</li>
<li>尽管右项有价值，但是我们更重视左项的价值</li>
</ol>
</li>
<li>XP eXtreme Programming 方法：偏重于一些工程实践的描述</li>
<li>Scrum：管理框架和管理实践。</li>
<li>KanBan<ol>
<li>精益生产（丰田制造法）的具体实现</li>
<li><strong>可视化工作流、限定 WIP(制品)、管理周期时间</strong></li>
</ol>
</li>
<li>开源软件开发方式：<ol>
<li>一种基于并行开发模式的软件开发的组织与管理方式。<ol>
<li>Linus 定律：如果有足够多的 beta 测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</li>
<li>“早发布，常发布，倾听用户的反馈”、“把你的用户当作开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径”、“设计上的完美不是没有东西可以再加，而是没有东西可以再减”</li>
<li>代码管理：严格的代码提交社区审核制度</li>
</ol>
</li>
<li>一些演化：内部开源（inner source）、众包（Crowdsourcing）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="当前软件发展现状"><a href="#当前软件发展现状" class="headerlink" title="当前软件发展现状"></a>当前软件发展现状</h2><ol>
<li>软件应用典型特征<ol>
<li>进一步服务化和网络化（移动是主流）随处可见（pervasive）</li>
<li>用户需求的多样性进一步凸显</li>
<li>软件产品和服务的地位变化</li>
<li>错综复杂的部署环境。</li>
<li>近乎苛刻的用户期望<ol>
<li>多：功能丰富，个性化</li>
<li>快：快速使用，及时更新，快速解决问题</li>
<li>好：稳定，可靠，安全，可信</li>
<li>省：用户的获得成本低，最好免费</li>
</ol>
</li>
</ol>
</li>
<li>软件开发的典型特征<ol>
<li>空前强大的开发和部署环境：XaaS，IaaS、PaaS、SaaS、FaaS</li>
<li>盛行开源和共享文化‘</li>
<li>盛行敏捷开发</li>
<li>软件工程的潜在支撑力量获得了长足进步（AI、大数据、云计算）</li>
</ol>
</li>
<li>【2021Fall】典型DevOps实践和方法：<ol>
<li>方法论的基础是软件敏捷开发、精益思想和看板 KanBan 方法</li>
<li>以领域驱动设计为指导的微服务架构方式</li>
<li>大量虚拟化技术的使用</li>
<li>一切皆服务 XaaS(X as a Service) 的理念指导</li>
<li>构建了强大的工具链，支持高水平自动化。</li>
</ol>
</li>
</ol>
<h2 id="思考与讨论"><a href="#思考与讨论" class="headerlink" title="思考与讨论"></a>思考与讨论</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458907.png" alt="image-20240101152614137"></p>
<p>答案：B。三思而后行。在软硬件一体化阶段，硬件成本非常高的环境下，编码完成后需要对代码进行详细的审阅，<strong>确认无误后再交给硬件运行</strong>。</p>
<p>现在：机器成本低，人力成本高，所以让机器反复测试验证产品，再让人工跑测试</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458868.png" alt="image-20240101152944456"></p>
<p>答案：C。云计算化和虚拟化属于网络化。软件作坊属于软硬件一体化。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458850.png" alt="image-20240101153203793"></p>
<p>答案：A。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458458.png" alt="image-20240101153242125"></p>
<p>A.软硬件一体化阶段-软件作坊</p>
<p>B.网络化与服务化</p>
<p>C.D.软件成为独立的产品</p>
<p>答案：A</p>
<h1 id="3-团队动力学"><a href="#3-团队动力学" class="headerlink" title="3.团队动力学"></a>3.团队动力学</h1><ol>
<li>软件开发的特点<ol>
<li>软件开发是一项既复杂又富有创造性的知识工作。</li>
<li>软件开发：智力劳动，需要处理和讨论极其抽象的概念，并把不同的部分（不可见）整合成一个可以工作的系统。<ol>
<li>要求从事软件开发的工程师<ol>
<li>必须全身心地参与工作：知识工作必须是全身心投入的，任务切换一般需要 30 分钟才能全身心的投入。</li>
<li>主观意愿上努力追求卓越。</li>
</ol>
</li>
<li>要求管理者激励并维持激励<ol>
<li>激励手段</li>
<li>维持激励手段</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>管理知识工作的关键规则是：管理者无法管理工作者，<strong>知识工作者必须实现并学会自我管理</strong><ol>
<li>要自我管理，知识工作者必须（自我管理的前提条件）<ol>
<li>有积极性</li>
<li>能做出准确的估算和计划</li>
<li>懂得协商承诺</li>
<li>有效跟踪他们的计划</li>
<li>持续地按计划交付高质量产品。</li>
</ol>
</li>
<li>知识工作者实现自我管理：胶冻状团队。</li>
</ol>
</li>
<li>知识工作者的管理需要的是领导者，而不是经理，领导者需要诚实、有能力、有远见、鼓舞人心。</li>
</ol>
<h2 id="领导者激励手段"><a href="#领导者激励手段" class="headerlink" title="领导者激励手段"></a>领导者激励手段</h2><ol>
<li>威逼：完全依靠不同角色的等级关系，通常是上级强制要求下属必须完成某些工作。</li>
<li>利诱：通过许诺一定的好处来吸引下属努力工作</li>
<li>鼓励承诺：<ol>
<li>建立承诺文化，利用软件工程师希望得到别人尊重的心理，鼓励他们合理承诺并努力满足承诺，从而得到别人的尊重。</li>
<li>位于马斯洛需求理论的 4 级以上，应当是主要的方式，并且最好以团队为单位做出承诺</li>
</ol>
</li>
</ol>
<h3 id="交易型领导方式"><a href="#交易型领导方式" class="headerlink" title="交易型领导方式"></a>交易型领导方式</h3><ol>
<li>承诺奖励激励</li>
<li>人们通常能找到新的方式来获得奖励，同时少做工作。</li>
<li>威逼和利诱属于交易型领导方式。</li>
</ol>
<h3 id="转变型领导方式"><a href="#转变型领导方式" class="headerlink" title="转变型领导方式"></a>转变型领导方式</h3><ol>
<li>用成就激励</li>
<li>鼓励承诺属于转变型领导方式。</li>
<li>由于交易型领导方式很少能产生成功并且有创造性的团队，因此<strong>转变型领导方式是首选</strong>。</li>
</ol>
<h2 id="马斯洛的需求层次理论"><a href="#马斯洛的需求层次理论" class="headerlink" title="马斯洛的需求层次理论"></a>马斯洛的需求层次理论</h2><ol>
<li>五个层次：生理需求（Physiological)、安全感（Safety)、爱和归属感（social)、获得尊敬（Esteem)、自我实现（Self-Actualization)</li>
<li>注意<ol>
<li>自我实现是最高的层次。</li>
<li>激励来自为没有满足的需求而努力奋斗。</li>
<li>低层次的需求必须在高层次需求满足之前得到充分满足。</li>
<li>满足高层次的需求的途径比满足低层次的途径更为广泛。</li>
</ol>
</li>
<li>威逼利诱比较低层，鼓励承诺在 4-5 层，效果比较好</li>
</ol>
<h2 id="承诺形式的激励"><a href="#承诺形式的激励" class="headerlink" title="承诺形式的激励"></a>承诺形式的激励</h2><ol>
<li><p>在个人级别，承诺有很大差异</p>
<ol>
<li>有些人对承诺非常认真</li>
<li>有些人对承诺非常轻率。</li>
</ol>
</li>
<li><p>在满足以下条件下，<strong>团队承诺</strong>比个人承诺的激励作用更大</p>
<ol>
<li>所有团队成员共同参与作出承诺。</li>
<li>团队依赖于每一位成员履行自己的承诺。</li>
<li>如果有计划在支撑承诺，那么就更为可信</li>
</ol>
</li>
<li><p>软件开发团队在制定承诺时，需要保证：</p>
<ol>
<li>承诺是自愿的公开的、可信（行）的</li>
<li>向团队做出承诺。</li>
</ol>
<blockquote>
<ol>
<li>承诺需要有详细计划支撑</li>
<li>开发者需要参与承诺的协商和设计。</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<p>除了以团队形式作出承诺以外，承诺文化的建立还要求在项目进行过程中维持承诺水平。</p>
<ol>
<li>及时提供各种反馈信息是维持承诺的有效手段。</li>
<li>反馈信息包括项目进度、更新后的项目计划以及里程碑实现情况等。</li>
</ol>
<p>leader 和 manager 的区别</p>
<p><img src="https://eaglebear2002.github.io/8725/26.png" alt="img"></p>
</blockquote>
<h2 id="维持激励水平"><a href="#维持激励水平" class="headerlink" title="维持激励水平"></a>维持激励水平</h2><p>维持激励需要及时的绩效反馈</p>
<ol>
<li><p>绩效反馈包括</p>
<ol>
<li>根据一个详细计划衡量进度。</li>
<li>当前计划不准确时重做计划</li>
<li>为漫长而富有挑战性的项目提供中间反馈，即<strong>里程碑</strong></li>
</ol>
</li>
<li><blockquote>
<p>激励水平的重要影响因素</p>
<ol>
<li>回报：回报越大，激励水平越高</li>
<li>期望：完成这件事情的把握越大，激励水平越高</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="其他激励相关理论"><a href="#其他激励相关理论" class="headerlink" title="其他激励相关理论"></a><strong>其他激励相关理论</strong></h2><h3 id="海兹伯格的激励理论"><a href="#海兹伯格的激励理论" class="headerlink" title="海兹伯格的激励理论"></a>海兹伯格的激励理论</h3><ol>
<li>激励因素（内在因素）：成就感、责任感、晋升、被赏识、认可。</li>
<li>保健因素（外在因素）：工作环境、薪金、工作关系、安全等。</li>
</ol>
<h3 id="麦克勒格的-X、Y－理论"><a href="#麦克勒格的-X、Y－理论" class="headerlink" title="麦克勒格的 X、Y－理论"></a>麦克勒格的 X、Y－理论</h3><ol>
<li>麦克勒格的 X－理论：人性本恶，独裁式的管理风格<ol>
<li>不喜欢他们的工作并努力逃避工作</li>
<li>缺乏进取心，没有解决问题与创造的能力</li>
<li>更喜欢经常的指导，避免承担责任，缺乏主动性</li>
<li>自我中心，对组织需求反应淡漠，反对变革</li>
<li>用马斯洛的底层需求（生理和安全）进行激励</li>
</ol>
</li>
<li>麦克勒格的 Y-理论：人性本善，民主式的管理风格<ol>
<li>如果给予适当的激励和支持性的工作氛围，会达到很高的绩效预期</li>
<li>具有创造力，想象力，雄心和信心来实现组织目标</li>
<li>能够自我约束，自我导向与控制，渴望承担责任</li>
<li>用马斯洛的高层需求（自尊和自我实现）进行激励</li>
</ol>
</li>
</ol>
<h3 id="期望理论-Expectancy-Theory"><a href="#期望理论-Expectancy-Theory" class="headerlink" title="期望理论 Expectancy Theory"></a>期望理论 Expectancy Theory</h3><ol>
<li>人们在下列情况下能够收到激励并且产生出大量成果 M &#x3D; V  * E<ol>
<li>相信他们的努力很可能会产生成功的结果（V）</li>
<li>相信自己因为成功而得到相应的回报（E）</li>
</ol>
</li>
<li>Motivation &#x3D; Valence x Expectancy(Instrumentality)，即激发力量 &#x3D; 效价 X 期望值<ol>
<li>M 表示激发力量，是指调动一个人的积极性，激发人内部潜力的强度。</li>
<li>V 表示目标价值（效价），这是一个心理学概念，是指达到目标对于满足他个人需要的价值。同一目标，由于各个人所处的环境不同，需求不同，其需要的目标价值也就不同。同一个目标对每一个人可能有三种效价：正、零、负。效价越高，激励力量就越大</li>
<li>E 是期望值，是人们根据过去经验判断自己达到某种目标的可能性是大还是小，即能够达到目标的概率。目标价值大小直接反映人的需要动机强弱，期望概率反映人实现需要和动机的信心强弱。</li>
</ol>
</li>
</ol>
<h2 id="提高成功把握的两种方法"><a href="#提高成功把握的两种方法" class="headerlink" title="提高成功把握的两种方法"></a>提高成功把握的两种方法</h2><ol>
<li>现实扭曲力场（乔布斯传）</li>
<li>数据</li>
</ol>
<h2 id="自主团队"><a href="#自主团队" class="headerlink" title="自主团队"></a>自主团队</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个团队必须包括至少两个成员，他们为了共同的目标和愿景而努力工作，他们每个人都有明确的角色和相应的职责定义，任务的完成需要团队成员互相依赖和支持。</p>
<p>软件工程师所从事的工作一般称之为复杂的知识工作。在这种性质的工作中，实现软件工程师的自我管理往往可以获得最好的工作效率和质量水平。如果整个团队的所有成员都实现了自我管理，也就形成了所谓的自主团队。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>自行定义项目的目标</li>
<li>自行决定团队组成形式以及成员的角色</li>
<li>自行决定项目的开发策略</li>
<li>自行决定项目的开发过程</li>
<li>自行制定项目的开发计划</li>
<li>自行度量、管理和控制项目工作</li>
</ol>
<blockquote>
<h5 id="自主团队的必要性"><a href="#自主团队的必要性" class="headerlink" title="自主团队的必要性"></a>自主团队的必要性</h5><ol>
<li>自主团队可以形成“胶冻态团队”。在这样的团队中存在一种神奇的力量，这种神奇力量弥漫于该团队做的所有工作</li>
<li>团队成员互相支持，更为重要的是，团队成员在任何时刻都知道应该以怎样的方式帮助别人;团队成员相互信任，有强烈的归属感</li>
<li>团队在适当的知道会聚集在一起，研究现状，讨论策略。</li>
</ol>
<h5 id="自主团队的形成"><a href="#自主团队的形成" class="headerlink" title="自主团队的形成"></a>自主团队的形成</h5><ol>
<li>自主团队不是偶然形成的。</li>
<li>大部分情况下，在团队建立之初，团队成员往往有着不同的目标;缺乏清晰的角色定义和职责安排。对于待开发的产品只有模糊的概念;团队成员也有着不同的工作习惯和工作方法。</li>
<li>经过一段时间的协同工作，团队成员可以慢慢培养团队协作方式，从而逐渐演化成自主团队。</li>
</ol>
</blockquote>
<h3 id="自主团队的外部环境"><a href="#自主团队的外部环境" class="headerlink" title="自主团队的外部环境"></a>自主团队的外部环境</h3><ol>
<li><strong>项目启动阶段</strong>获得管理层的支持<ol>
<li>项目小组应当表现出已经尽最大的可能在满足管理层的需求的工作态度。</li>
<li>项目小组应当在计划中体现定期需要向管理层报告的内容。</li>
<li>项目小组应当向管理层证明他们所制定的工作计划是合理的。</li>
<li>项目小组应当在项目中体现为了追求高质量而开展的工作。</li>
<li>项目小组应当在工作计划中允许必要的项目变更。</li>
<li>项目小组应当向管理层寻求必要的帮助。</li>
</ol>
</li>
<li>在<strong>项目进展过程</strong>中获得管理层的支持<ol>
<li>项目小组应当严格遵循定义好的开发过程开展项目开发过程。</li>
<li>项目小组应当维护和更新项目成员的个人计划和团队计划。</li>
<li>项目小组应当对产品质量进行管理。</li>
<li>项目小组应当跟踪项目进展，并定期向管理层报告。</li>
<li>项目小组应当持续地向管理层展现优异的项目表现。</li>
</ol>
</li>
</ol>
<h3 id="TSP对自主团队的支持"><a href="#TSP对自主团队的支持" class="headerlink" title="TSP对自主团队的支持"></a>TSP对自主团队的支持</h3><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458886.png" alt="image-20240101160042417"></p>
<h2 id="TSP-Launch"><a href="#TSP-Launch" class="headerlink" title="TSP Launch"></a>TSP Launch</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458944.png" alt="image-20240101160056129"></p>
<p><strong>制定开发策略</strong>是第三次会议。</p>
<h3 id="TSP-的典型角色"><a href="#TSP-的典型角色" class="headerlink" title="TSP 的典型角色"></a>TSP 的典型角色</h3><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458959.png" alt="image-20240101160442997"></p>
<p><strong>领导者与经理的区别</strong></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458427.png" alt="image-20240101160309835"></p>
<p><strong>项目组长TL</strong></p>
<p>项目组长的目标和衡量指标</p>
<ol>
<li>项目组长应当建设和维持高效率的团队。</li>
<li>项目组长应当激励团队成员积极工作。</li>
<li>项目组长应当合理处理团队成员的问题。</li>
<li>项目组长应当向管理层提供项目进度相关的完整信息。</li>
<li>项目组长应当充当合格的会议组织者和协调者。</li>
</ol>
<p>典型TL技能</p>
<ol>
<li>你是天生的领导者</li>
<li>你有能力识别问题的关键并且做出客观的决策</li>
<li>你不介意偶尔充当“恶人”</li>
<li>你尊敬你的团队成员</li>
</ol>
<p>TL工作内容</p>
<ol>
<li>激励团队成员努力工作</li>
<li>主持项目周例会</li>
<li>每周汇报项目状态</li>
<li>分配工作任务</li>
<li>维护项目资料</li>
<li>组织项目总结</li>
</ol>
<p><strong>计划经理</strong></p>
<ol>
<li>开发完整的、准确的团队计划和个人计划</li>
<li>每周准确的报告项目小组状态</li>
</ol>
<p>典型技能</p>
<ol>
<li>最为重要的一点是，你做事有条理和逻辑</li>
<li>你对于过程数据非常感兴趣，期待通过每周输入的数据来了解项目当前状况</li>
<li>你认为计划非常重要，也愿意要求团队成员跟踪和度量他们的工作</li>
</ol>
<p>工作内容</p>
<ol>
<li>带领项目小组开发项目计划</li>
<li>带领项目小组平衡计划</li>
<li>跟踪项目进度</li>
<li>参与项目总结</li>
</ol>
<p><strong>开发经理</strong></p>
<ol>
<li>开发优秀的软件产品</li>
<li>充分利用团队成员的技能</li>
</ol>
<p>典型技能</p>
<ol>
<li>你喜欢创造事物</li>
<li>你愿意成为软件工程师，并且喜欢带领团队开展设计和开发工作</li>
<li>你具备足够的背景可以胜任设计师的工作，并且可以领导设计团队开展工作</li>
<li>你熟悉主流的设计工具</li>
<li>你愿意倾听和接受其他人的设计思想</li>
</ol>
<p>工作内容</p>
<ol>
<li>带领团队制定开发策略。</li>
<li>带领团队开展产品规模估算和所需时间资源的估算。</li>
<li>带领团队开发需求规格说明。</li>
<li>带领团队开发高层设计。</li>
<li>带领团队开发设计规格说明。</li>
<li>带领团队实现软件产品。</li>
<li>带领团队开展集成测试和系统测试。</li>
<li>带领团队开发用户支持文档。</li>
<li>参与项目总结</li>
</ol>
<p><strong>质量经理</strong></p>
<ol>
<li>项目团队严格按照质量计划开展工作，开发出高质量的软件产品</li>
<li>所有的小组评审工作都正常开展，并且都形成了评审报告</li>
</ol>
<p>典型技能</p>
<ol>
<li>你关注软件产品的质量</li>
<li>你有评审方面的经验，熟悉各种评审方法</li>
<li>你有协调组织有效评审的能力</li>
</ol>
<p>工作内容</p>
<ol>
<li>带领团队开发和跟踪质量计划</li>
<li>向项目组长警示质量问题</li>
<li>软件产品提交配置管理之前，对其进行评审，以消除质量问题</li>
<li>项目小组评审的组织者和协调者</li>
<li>参与项目总结</li>
</ol>
<p><strong>过程经理</strong></p>
<ol>
<li>所有团队成员准确的记录、报告和跟踪过程数据。</li>
<li>所有的团队会议都有相应会议记录。</li>
</ol>
<p>典型技能</p>
<ol>
<li>你对过程定义、过程度量非常感兴趣</li>
<li>你对过程改进非常感兴趣</li>
</ol>
<p>工作内容</p>
<ol>
<li>带领团队定义和记录开发过程并且支持过程改进。</li>
<li>建立和维护团队的<strong>开发标准</strong>。</li>
<li>记录和维护项目的会议记录。</li>
<li>参与项目总结。</li>
</ol>
<p><strong>支持经理</strong></p>
<ol>
<li>项目小组在整个开发过程中都有合适的工具和环境</li>
<li>对于基线产品，不存在非授权的变更</li>
<li>项目小组的风险和问题得到跟踪</li>
<li>项目小组在开发过程中满足复用目标</li>
</ol>
<p>典型技能</p>
<ol>
<li>你对于各种开发工具很感兴趣，熟悉各类工具的适用场合。</li>
<li>你对版本控制工具很熟悉，也熟悉配置管理流程。</li>
<li>对于本项目所有工具而言，你都是专家。</li>
</ol>
<p>工作内容</p>
<ol>
<li>带领团队识别开发过程中所需要的各类工具和设施。</li>
<li>主持配置管理委员会，管理配置管理系统。</li>
<li>维护软件项目的词汇表。</li>
<li>维护项目风险和问题跟踪系统。</li>
<li>支持软件开发过程中复用策略的应用。</li>
<li>参与项目总结。</li>
</ol>
<h2 id="典型Scrum-小组角色"><a href="#典型Scrum-小组角色" class="headerlink" title="典型Scrum 小组角色"></a>典型Scrum 小组角色</h2><ul>
<li><p>典型SCRUM团队由一名产品负责人、开发团队和一名SCRUM Master组成</p>
</li>
<li><p>SCRUM团队是跨职能的自组织团队</p>
</li>
</ul>
<ol>
<li>产品负责人，代表利益所有者<ol>
<li>产品负责人的职责是将<strong>开发团队开发的产品价值最大化</strong>。</li>
<li>产品负责人是负责管理产品待办列表的唯一负责人。产品待办列表的管理包括：<ol>
<li>清晰地表述产品待办列表项；</li>
<li>对产品待办列表项进行排序，使其最好地实现目标和使命；</li>
<li>优化开发团队所执行工作的价值；</li>
<li>确保产品待办列表对所有人是可见、透明和清晰的，同时显示 Scrum 团队下一步要做的工作；以及</li>
<li>确保开发团队对产品待办列表项有足够深的了解。</li>
</ol>
</li>
</ol>
</li>
<li>开发团队<ol>
<li>负责在<strong>每个 Sprint 结束时交付潜在可发布并且“完成”的产品增量</strong>。</li>
<li>开发团队由组织组建并得到授权，团队自己组织和管理他们的工作。开发团队具有下列特点：<ol>
<li>他们是自组织的。没有人（即使是 Scrum Master）有权告诉开发团队应该如何把产品待办列表变成潜在可发布的功能增量；</li>
<li>开发团队是跨职能的团队，团队作为一个整体，拥有创建产品增量所需的全部技能；</li>
<li>Scrum 不认可开发团队成员的任何头衔，不管其承担何种工作（他们都叫开发人员）。</li>
<li>Scrum 不认可开发团队中所谓的“子团队”，无论其需要处理的领域是诸如测试、架构、运维或业务分析；同时，</li>
<li>开发团队中的每个成员也许有特长和专注的领域，但是责任属于整个开发团队。</li>
</ol>
</li>
</ol>
</li>
<li>Scrum Master，类似于项目经理，负责维护过程和任务<ol>
<li>促进和支持 SCRUM</li>
<li>帮助每个人理解 SCRUM 理论、实践、规则和价值</li>
<li>SCRUM Master 是一位服务型领导。<ol>
<li>帮助 SCRUM 团队之外的人了解如何与 SCRUM 团队交互是有益的</li>
<li>改变 SCRUM 团队之外的人与 SCRUM 团队的互动方式来最大化 SCRUM 团队所创造的价值。</li>
</ol>
</li>
<li>Scrum Master 服务于产品负责人，包括：<ol>
<li>确保 Scrum 团队中的每个人都尽可能地理解目标、范围和产品域；</li>
<li>找到有效管理产品待办列表的技巧；</li>
<li>帮助 Scrum 团队理解为何需要清晰且简明的产品待办列表项；</li>
<li>理解在经验主义的环境中的产品规划；</li>
<li>确保产品负责人懂得如何来安排产品待办列表使其达到最大化价值；</li>
<li>理解并实践敏捷性；以及，</li>
<li>当被请求或需要时，引导 Scrum 事件。</li>
</ol>
</li>
<li>Scrum Master 以各种方式服务于开发团队，包括<ol>
<li>作为教练在自组织和跨职能方面给予开发团队以指导；</li>
<li>帮助开发团队创造高价值的产品；</li>
<li>移除开发团队工作进展中的障碍；</li>
<li>按被请求或需要时，引导 Scrum 事件；以及，</li>
<li>在 Scrum 还未完全采纳和理解的组织环境中，作为教练指导开发团队。</li>
</ol>
</li>
<li>Scrum Master 以各种方式服务于组织，包括：<ol>
<li>带领并作为教练指导组织采纳 Scrum；</li>
<li>在组织范围内规划 Scrum 的实施；</li>
<li>帮助员工和利益攸关者理解并实施 Scrum 和经验导向的产品开发；</li>
<li>引发能够提升 Scrum 团队生产率的改变；以及，</li>
<li>与其他 Scrum Master 一起工作，增强组织中 Scrum 应用的有效性。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="思考和讨论-1"><a href="#思考和讨论-1" class="headerlink" title="思考和讨论"></a>思考和讨论</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458450.png" alt="image-20240101161222403"></p>
<p>典型SCRUM团队由一名产品负责人、开发团队和一名SCRUM Master(项目经理)组成</p>
<p>TSP由项目组长、开发经理、质量经理、支持经理、计划经理、过程经理组成</p>
<p><strong>共性：</strong></p>
<ol>
<li><strong>跨职能团队：</strong> TSP和Scrum都主张跨职能的团队。在这两种方法中，团队成员通常具备不同的技能，可以在需要时协同工作，以实现更好的灵活性和应变能力。</li>
<li><strong>自组织性：</strong> TSP和Scrum都强调团队的自组织性。团队有权自主决策如何实现项目目标，并对团队的运作负责。这有助于激发团队成员的积极性和创造性。</li>
<li><strong>定期评审和反馈：</strong> 两者都支持定期的评审和反馈机制。这些机制有助于团队及时发现问题、调整方向，并不断提高工作效率。</li>
<li><strong>迭代和增量开发：</strong> TSP和Scrum都采用迭代和增量的开发方式。项目工作分成多个迭代，每个迭代都有一个可交付的产品增量。这有助于降低项目风险，提高可交付价值。</li>
</ol>
<p><strong>对高效团队的帮助：</strong></p>
<ol>
<li><strong>团队协作：</strong> 共同强调团队协作，通过跨职能团队的形式，使得团队成员更好地协同工作，促进信息共享和沟通。</li>
<li><strong>自组织性：</strong> 两者都通过强调自组织性来激发团队成员的积极性，提高团队的执行效率。自组织的团队更能应对变化和快速适应。</li>
<li><strong>迭代开发：</strong> 通过迭代开发，团队能够更快地响应变化、及时发现和解决问题，有助于提高团队的灵活性和适应性。</li>
<li><strong>透明度和反馈：</strong> 定期的评审和反馈机制提供了透明度，使团队了解项目的状态和进度。透明度有助于团队做出及时的调整。</li>
<li><strong>持续改进：</strong> 两者都鼓励团队进行持续改进，通过不断地反思和调整过程，提高工作效能，减少浪费，专注于价值交付。</li>
</ol>
<p><strong>团队中有3种激励方式 1.威逼 2.利诱 3.鼓励承诺 ，这三种方式下的团队有什么特点，哪种最好？</strong></p>
<ol>
<li><p>威逼：这样的团队，团队成员会比较有压力，在一定程度上提高团队效率。但Leader和团队成员是一种对立的关系，团队结构不稳定，如果逼得太紧，可能就会产生反抗情绪。动力是为了保住自己的工作岗位。马斯洛<strong>第二级</strong>。</p>
</li>
<li><p>利诱：团队成员的工作动力是为了奖励，可能变成为了完成任务而完成任务，团队成员的工作态度可能变成了做完任务而不是做好任务。或者为了利益，大家争着干一些活儿，为了卷而卷。马斯洛<strong>第一级</strong>。</p>
</li>
<li><p>鼓励承诺：肯定了团队成员的主观能动性。团队成员的工作动力不仅来自于团队的鼓励，也有自我价值的肯定与实现，加强了团队成员在团队中的归属感和认同感，朝着一个良性的方向发展。马斯洛四级以上。</p>
</li>
</ol>
<p>前两种，大家倾向于以最低标准完成工作，第三种，大家完成工作还为了赢得尊重。第三种看起来最好。</p>
<p><strong>第一次开会的时候，为什么“要构建高质量软件”不是一个恰当的计划？&#x2F;为什么把目标定义成高质量开发不合适？</strong></p>
<ul>
<li>可以用期望理论来解释。期望理论 Motivation &#x3D; Valence x Expectancy(Instrumentality)，即 激发力量 &#x3D; 价值（效价）x 期望难度。</li>
<li>在第一次开会的时候，如果提出一个过于雄心勃勃和庞大的计划，可能确实会提高软件目标的价值，也就是提高了完成目标的吸引力。但是显然在期望理论上，这在提高了valence的同时，却也提高了完成的难度，降低了公式里的期望值Expectancy。如果开发团队认为完成项目的难度过高，反而会降低整个团队的凝聚力、信心和工作效率。（Expectancy有点像工作量、开发难度）</li>
<li>一个应用案例：顶会审稿人不够，稿子太多看不过来<ul>
<li>措施：<strong>取消</strong>ddl，你任何时候都能写，任何时候都能提交</li>
<li>然后发现：提交的数量急剧下降。因为大家都觉得时间都还够。</li>
</ul>
</li>
</ul>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458471.png" alt="image-20231106153710195"></p>
<p>B.只要是商业环境的所有项目，所有方法都是计划驱动方法（都要做计划、估算、跟踪）所以SCRUM也是计划驱动的</p>
<p>C.迭代式和瀑布都是迭代式场景</p>
<p>答案：BC</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458497.png" alt="image-20231106154239808"></p>
<p>答案：D。Y理论用马斯洛的高层需求（自尊和自我实现）进行激励</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458292.png" alt="image-20240101191803233"></p>
<p>答案：AD。A自我实现是五层的，寻求自尊是四层的，D高层次更多</p>
<p><img src="/ppt%E6%95%B4%E7%90%86.assets/image-20231106154615004-1704107779388.png" alt="image-20231106154615004"></p>
<p>答案：A。维持激励水平依靠<strong>绩效反馈</strong>，而马斯洛指导怎么做激励</p>
<h1 id="4-估算、计划和跟踪"><a href="#4-估算、计划和跟踪" class="headerlink" title="4. 估算、计划和跟踪"></a>4. 估算、计划和跟踪</h1><h2 id="PROBE-方法"><a href="#PROBE-方法" class="headerlink" title="PROBE 方法"></a>PROBE 方法</h2><ol>
<li>估算的目的是给各类计划提供决策依据</li>
</ol>
<p>PROBE：精确度量和早期规划需要的度量之间的桥梁：相对大小矩阵</p>
<p><strong>PROBE 方法例子</strong></p>
<ol>
<li>估算房子面积大小<ol>
<li>使用房间相对大小矩阵</li>
<li>使用房间作为代理</li>
</ol>
</li>
<li>估算程序规模和工作量<ol>
<li>使用代码相对大小矩阵<ol>
<li>每个组件都有设定的类型（计算、逻辑或数据）</li>
<li>规模（非常小、小、中、大、非常大）</li>
</ol>
</li>
<li>假设<ol>
<li>如果新建立的组件与以前建立的组件类似，那么新组建所需的工作量与旧组件一样。</li>
<li>当开始一个新项目时，我们可以将任务划分为与代码库中组件相似的类型和规模，然后利用线性回归方法来估算项目的工作量。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>方法思想</strong></p>
<ol>
<li>在 PROBE 估算中，需要建立自己的代码库，以跟踪所有程序的规模和工作量，而代码库中的每个组件都有设定的类型（计算、逻辑或数据等）和规模（非常小、小、中、大、非常大）。<ol>
<li>如果新建立的组件与以前建立的组件类似，那么新组件所需的工作量与旧组件一样。</li>
<li>当开始一个新项目时，我们可以将任务划分成与代码库中组件相似的类型和规模，然后利用线性回归方法来估算项目的工作量。</li>
</ol>
</li>
<li>估算本质上是一种猜测，追求的目标是一致性以及估算结果的使用者对估算结果的信心。<ol>
<li>PROBE 方法通过定义估算过程和数据收集以及使用的框架，使得估算结果可以尽可能一致，从而使得一些统计方法可以用来调整估算结果，增强用户对估算结果的信心。</li>
<li>PROBE 方法非常<strong>依赖高质量的历史数据</strong>，一旦数据不完整或缺失，会导致估算结果有明显偏差。</li>
</ol>
</li>
</ol>
<blockquote>
<ol>
<li>上述框架中，那些步骤必须人为的干预<ol>
<li>定义需求</li>
<li>概要设计：划分由人为开始，规模划分好之后估算是自动产生的</li>
<li>日程计划</li>
</ol>
</li>
<li>这会带来什么的好处？比较容易扛住别人的质疑。<ol>
<li>攻击点：资源和时间是否被高估了</li>
<li>解决：估算没有代码行 PROBE 只有功能点是大中小。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="PROBE-估算过程"><a href="#PROBE-估算过程" class="headerlink" title="PROBE 估算过程"></a>PROBE 估算过程</h2><p><img src="https://eaglebear2002.github.io/8725/2.png" alt="img"></p>
<ol>
<li>概要设计<ol>
<li>确定产品功能，以及产生这些功能所需的程序组件&#x2F;模块</li>
<li>将程序组件&#x2F;模板与你之前写的程序相比较，估算它们的规模</li>
<li>最后将程序组件&#x2F;模块估算综合给出总规模</li>
</ol>
</li>
<li><strong>估算要点</strong>：<ol>
<li>尽可能划分详细一些：估算多个部件的时候，总的误差会比各个部件的误差的总和小</li>
<li>建立对结果的信心</li>
<li>依赖数据</li>
<li>估算要的是过程，而非结果，估算的过程是相关干系人达成一致共识的过程。</li>
</ol>
</li>
</ol>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><h3 id="工作分解结构WBS"><a href="#工作分解结构WBS" class="headerlink" title="工作分解结构WBS"></a>工作分解结构WBS</h3><ol>
<li>工作分解结构是以可交付成果为导向对满足项目目标和开发交付产物的项目相关工作进行的分解。<ol>
<li>它归纳和定义了项目的整个工作范围。</li>
<li>每下降一层代表对项目工作的更详细定义。</li>
</ol>
</li>
<li>作用&#x2F;特点<ol>
<li>提供了项目<strong>范围基线</strong>，是范围变更的重要输入。</li>
<li>可以展现项目<strong>整体观</strong>，使得项目团队成员可以集中注意力实现项目的目标上。</li>
<li>为开发项目提供了一个整体框架，<strong>防止遗漏项目的可交付成果</strong>。</li>
<li>使得项目中各个角色的<strong>责任更明确</strong>，帮助项目团队的建立和获得项目成员的承诺。</li>
<li>为评估和分配任务提供具体的<strong>工作包的定义</strong>，工作包可以分配给项目某个成员或者另一个团队。</li>
<li>是进行<strong>估算和编制项目日程计划的基础</strong>。</li>
<li>可以帮助项目团队<strong>理解工作</strong>内容，<strong>分析项目的风险</strong>。</li>
</ol>
</li>
<li>表示方式<ol>
<li>树型层次结构</li>
<li>清单型层次结构</li>
</ol>
</li>
</ol>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458645.png" alt="image-20240101163523204"></p>
<p><strong>创建 WBS</strong></p>
<ol>
<li>将复杂的项目逐步分解为一系列明确定义的工作任务并作为随后计划活动的指导文档。</li>
<li>要将整个项目分解成工作包：<ol>
<li>识别和分析可交付成果以及相关工作。</li>
<li>确定工作分解结构的结构与编排方法。</li>
<li>自上而下逐层细化分解。</li>
<li>为工作分解结构组成部分制定和分配标志编码。</li>
<li>核实工作分解的程度是必要且充分的。</li>
</ol>
</li>
</ol>
<p><strong>好的 WBS 的检查标准</strong></p>
<ol>
<li>最底层要素不能重复，即任何一个工作应该在 WBS 中的一个地方且只应该在 WBS 中的一个地方出现。</li>
<li>所有要素必须清晰完整定义，即相应的数据词典必须完整定义。</li>
<li>最底层要素必须有定义清晰的责任人，可以支持成本估算和进度安排。</li>
<li>最底层要素是实现目标的成分必要条件，即项目的工作范围得到完整体现。</li>
</ol>
<p><strong>范围管理</strong></p>
<ol>
<li>包括确保项目做且只做成功完成项目所需的全部工作的各过程。</li>
<li>WBS 为范围管理提供了基础<ol>
<li>收集需求</li>
<li>定义范围</li>
<li>创建 WBS</li>
<li>核实范围</li>
<li>控制范围变更</li>
</ol>
</li>
</ol>
<h3 id="开发策略与计划"><a href="#开发策略与计划" class="headerlink" title="开发策略与计划"></a>开发策略与计划</h3><ol>
<li>定义：是在产品组件需求基础之上，明确每个产品组件的获得方式与顺序，从而在项目团队内部建立起大家都理解的产品开发策略</li>
<li>注意事项：<ol>
<li>WBS 的使用</li>
<li>产品组件开发顺序的考虑</li>
<li>产品组件获得方式的考虑</li>
</ol>
</li>
</ol>
<h3 id="过程框架：生命周期模型"><a href="#过程框架：生命周期模型" class="headerlink" title="过程框架：生命周期模型"></a>过程框架：生命周期模型</h3><ol>
<li>生命周期模型的各个阶段<ol>
<li>项目启动阶段</li>
<li>项目策划阶段</li>
<li>需求开发阶段</li>
<li>技术实现阶段</li>
<li>集成与测试阶段</li>
<li>交付与维护阶段</li>
<li>项目总结</li>
</ol>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/34.png" alt="img"></p>
<h3 id="日程计划原理和方法"><a href="#日程计划原理和方法" class="headerlink" title="日程计划原理和方法"></a>日程计划原理和方法</h3><ol>
<li>任务计划描述了项目所有的<strong>任务清单</strong>，任务之间的先后顺序以及每个任务所需时间资源。</li>
<li><strong>资源清单</strong></li>
<li><strong>日程计划</strong>描述了每个任务在日志上的安排，即每个任务计划哪天开始和计划哪天结束。</li>
<li>制定资源计划，结合任务计划就可以定义日程计划</li>
<li>团队形式的日程计划考虑<ol>
<li>资源平衡：要求项目团队结合每个团队成员的工作效率、工作内容以及资源水平，找到一个时间点，让所有团队成员几乎同时完成任务</li>
<li>资源同步：安排日程时必须兼顾某些项目人物之间的依赖关系。</li>
</ol>
</li>
</ol>
<p><strong>典型计划流程回顾</strong></p>
<ol>
<li>估算规模</li>
<li>估算资源</li>
<li>规划日程</li>
</ol>
<h3 id="质量计划原理和方法"><a href="#质量计划原理和方法" class="headerlink" title="质量计划原理和方法"></a><strong>质量计划原理和方法</strong></h3><ol>
<li>项目的质量计划中应当确定需要开展的质量保证活动。</li>
<li>典型的质量保证活动包括了个人评审、团队评审、单元测试、集成测试以及验收测试等。</li>
<li>在质量计划中需要解决的关键问题是该开展哪些活动，以及这些活动开展的程度，如时间、人数和目标是什么。</li>
</ol>
<h3 id="风险计划"><a href="#风险计划" class="headerlink" title="风险计划"></a>风险计划</h3><ol>
<li>风险管理的目标是：在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目产生的负面影响。</li>
<li>风险管理是一个持续的、前瞻的过程，此过程是项目管理的重要部分。有效的风险管理是通过相关干系人的合作与参与，尽快且积极地识别风险，指定项目风险管理计划。<ol>
<li>风险管理需要同时考虑有关成本、进度、绩效以及其他风险的内部及外部来源。</li>
<li>在项目初期进行变更或修正的工作负荷，通常比在项目后期来得容易、花费较低且较不具破坏性。</li>
<li>早期且积极的风险侦测是重要的。</li>
</ol>
</li>
<li>风险管理大致分为两部分，即风险识别和风险应对。</li>
<li>早期风险侦测的重要性：在项目初期进行变更或修正的工作负荷，通常比在项目后期来得容易、花费较低及较不具破坏性。</li>
</ol>
<p><strong>风险识别</strong></p>
<ol>
<li>风险：没有发生，有一定概率会发生，发生后有一定影响</li>
<li>问题：已经发生的，比如人员调动等。</li>
<li>典型的识别方法<ol>
<li>检查 WBS 的每个组件以找出相应的风险</li>
<li>使用定义好的风险分类表上来评估风险</li>
<li>访谈相关的领域专家</li>
<li>与类似项目进行比较来审查风险管理</li>
<li>检查以往项目的总结报告或组织级数据库</li>
<li>检查设计规格和协议书需求。</li>
</ol>
</li>
<li>典型的风险识别活动包括<ol>
<li>识别与成本、进度及绩效相关的风险</li>
<li>审查可能影响项目的环境因素</li>
<li>审查工作分解结构的所有组件，作为风险识别的一部分，以协助确保所有的工作投入均已考虑</li>
<li>审查项目计划的所有组件，作为风险识别的一部分，以确保项目在各方面均已考虑</li>
<li>记录风险的内容、条件及可能的结果</li>
<li>识别每一风险相关的干系人</li>
<li>利用已定义的风险参数，评估已识别的风险</li>
<li>依照定义的风险类别，将风险分类并分组</li>
<li>排列降低风险的优先级<ol>
<li>可能性很低，但是发生影响程度很大：政策变化、领导层大规模变动、公司倒闭</li>
<li>[P（可能性）, I（影响程度）, T（阈值）]</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>风险应对</strong></p>
<ol>
<li>识别风险之后，就应当制定相应的风险管理策略，以应对各类风险</li>
<li>典型的策略包括<ol>
<li>风险转嫁<ol>
<li>指通过某种安排，在放弃部分利益的同时，将部分的项目风险转嫁到其他的团队或者组织。</li>
<li>比如有的公司采取外包的方式，把一部分有技术风险的产品组建交由其他公司开发，在放弃部分收益的同时，也规避了技术风险。</li>
</ol>
</li>
<li>风险解决<ol>
<li>指采用一些有效措施，使得风险的来源不再存在。</li>
<li>这往往是一种预防性的手段，比如针对项目面临的技术风险，采取技术调研或者引进技术专家的手段，使得原有的风险来源不再存在或者存在可能性极低，从而测试解决该风险。</li>
</ol>
</li>
<li>风险缓解<ol>
<li>指容忍风险的存在，采取一些措施监控风险，不让风险对项目最终目标的实现造成负面影响。<ol>
<li>一般情况下，都需要指定相应的风险缓解计划：理性对待每个关键性的风险，研究可选择的应对方案，并对每个风险皆制定相应的行动过程，是风险缓解计划的关键内容。</li>
<li>特定风险的风险缓解计划包括规避、降低及控制风险发生可能性的技术和方法，或降低风险法身时遭受的损失程度的方法，或上述两者。</li>
</ol>
</li>
<li>监控风险：<ol>
<li>当风险超过设定的阈值时，实施风险缓解计划，以使受冲击的部分回归到可接受的风险等级。</li>
<li>只有当风险结果评定为高或者无法接受时，才相应指定风险缓解计划和紧急应对计划，其他情况只需要适当监控即可。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="计划评审与各方承诺"><a href="#计划评审与各方承诺" class="headerlink" title="计划评审与各方承诺"></a>计划评审与各方承诺</h2><ol>
<li>项目各项计划完成之后，需要与各类计划的相关干系人开展评审工作，解决工作中相互矛盾与不一致的地方，并获得参与项目的各方对项目计划的承诺。<ol>
<li>识别每一项计划所需支持，并与相关干系人协商承诺。</li>
<li>记录所有的承诺，包括完整的承诺和临时的承诺，并确保由适当层次的人员签署。</li>
<li>适当与资深管理人员一起审查承诺。</li>
</ol>
</li>
</ol>
<blockquote>
<h3 id="团队项目规划：TSP-项目启动"><a href="#团队项目规划：TSP-项目启动" class="headerlink" title="团队项目规划：TSP 项目启动"></a>团队项目规划：TSP 项目启动</h3><h4 id="TSP-的九次会议"><a href="#TSP-的九次会议" class="headerlink" title="TSP 的九次会议"></a>TSP 的九次会议</h4><p><img src="https://eaglebear2002.github.io/8725/25.png" alt="img"></p>
<ul>
<li>几个认识<ul>
<li>错误的认识：软件开发阶段理解为注入缺陷的阶段，软件测试阶段理解为消除缺陷的阶段。</li>
<li>正确的认识：开发和测试都是既有可能引入缺陷，也有可能消除缺陷的阶段</li>
</ul>
</li>
<li>项目完成的实际时间由什么决定？最晚完成的工作的人决定的</li>
<li>经过平衡的计划和没有平衡的计划有什么不一样？更有把握去成功。</li>
</ul>
</blockquote>
<h2 id="跟踪与分析"><a href="#跟踪与分析" class="headerlink" title="跟踪与分析"></a>跟踪与分析</h2><p><strong>项目跟踪意义</strong></p>
<ol>
<li>在项目进展过程中开展跟踪活动的目的在于了解项目进度，以便在项目实际进展和计划产生严重偏差时，可采取适当的纠正措施。<ol>
<li>项目进度滞后与是否需要参照物，即项目计划。</li>
<li>项目跟踪需要管理偏差而采取的纠偏措施。</li>
</ol>
</li>
<li>团队项目的跟踪与管理主要包括进度的跟踪（利用不同跟踪方法，例如挣值管理、里程碑评审）、纠偏活动管理</li>
</ol>
<h3 id="项目的挣值管理方法EVM"><a href="#项目的挣值管理方法EVM" class="headerlink" title="项目的挣值管理方法EVM"></a>项目的挣值管理方法EVM</h3><p><strong>什么是 EVM？</strong></p>
<ol>
<li>项目的挣值管理方法是用来客观度量项目进度的一种项目管理方法。<ol>
<li>每项任务实现附以一定价值（credit）</li>
<li>100%完成该项任务，就获得相应的价值。</li>
</ol>
</li>
<li>EVM 采用与进度计划、成本预算和实际成本相联系的三个独立的变量，进行项目绩效测量。</li>
</ol>
<p><strong>挣值管理实现</strong></p>
<ol>
<li><p>简单实现：这种方式仅仅关注进度信息。</p>
<ol>
<li>在实现时，首先需要建立WBS，定义工作范围；</li>
<li>其次为WBS中每一项工作定义一个价值（PV）；</li>
<li>最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作。常用规则分别为0-100规则和50-50规则，前者只有当某项任务完成时，该任务的PV值将转化成EV值；后者只需要开始某项任务，即可以赋原PV值的50%作为EV值，完成时，再加上另外的50%。而实际完成的工作所需成本AC不对EV值产生任何影响。</li>
</ol>
</li>
<li><p>中级实现：在简单实现的基础上，加入日程偏差的计算。典型计算方式有：</p>
<ol>
<li>日程偏差SV &#x3D; EV – PV;</li>
<li>日程偏差指数SPI &#x3D; EV&#x2F;PV；</li>
</ol>
</li>
<li><p>高级实现：在中级实现的基础上，还需要考察项目的实际成本。</p>
</li>
</ol>
<p><strong>挣值管理图解</strong></p>
<p>PV：Planned Value,截止某时间点计划要完成工作量的价值（理想情况） 4000元</p>
<p>EV：Earned Value,截止到某时间点实际已经完成工作量的价值 3000元</p>
<p>AC：Actual Cost,截止到某时间点实际已经发生的成本 5000元</p>
<p>BAC：对完成该项目的计划预算 10000元<img src="https://pic3.zhimg.com/80/v2-151f19e36fcecade40e04a6d5e7e1946_1440w.webp" alt="img" style="zoom:25%;" />花钱快做事慢</p>
<p>绩效指标：</p>
<p>成本偏差<strong>CV&#x3D;EV-AC **   成本绩效指数</strong>CPI&#x3D;EV&#x2F;AC** 每花一元钱，完成做了多少钱的事</p>
<p>进度偏差<strong>SV&#x3D;EV-PV</strong>  进度绩效指数<strong>SPI&#x3D;EV&#x2F;PV</strong> 实际完成的工作量与计划完成工作量之比</p>
<p>EAC&#x3D; AC+(BAC-EV)&#x2F;CPI  按照目前的进展已经成本消耗情况+整个项目完成时所需消耗的成本</p>
<p><img src="https://eaglebear2002.github.io/8725/24.png" alt="img"></p>
<p>挣值管理会带来什么好处？可以很好的适应项目的动态变化。</p>
<p><strong>挣值管理的度量</strong></p>
<ol>
<li>BAC 表示按照 PV 值的曲线，当项目完成的时候所需预算或者时间</li>
<li>成本差异 CV &#x3D; EV-AC，表示的是已经完成的工作与所消耗的成本的差异。可以表示为消耗的时间，也可以表示为消耗的资金。</li>
<li>成本差异指数 CPI &#x3D; EV&#x2F;AC，表示单位成本创造的价值<ol>
<li>CPI&lt;1 说明成本超支</li>
<li>CPI&#x3D;1 说明成本与预期一致</li>
<li>CPI&gt;1 说明成本低于预期。</li>
</ol>
</li>
<li>日程偏差 SV &#x3D; EV – PV，表示进度偏差。<ol>
<li>SV&lt;0 表示进度落后；SV&#x3D;0 表示进度正常</li>
<li>SV&gt;0 表示进度超前。</li>
</ol>
</li>
<li>日程偏差指数 SPI &#x3D; EV&#x2F;PV</li>
<li>预计完成成本 EAC &#x3D; AC+(BAC-EV)&#x2F;CPI &#x3D; BAC&#x2F;CPI，表示的是按照目前的进展已经成本消耗情况，整个项目完成的时候所需消耗的成本。</li>
</ol>
<p><strong>挣值管理的应用</strong></p>
<ol>
<li>发现项目已经滞后<ol>
<li><strong>削减功能</strong>，使得已经完成的任务的 EV 值增加</li>
<li>通过加班或加人等手段，有效提升获取 EV 值的速度</li>
<li>加强成本监控</li>
</ol>
</li>
<li>见课本 126 页相关例子<ol>
<li>EV 值显示的项目落后可能是假象</li>
<li>分析例子</li>
</ol>
</li>
</ol>
<p><strong>挣值管理的局限性</strong></p>
<ol>
<li>一般<strong>不能应用软件项目的质量管理</strong>。</li>
<li>需要定量化的管理机制，这就使得在一些探索型项目以及常用的敏捷开发方法中的应用受到限制。</li>
<li>完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算。</li>
</ol>
<p><strong>另一种挣值管理变形：燃尽图</strong></p>
<p><img src="https://eaglebear2002.github.io/8725/42.png" alt="img"></p>
<ol>
<li>燃尽图是简单的挣值管理的变形。</li>
<li>他是剩下的工作占的百分比。</li>
</ol>
<h3 id="里程碑评审"><a href="#里程碑评审" class="headerlink" title="里程碑评审"></a>里程碑评审</h3><ol>
<li>软件项目的里程碑往往是指某个时间点，用以标记某些工作的完成或者阶段的结束。<ol>
<li>典型的里程碑事件：<ol>
<li>完成某项工作</li>
<li>获得干系人签字认可</li>
<li>完成某产物的评审</li>
<li>修改或交付某产物</li>
</ol>
</li>
</ol>
</li>
<li>里程碑评审的审查内容包括：<ol>
<li>项目相关的承诺，如日期、规格、质量等等；</li>
<li>项目各项计划的执行状况；</li>
<li>项目当前的状态讨论；</li>
<li>项目面临的风险讨论等</li>
</ol>
</li>
<li>里程碑评审也可用于质量管理</li>
</ol>
<p><strong>其他类型跟踪方法</strong></p>
<ol>
<li>日程计划跟踪</li>
<li>承诺计划跟踪</li>
<li>风险计划跟踪</li>
<li>数据收集计划跟踪</li>
<li>沟通计划跟踪</li>
</ol>
<h3 id="纠偏活动的管理"><a href="#纠偏活动的管理" class="headerlink" title="纠偏活动的管理"></a>纠偏活动的管理</h3><p>典型的纠偏活动包括：偏差原因分析、纠偏措施定义、纠偏措施管理</p>
<ol>
<li>偏差原因分析：收集偏差相关的各种信息，基于收集到的信息，开展充分的分析工作，找出偏差的根本原因。</li>
<li>纠偏措施定义：确认偏差的根本原因，就可以有针对性地定义纠偏的措施。</li>
<li>纠偏措施管理：管理纠偏措施直到结项。</li>
</ol>
<blockquote>
<h4 id="项目审查"><a href="#项目审查" class="headerlink" title="项目审查"></a>项目审查</h4><blockquote>
<p>审查的内容包括</p>
</blockquote>
<ol>
<li>项目相关的承诺，如日期、规格、质量等等。</li>
<li>项目各项计划的执行状况。</li>
<li>项目当前的状态讨论</li>
<li>项目面临的风险讨论</li>
<li>其他计划跟踪</li>
<li>日程计划跟踪</li>
<li>承诺计划跟踪</li>
<li>风险计划跟踪</li>
<li>数据收集计划跟踪</li>
<li>沟通计划跟踪</li>
</ol>
</blockquote>
<h3 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h3><p><strong>项目总结的定义</strong></p>
<ol>
<li>项目总结需要系统化有条理的进行，才能不遗漏重要的内容。</li>
<li>因此往往需要事先定义总结过程，然后就按部就班地开展总结工作。</li>
</ol>
<p><strong>一般项目总结流程</strong></p>
<blockquote>
<p>基于 PMBOK 的总结方式，包含范围管理、时间管理、成本管理、质量管理、人力资源管理、沟通管理、风险管理、采购管理和整合管理 9 大知识领域（每个领域具体内容见 Lec-4)</p>
</blockquote>
<ol>
<li>项目范围包括产品范围和项目范围。对项目范围管理的总结应当主要关注项目的需求开发过程与变更管理中的得失，对需求管理实际执行情况的差距进行原因分析，找到改进的机会。</li>
<li>时间管理所关注的就是项目的日程计划以及对日程计划的跟踪和管理状况。因此主要考察计划的准确程度以及各个里程碑的偏差情况。</li>
<li>成本管理包括对成本进行估算、预算和控制的各个过程，从而确保项目在批准的预算内完工</li>
<li>质量管理包括执行组织确定质量政策、目标与职责的各过程和活动，从而使项目满足其预定的需求。</li>
<li>人力资源管理包括组织、管理与领导项目团队的各个过程。</li>
<li>沟通管理包括为确保项目信息及时且恰当地生成、收集、发布、存储、调用最终处置所需的各个过程</li>
<li>风险管理包括风险管理规划、风险识别、风险分析、风险应对规划和风险监控等各个过程。</li>
<li>采购管理包括从项目组织外部采购或获得所需产品、服务或成果的各个过程。</li>
<li>整合管理包括为识别、定义、组合、统一与协调项目管理过程组的各过程及项目管理活动而进行的各种过程和活动</li>
</ol>
<p><strong>TSP 项目总结方式</strong></p>
<ol>
<li>准备阶段</li>
<li>过程数据评审阶段：该阶段往往由过程经理或者质量经理带领整个团队分析过程数据，识别过程改进机会。<ol>
<li>可以结合典型 TSP 团队角色，逐个讨论改进领域。如团队领导力、计划准确性、过程优劣、质量管理能力、开发环境以及配置管理等。</li>
<li>此外，也可以就 TSP 教练的作用进行评价。</li>
<li>过程数据评审阶段还要求开发团队的所有成员都整理过程改进提案（PIP）：PIP 是 TSP 过程中供开发人员在日程工作中记录改进想法的工具。其基本思想是积累小的改进，慢慢形成大的改进。在软件开发过程中，重大的改进机会不多，因此，往往需要从小做起，慢慢积累之后，就会形成对原有过程的显著改进。小的改进机会虽然多，但是容易被遗忘，PIP 的作用就在于提供了一个标准表格工具，允许软件工程师时时记录改进方案。在项目总结阶段，将开发过程中记录的所有 PIP 整理出来，形成整个开发周期的过程改进提案，供讨论，以确定下个开发周期要实施的过程改进。</li>
</ol>
</li>
<li>人员角色评价阶段（角色包括项目组长、计划经理、开发经理、质量经理、过程经理和支持经理）：详见 Lec-4</li>
<li>总结报告撰写阶段</li>
</ol>
<p><strong>通用项目总结流程</strong></p>
<ol>
<li>准备阶段</li>
<li>总结阶段</li>
<li>报告阶段</li>
</ol>
<p><strong>项目总结的意义</strong></p>
<p>提供一个系统化的方式来总结经验教训、防止犯同样的错误、评估项目团队绩效、积累过程数据等，给项目团队成员持续学习和改进的机会。</p>
<h2 id="思考与讨论-1"><a href="#思考与讨论-1" class="headerlink" title="思考与讨论"></a>思考与讨论</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458656.png" alt="image-20240101192202692"></p>
<p>A：WBS是将项目分解为<strong>细粒度的功能元素</strong>，用来指导项目开发的规划和设计。<br>OBS是关于项目内部组织的，是将项目团队一些特点进行<strong>分工、职责分配</strong>。<br>他们的分析方法类似，但不需要彼此对应。错。</p>
<p>B:WBS可以对项目功能或者项目的开发过程做分解，可以方便范围管理的分阶段<br>进行。正确。</p>
<p>C：正确。</p>
<p>D：每一层确实必须用同样的标准分解。</p>
<p>答案：A。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458713.png" alt="image-20240101193111728"></p>
<p>A.EVM是度量项目开发进度、成本的，不适用于质量管理，正确。</p>
<p>B.低级实现引入EV(挣值) ，中级引入BAC（项目总预算），高级引入成本（AC）错误</p>
<p>C.估算越准确当然越好，正确</p>
<p>D.挣值管理可以实时计算项目实际进度和预期进度的区别，正确</p>
<p>答案：B。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458702.png" alt="image-20240101193852397"></p>
<p>答案：ABC。</p>
<p>D：挣值管理很好的适应于需求变更</p>
<h1 id="5-质量管理"><a href="#5-质量管理" class="headerlink" title="5. 质量管理"></a>5. 质量管理</h1><h2 id="PSP-质量观与质量策略"><a href="#PSP-质量观与质量策略" class="headerlink" title="PSP 质量观与质量策略"></a>PSP 质量观与质量策略</h2><ol>
<li>软件项目的日程、成本以及质量三大目标统一于质量目标</li>
<li>什么是软件质量？<ol>
<li>与软件产品满足规定的和隐含的需求能力有关的特征或者特征的全体</li>
<li>PSP 中定义质量为满足用户需求的程度，需要明确用户需求的范围、优先级、度量方式</li>
</ol>
</li>
<li>软件质量分为内外两部分的特性<ol>
<li>其外部质量特性<strong>面向软件产品的最终用户</strong>。</li>
<li>其内部质量特性不直接面向最终用户。</li>
</ol>
</li>
<li>软件质量的不同视角<ol>
<li>软件质量为软件产品可以改变世界，使世界更加美好的程度。从用户的角度考察软件质量，用户满意度是最为重要的判断标准。</li>
<li>软件质量是对人（用户）的价值，这一定义强调了质量的主观性，即对于同一款软件而言，不同的用户对其质量有不同的体验。</li>
</ol>
</li>
</ol>
<h2 id="面向用户的质量观"><a href="#面向用户的质量观" class="headerlink" title="面向用户的质量观"></a>面向用户的质量观</h2><ol>
<li>PSP 中也采用了面向用户的质量观，定义质量为<strong>满足用户需求的程度</strong>。在这个定义中，就需要进一步明确：<ol>
<li>用户究竟是谁？</li>
<li>用户需求的优先级是什么？</li>
<li>这种用户的优先级对软件产品的开发过程产生什么样的影响？</li>
<li><strong>怎样来度量这种质量观下的质量水平？</strong></li>
</ol>
</li>
<li>典型用户质量期望<ol>
<li>这款软件产品必须能够工作：因此可以使用缺陷管理代替质量管理</li>
<li>这款软件产品最好有较快的执行速度</li>
<li>这款软件产品最好在安全性、保密性、可用性、可靠性、兼容性、可维护性、可移植性等方面表现优异。</li>
</ol>
</li>
<li>指导意义<ol>
<li>开发在前，运维在后</li>
<li>高质量开发确保 DevOps 中的价值顺畅流动</li>
<li>个体软件工程师的技能、过程直接影响产品质量</li>
<li>PSP 关注提升个体软件工程师工程技能</li>
</ol>
</li>
</ol>
<h2 id="质量策略"><a href="#质量策略" class="headerlink" title="质量策略"></a>质量策略</h2><ol>
<li><strong>使用缺陷管理来代替质量管理</strong></li>
<li>高质量的产品也就意味着组成软件产品的各个组件基本无缺陷</li>
<li>各个组件的高质量是通过高质量评审来实现的；</li>
</ol>
<h2 id="质量路径-Quality-Journey"><a href="#质量路径-Quality-Journey" class="headerlink" title="质量路径 Quality Journey"></a>质量路径 Quality Journey</h2><blockquote>
<p>为了追求极高的质量，你有哪些手段？</p>
<p>顺序不能更换。</p>
</blockquote>
<ol>
<li>第一步：各种测试</li>
<li>第二步：进入测试之前的产物质量提升</li>
<li>第三步：评审过程度量和稳定</li>
<li>第四步：质量意识和主人翁态度</li>
<li>第五步：个体 review 的度量和稳定</li>
<li>第六步：诉诸设计</li>
<li>第七步：缺陷预防</li>
<li>第八步：用户质量观 —— 其他质量属性</li>
</ol>
<h2 id="发现缺陷的几个示例流程"><a href="#发现缺陷的几个示例流程" class="headerlink" title="发现缺陷的几个示例流程"></a>发现缺陷的几个示例流程</h2><p><strong>测试消除缺陷的典型流程</strong></p>
<ol>
<li>发现待测程序的一个异常行为</li>
<li>理解程序的工作方式</li>
<li>调试程序，找到出错的位置，确定出错的原因：非常耗时，在项目后期可能会消耗数天甚至数周的时间</li>
<li>确定修改方案，修改缺陷</li>
<li>回归测试，以确认修改有效</li>
</ol>
<p><strong>评审发现缺陷的典型流程</strong></p>
<blockquote>
<p>在如下的步骤中，每一步消耗的时间都不会太多。尽管评审的技能因人而异，但是，通过适当培训和积累，有经验的评审者可以发现 80%左右的缺陷。</p>
</blockquote>
<ol>
<li>遵循评审者的逻辑来理解程序流程</li>
<li>发现缺陷的同时，也知道了缺陷的位置和原因</li>
<li>修正缺陷</li>
</ol>
<h2 id="评审与测试"><a href="#评审与测试" class="headerlink" title="评审与测试"></a>评审与测试</h2><p><strong>评审检查表</strong></p>
<ol>
<li>评审检查表的建立和维护：示例见课本</li>
<li>评审检查表的使用</li>
</ol>
<p><strong>评审形式</strong></p>
<blockquote>
<p><strong>打印</strong>后评审效果更好</p>
</blockquote>
<ol>
<li>单个屏幕可以展现的内容比较有限（评审对象比较复杂的时候，单个屏幕往往不能体现评审对象的整体结构、整体安全、整体性能以及其他整体属性）</li>
<li>评审人员的注意力：基于屏幕的评审往往容易受到干扰，从而影响评审人员的注意力</li>
</ol>
<p><strong>评审时机</strong></p>
<ol>
<li>编译、评审<ol>
<li>对于某些类型的缺陷而言，通过编译发现并消除的效率往往是通过评审发现并消除的数倍。（编译速度&gt;评审速度）<ol>
<li>越来越强大的编译器一般可以发现超过 90% 的拼写错误。</li>
<li>不管怎么努力，评审还有会遗漏约 20-50% 的语法错误。</li>
<li>即便编译器遗漏了一些类似语法的错误，这些错误也不难通过单元测试消除。</li>
</ol>
</li>
<li>一些基于解释执行的集成开发环境，可以实现消除编译错误。</li>
</ol>
</li>
<li>评审、编译（更应该选择这个）<ol>
<li>为了确保评审的效率，不管在评审之前有没有编译，<strong>评审的速度是一定的</strong>，也就意味着评审所需时间是一定的，那么如果先评审后编译，<strong>在编译阶段就可以节省较多的时间。</strong></li>
<li>编译器会大概会遗漏 9%左右的缺陷，从前面讨论可知，为了有较高的质量，这些缺陷仍然期望通过评审加以消除。</li>
<li>有数据表明，编译过程中缺陷较多，往往意味着单元测试中缺陷也较多。</li>
<li>即便单元测试也可以发现一些类似语法的错误，但是，毕竟还有些很难发现，而单元测试之后的一些缺陷消除环节的 Phase Yield 往往还低于单元测试。</li>
<li>编译之前评审也是一种自我学习的好机会。</li>
<li>干净的编译，即编译过程没有缺陷对于软件工程师来说，也有极大的成就感。</li>
</ol>
</li>
</ol>
<p><strong>评审的具体形式</strong></p>
<blockquote>
<p>个人评审、小组评审</p>
</blockquote>
<ol>
<li>个人评审 -&gt; 小组评审</li>
<li>小组评审的意义<ol>
<li>有利于更好地发现缺陷，预防风险，提高 <strong>Process Yield</strong> 进而确保质量。</li>
<li>在个人评审之后安排小组评审，也有利于提升个人的技能。特别是那些个人评审未发现而个人评审发现的缺陷，往往都需要引起足够的注意。软件工程师通过对这些缺陷的分析，往往可以学到很多东西。</li>
</ol>
</li>
</ol>
<p><strong>评审中缺陷预防过程中的缺陷数据选择</strong></p>
<ol>
<li>选择那些在系统测试、验收测试以及应用环节出现的缺陷，特别是验收测试和应用环节中的缺陷，这些缺陷往往意味着软件开发过程本身有不足之处。</li>
<li>选择那些在出现频率较高或者消除代价较高的缺陷，这些缺陷如果可以预防，往往可以节省较多开发的代价，从而体现缺陷预防的优势。</li>
<li>选择那些预防方法容易识别和实现的缺陷，这样的策略容易让软件工程师迅速看到缺陷预防的好处，鉴定使用缺陷预防策略的信心。</li>
</ol>
<h2 id="PSP-质量控制的衍生指标"><a href="#PSP-质量控制的衍生指标" class="headerlink" title="PSP 质量控制的衍生指标"></a>PSP 质量控制的衍生指标</h2><h3 id="Yield-指标"><a href="#Yield-指标" class="headerlink" title="Yield 指标"></a>Yield 指标</h3><p><strong>基本定义</strong></p>
<ol>
<li>定义了各个阶段在消除缺陷方面的效率<ol>
<li>Yield 指标越高越好</li>
<li>Process Yield 我们期望在 80 以上</li>
</ol>
</li>
</ol>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458923.png" alt="image-20240101195653846"></p>
<ol>
<li>Yield 可用于制定质量计划并且在项目执行阶段用于进行风险监控、预测、识别以及控制</li>
</ol>
<p>Yield 的计算是一种<strong>事后的质量控制手段</strong>，而且除非发现了所有的缺陷，否则很难非常精确地进行计算。</p>
<p><img src="https://eaglebear2002.github.io/8725/3.png" alt="img"></p>
<blockquote>
<p>上图第一个消除步骤是需求评审，第二个消除步骤是设计评审，第三个消除步骤是测试评审</p>
</blockquote>
<p>改进方案</p>
<ol>
<li>结果受限于历史数据在简单性、可理解性、稳定性、可度量性、相关性等方法的质量。因此，维护历史数据。</li>
<li>影响因子的选择上面不仅仅需要有关软件规模的数据，还需要有关开发过程、开发文档、开发人员等方面的数据，并且需要将数据可度量化。</li>
<li>反馈模型。即在开发过程中随着实际数据的产生，将这些数据作为输入变量放入模型中以调整回归参数。</li>
<li>（重要）可能的改进是假设注入水平和消除水平都符合正态分布，计算均值和标准差，因此，可以用蒙特卡罗方法模拟结果。</li>
</ol>
<h3 id="A-FR"><a href="#A-FR" class="headerlink" title="A&#x2F;FR"></a>A&#x2F;FR</h3><ol>
<li>COQ(Cost of Quality)<ol>
<li>失效成本：分析失效现象、查找原因，做必要的修改所消耗的成本</li>
<li>质检成本：评价软件产品，确定其质量状况所消耗的成本</li>
<li>预防成本：识别缺陷根本原因、采取措施预防其再次发生所消耗的成本</li>
</ol>
</li>
<li>质检失效比<ol>
<li>A&#x2F;FR &#x3D; PSP 质检成本 &#x2F; PSP 失效成本</li>
<li>质检成本 &#x3D; 设计评审时间 + 代码评审时间</li>
<li>失效成本 &#x3D; 编译时间 + 单元测试时间</li>
</ol>
</li>
<li>理论上，A&#x2F;FR 值越大，意味着质量越高，但 A&#x2F;FR 值过大说明评审过多，则开发效率低下，因此 PSP 中 A&#x2F;FR 期望值为 2.0</li>
</ol>
<h3 id="PQI-过程质量指标"><a href="#PQI-过程质量指标" class="headerlink" title="PQI 过程质量指标"></a>PQI 过程质量指标</h3><ol>
<li>为 5 个数据的乘积（以基准值作为 1，最后结果越接近 1，质量越高）<ol>
<li>设计质量：设计时间应该大于编码时间，设计时间编码时间min(设计时间编码时间,1)</li>
<li>设计评审质量：设计评审的时间应该大于设计时间的 50%，设计评审时间设计时间min(2设计评审时间设计时间,1)</li>
<li>代码评审质量：代码评审时间应该大于编码时间的 50%，代码评审时间编码时间min(2代码评审时间编码时间,1)</li>
<li>代码质量：代码的编译缺陷密度应当小于 10 个&#x2F;千行，编译缺陷密度min(20编译缺陷密度+10,1)</li>
<li>程序质量：代码的单元测试缺陷密度应当小于 5 个&#x2F;千行，单元测试缺陷密度min(10单元测试缺陷密度+5,1)（以每小时发现缺陷率作为基准）</li>
</ol>
</li>
<li>用途<ol>
<li>判断模块开发质量</li>
<li>规划质量活动计划</li>
<li>过程改进</li>
</ol>
</li>
</ol>
<h3 id="Review-Rate"><a href="#Review-Rate" class="headerlink" title="Review Rate"></a>Review Rate</h3><ol>
<li>评审的速度是一个用以指导软件工程师开展有效评审的指标</li>
<li>代码评审速度小于 200 LOC（代码行）&#x2F;h</li>
<li>文档评审速度小于 4 page（文档采用页）&#x2F;h</li>
</ol>
<h3 id="DRL-缺陷消除效率比"><a href="#DRL-缺陷消除效率比" class="headerlink" title="DRL 缺陷消除效率比"></a>DRL 缺陷消除效率比</h3><ol>
<li>缺陷消除效率比：不同缺陷消除手段消除缺陷的效率</li>
<li>计算方法：以某个测试阶段（一般为单元测试）每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是 DRL<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458459.png" alt="image-20240103182356415"></li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/20.png" alt="img"></p>
<p>发现的效率：代码评审 &gt; 设计评审 &gt; 设计检查 &gt; 代码检查 &gt; 单元测试 &gt; 系统测试</p>
<h2 id="PSP-的设计"><a href="#PSP-的设计" class="headerlink" title="PSP 的设计"></a>PSP 的设计</h2><ol>
<li>PSP 设计过程的关注点并不是具体的设计方法，而是设计的步骤定义以及设计的表现形式</li>
</ol>
<p><strong>设计与质量的关系</strong></p>
<ol>
<li>低劣的设计是导致在软件开发中返工、不易维护以及用户不满的主要原因。</li>
<li>充分设计可以显著减少最终程序的规模，提升质量</li>
<li>设计本身也是一种排除错误的过程。</li>
</ol>
<p><strong>设计什么</strong></p>
<ol>
<li>设计目标程序在整个应用系统中的位置</li>
<li>设计目标程序的使用方式</li>
<li>设计目标程序与其他组件以及模块之间的关系</li>
<li>设计目标程序外部可见的变量和方法</li>
<li>设计目标程序内部运作机制</li>
<li>设计目标程序内部静态逻辑</li>
</ol>
<p><strong>设计的过程</strong></p>
<p><img src="https://eaglebear2002.github.io/8725/21.png" alt="img"></p>
<p><strong>设计内容</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>动态信息</th>
<th>静态信息</th>
</tr>
</thead>
<tbody><tr>
<td>外部信息</td>
<td>交互信息（服务、消息等）</td>
<td>功能（继承、类结构等）</td>
</tr>
<tr>
<td>内部信息</td>
<td>行为信息（状态机）</td>
<td>结构信息（属性、业务逻辑等）</td>
</tr>
</tbody></table>
<p><strong>设计模板</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>动态信息</th>
<th>静态信息</th>
</tr>
</thead>
<tbody><tr>
<td>外部信息</td>
<td>OST&#x2F;FST</td>
<td>FST</td>
</tr>
<tr>
<td>内部信息</td>
<td>SST</td>
<td>LST</td>
</tr>
</tbody></table>
<p><strong>操作规格模板 Operational Specification Template</strong></p>
<ol>
<li>描述系统与外界的交互，用于场景描述：也就是”用户“与”待设计系统的正常情况和异常情况下的交互。</li>
<li>定义测试场景和测试用例，用来与用户讨论需求的基础，特别是操作相关的需求描述</li>
<li>与 UML 比较：用例图、时序图</li>
</ol>
<p><strong>功能规格模板（Functional Specification Template， 简称 FST）</strong></p>
<ol>
<li>描述系统的对外接口，是一种静态信息的展现。</li>
<li>提供的典型信息有类和继承关系、外部可见的属性和方法等。</li>
<li>用形式化符号等方法描述方法等行为，消除二义性。</li>
<li>与 UML 对比：没有对应图（FST是系统对外的接口，类图无法描述行为，只能描述型构）</li>
</ol>
<p><strong>状态规格模板（State Specification Template，简称 SST）</strong></p>
<ol>
<li>可以精确定义程序的所有状态、状态之间的转换以及伴随着每次状态转换的动作。</li>
<li>SST 模板中，需要描述如下的信息<ol>
<li>所有状态的名称</li>
<li>所有状态的简要描述</li>
<li>在 SST 中需要使用的参数和方法的名称与描述</li>
<li>状态转换的条件</li>
<li>状态转换是发生的动作。</li>
</ol>
</li>
<li>与 UML 对比：UML 状态图</li>
</ol>
<p><strong>逻辑规格模板（Logical Specification Template，简称 LST）</strong></p>
<ol>
<li>可以精确描述系统的内部静态逻辑。为了消除描述的二义性，一般建议使用伪代码配合形式化符号来描述设计结果。</li>
<li>LST 模板中，需要描述如下的信息<ol>
<li>关键方法的静态逻辑</li>
<li>方法的调用</li>
<li>外部引用</li>
<li>关键数据的类型和定义</li>
</ol>
</li>
<li>与 UML 对比：没有对应图</li>
</ol>
<p><strong>UML</strong></p>
<ol>
<li>UML 图有用例图、时序图、类图、状态机图</li>
<li>UML 的用例图和时序图提供了与 PSP 中 OST 同样的信息；</li>
<li>UML 中的时序图和类图所描述的类之间的关系以及对象之间的交互信息在 PSP4 个设计模板中没有对应的内容；</li>
<li>UML 类图中记录了方法的型构，然而方法的行为没有描述，这一点在 PSP 的 FST 中有相应的内容；</li>
<li>PSP 中的 LST 用以描述程序的静态逻辑，这在 UML 没有对应的图示方法；</li>
<li>UML 中的状态图与 SST 描述的状态图类似，但是 SST 中描述的关于状态、状态转换条件以及状态转换中的动作没有对应的 UML 图示方法。</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/9.png" alt="img"></p>
<h2 id="PSP-设计验证方法"><a href="#PSP-设计验证方法" class="headerlink" title="PSP 设计验证方法"></a>PSP 设计验证方法</h2><h3 id="状态机验证"><a href="#状态机验证" class="headerlink" title="状态机验证"></a>状态机验证</h3><ol>
<li><p>检查状态机的完整性和正交性</p>
<ol>
<li>完整性：对于状态机中任何一个状态，对应的所有条件组合，下一个状态的转换都有定义。</li>
<li>正交性：对于状态机中任何一个状态，其所有下一个状态的转换条件都不能相同。</li>
</ol>
</li>
<li><p>验证步骤</p>
<ol>
<li>检查状态机，消除死循环和陷阱状态</li>
<li>检查状态转换，验证完整性和正交性</li>
<li>评价状态机，检验是否体现设计意图</li>
</ol>
</li>
<li><p>具体验证方法</p>
<ul>
<li><p>检验状态机，消除死循环和陷阱状态。</p>
<p><strong>死循环</strong>是指在状态机中存在不能跳出的状态转换回路。在图 4‑11中，状态CheckID和CheckPW之间存在回路。仔细考察相应的转换条件和动作，CheckPW回到CheckID的时候，试验次数n必须小于最大容许出错的次数nMax，而本身n又会递增。因此，总有一次n将大于或者等于nMax，此时，CheckPW状态将转换到End状态，也就是跳出循环。通过上述分析，我们认为，在图 4‑11所示的状态机图中不存在死循环。</p>
<p>状态机中的陷阱状态是指<strong>在状态机中存在某个状态A，不存在从A状态转换到结束状态的路径。</strong>同样的，经过仔细考察，在图 4‑11所示的状态机图中，所有状态都可以经由一定的状态转换到大End状态，因此，也不存在陷进状态。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458483.png" alt="image-20240103185238284"></p>
</li>
<li><p>检查状态转换，验证完整性和正交性。</p>
<ul>
<li>检验从CheckPW状态出发的状态组合<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458502.png" alt="image-20240103185713764"></li>
<li>列真值表：检查完整性和正交性（感觉Timeout也应该作为一个变量？）<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458521.png" alt="image-20240103185940032"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="符号化验证"><a href="#符号化验证" class="headerlink" title="符号化验证"></a>符号化验证</h3><ol>
<li>将描述设计的逻辑规格（一般用伪代码程序表示）用<strong>代数符号</strong>来表示，然后系统地开展分析和验证</li>
<li>验证步骤<ol>
<li>识别伪码程序中的关键变量</li>
<li>将这些变量使用代数符号表示，重写伪码程序</li>
<li>分析伪码程序的行为。</li>
</ol>
</li>
<li>具体示例见 PPT：交换两个变量的值（赋初值，罗列每一步变量的变化。注意<strong>值没变时不用写</strong>！！）<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458538.png" alt="image-20240103191658272"></li>
<li>优点：这种方法通常用在<strong>验证一些复杂算法</strong>中，特别是对遗留系统的改造中，往往应用这种方法来识别和理解原有的设计。</li>
<li>缺点：这种验证方法<strong>不适用于有复杂逻辑的场合</strong>，而且，纯手工的验证方法也<strong>容易引入一些人为的错误</strong>。</li>
</ol>
<h3 id="执行表验证"><a href="#执行表验证" class="headerlink" title="执行表验证"></a>执行表验证</h3><ol>
<li>执行表</li>
<li>步骤<ol>
<li>识别伪码程序的关键变量</li>
<li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li>
<li>初始化被选定的变量（!Valid看成常量，就不是关键变量了）</li>
<li>跟踪<strong>被选择的关键变量的变化情况</strong>，从而判断程序行为<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458567.png" alt="image-20240103192115912">这里Test表示该行有没有执行成功的赋值，有就是T；然后Check会跟踪一下，Get似乎没有（看ID那一列）</li>
</ol>
</li>
<li>优点：实施简单；结果可靠，可用于复杂逻辑的验证。</li>
<li>缺点：每次只能验证一个用例；手工验证比较耗时，容易引入错误。</li>
</ol>
<h3 id="跟踪表验证"><a href="#跟踪表验证" class="headerlink" title="跟踪表验证"></a>跟踪表验证</h3><ol>
<li>步骤<ol>
<li>识别伪码程序的关键变量</li>
<li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li>
<li>初始化被选定的变量</li>
<li><strong>识别将伪码程序符号化的机会，并加以符号化</strong></li>
<li><strong>定义并且优化用例组合</strong></li>
<li>跟踪被选择的关键变量的变化情况，从而判断程序行动。<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458933.png" alt="image-20240103193820474"></li>
</ol>
</li>
<li>跟踪表应用符号化以及用例识别等方法，对程序的一般化行为进行验证，是执行表验证的补充，可以每次验证多个用例，从而提供更加高效地开展验证工作。</li>
</ol>
<h3 id="正确性验证"><a href="#正确性验证" class="headerlink" title="正确性验证"></a>正确性验证</h3><ol>
<li>将伪码程序当做<strong>数学定理</strong>，采用形式化方法加以推理和验证</li>
<li>步骤<ol>
<li>分析和识别用例</li>
<li>对于复杂伪码程序的结构，应用正确性验证的标准问题逐项加以验证</li>
<li>对于不能明确判断的复杂程序结果，使用跟踪表等辅助验证</li>
</ol>
</li>
<li>While-Do 循环的验证<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458951.png" alt="image-20240103195246206"><ol>
<li>条件 1：condition 是否最终一定会为”假”，从而使得循环可以结束。</li>
<li>条件 2：condition 为”真”的时候，单独的循环结构执行结果与循环体再加一个循环结构，其执行结果是否一致？</li>
<li>条件 3：condition 为”假”的时候，循环体内所有变量是否未被修改？</li>
</ol>
</li>
</ol>
<h2 id="思考和讨论-2"><a href="#思考和讨论-2" class="headerlink" title="思考和讨论"></a>思考和讨论</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458993.png" alt="image-20240101194246956"></p>
<p>A：PSP策略里有“拿缺陷管理替代质量管理”，因为质量管理无法管理（可靠稳定、快、质量稳定不行，因为定义、状态跟踪和纠偏很麻烦，这是管理的三要素很难定义），所以用缺陷管理替换（首要需求是不出错）正确。</p>
<p>B：评审是高质量的保障，测试是检测质量状态的，正确。</p>
<p>C：编译的速度是最快的，时间最短，错误。</p>
<p>D：PSP主要解决用户需求，处理缺陷。而外部质量直接面向最终用户，对应用户需求，正确。</p>
<p>答案：ABD</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458060.png" alt="image-20240101195014836"></p>
<p>答案：CD</p>
<p>DRL(UT) DRL(X&#x2F;UT) 期望永远大于1，可以度量</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458081.png" alt="image-20240101195358912"></p>
<p>答案：BCD</p>
<p>A：PQI&#x3D;0，没做设计&#x2F;设计评审，指标低代表过程本身有问题（五个指标相乘）</p>
<p>B：不是越高越好，0.4</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458130.png"></p>
<p>答案：AB</p>
<p>它可以判断和评估项目某个模块的质量，指出问题，做针对性的改进建议，为软件改进做依据，可以帮助制定质量计划。AB是对的，<br>C: 范围[0,1] 不可能大于1<br>D: 本身就是一个度量指标</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458353.png" alt="image-20240101195517463"></p>
<p>答案：ABCD</p>
<p>D：分子是事实，分母只能猜测，可以用1:1的比例，或其他，分母永远是预测出来的</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458372.png" alt="image-20240101200038484"></p>
<p>答案：C。</p>
<p>AD：小于200LOC</p>
<p>B：评审速度根据<strong>目标</strong>而定。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458399.png" alt="image-20240101200211496"></p>
<p>答案：CD</p>
<p>A：不能更换顺序</p>
<p>B：不涉及到需求，step1是测试</p>
<p>D：最后一条是用户质量观——其他质量属性，所以先考虑1-7中的缺陷，再考虑其他质量属性.</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458431.png" alt="image-20240101200555368"></p>
<p>答案：B。</p>
<table>
<thead>
<tr>
<th></th>
<th>动态信息</th>
<th>静态信息</th>
</tr>
</thead>
<tbody><tr>
<td>外部信息</td>
<td>OST&#x2F;FST</td>
<td>FST</td>
</tr>
<tr>
<td>内部信息</td>
<td>SST</td>
<td>LST</td>
</tr>
</tbody></table>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458502.png" alt="image-20240103200727080"></p>
<p>答案：B</p>
<p>A：时序图用例图都可以表示OST</p>
<p>C：LST可以通过伪代码方式表现</p>
<p>D：FST是系统对外的接口，没有类图能描述行为</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458582.png" alt="image-20240101202156914"></p>
<p>AB：符号化执行、跟踪表、执行表等都是全面的</p>
<p>D：符号化表通常用在验证一些复杂算法中，但不适用于有复杂逻辑的场合</p>
<p>答案：C</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458697.png" alt="image-20231129113530965"></p>
<p>加粗的地方是跟踪表唯一与执行表不同的，所以跟踪表比执行表适用面更好（因为可以用于伪代码）</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458904.png" alt="image-20240101202435548"></p>
<p>答案：ABC </p>
<p>与D独立性无关，如果加的话看跟设计意图是否一致</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458932.png" alt="image-20240101202637020"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458955.png" alt="image-20240101202809611"></p>
<p>答案：C。</p>
<p>C：安全和保密性也是质量要素</p>
<p>D:质量是与用户的主观感受有关的（如易用性），有多重属性</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458981.png" alt="image-20240101202914121"></p>
<p>答案：C</p>
<p>A：A&#x2F;FR不是越高越好，2.0左右就可以了</p>
<p>B：yield是估算指标，无法精确度量</p>
<p>C：评审应该放在编译之前，先评审再做编译、测试更省时间，否则评审完了后面还是要编译一次</p>
<p>D：PQI可以指导质量计划</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458000.png" alt="image-20240101203315752"></p>
<p>答案：A</p>
<p>B：不是唯一一种，严格来说只有符号化执行，但用了符号化执行的跟踪表也行（因为用代数符号后方便当做数学定理，进行推理和验证？）</p>
<p>C：弱于（跟踪表&#x3D;执行表+符号化）</p>
<p>D：不仅是正确性检验，其他的验证手段也都很可靠</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458410.png" alt="image-20240101203839444"></p>
<p>答案：ABCD<br>A：要能跳出循环，不是死循环，A当然对<br>B：正确，反正跳出条件都一样，无非是一次循环都执行几次循环体。<br>C：是的<br>D：程序正确性证明手段<strong>不能一定实现算法意图</strong>。因为算法意图是否实现，要看你的循环体语句，你修改状态是不是改对了。</p>
<h1 id="6-团队工程开发"><a href="#6-团队工程开发" class="headerlink" title="6.团队工程开发"></a>6.团队工程开发</h1><p>TSP 提供了：</p>
<ol>
<li>一个已经定义的团队构建过程</li>
<li>一个团队作业框架</li>
<li>一个有效的管理环境</li>
</ol>
<h2 id="需求开发"><a href="#需求开发" class="headerlink" title="需求开发"></a>需求开发</h2><blockquote>
<p>需求开发包含需求获取、需求汇总、需求验证</p>
</blockquote>
<h3 id="需求分类"><a href="#需求分类" class="headerlink" title="需求分类"></a>需求分类</h3><ol>
<li><strong>客户需求</strong>描述的是客户的期望，是客户解决问题的愿望。<ol>
<li>客户需求可能很简单，也可能很复杂；可能很清晰，也可能模糊。</li>
<li>比如，客户希望有一种快速进行数据计算的工具帮助其完成繁琐的计算工作。</li>
</ol>
</li>
<li><strong>产品需求</strong>描述的是开发团队所提供的解决方案。即针对上述的客户需求，开发团队设计出一个可以帮助客户解决工作当中碰到的问题的方案。</li>
<li><strong>产品组件需求</strong>描述的是组成产品的各个组件的需求规格。与产品需求相比，这是更低层次，更为细致的描述了上述解决方案中的某个组件的功能、性能与形式等。</li>
</ol>
<p><strong>为什么说“需求是一切工程活动的基础”</strong></p>
<ol>
<li>设计活动一定是依据需求而开展的</li>
<li>产品集成活动中，各个组件之间的接口必须满足事先确定的接口需求，否则会造成接口不匹配。<ol>
<li>验证（Verification）活动也是检验获得的产品和产品组件能不能满足各自事先定义好的需求规格。</li>
<li>确认（Validation）活动是为了确保产品可以满足客户的需求以及实际操作场景的要求。</li>
</ol>
</li>
<li>此外，需求也是项目计划活动的关键输入。比如，项目的规模估算、成本估算等必须参考需求来进行。</li>
</ol>
<p><strong>需求获取</strong></p>
<ol>
<li>需求是采用”诱导“式方法获取客户的显式需求和隐式需求，尽可能的识别客户的期望与所受到的限制。<ol>
<li>“诱导”不仅仅是普通的需求采集，隐含了更加积极地、前瞻性地识别那些客户没有明确提供的额外需求。</li>
<li>客户所受到的限制也应当作为需求开发过后需要关注的内容。限制包括技术、成本、时间、风险、行业规则、法律等等。</li>
</ol>
</li>
</ol>
<p><strong>需求汇总</strong></p>
<ol>
<li>整理各种来源的信息，识别缺失的信息。</li>
<li>解决冲突的需求<ol>
<li>需求的整理和转化：我们需要将客户的需求转换为产品需求和产品组件的需求</li>
<li>推导未显式描述的需求内容，例如采用某项技术的附属需求</li>
</ol>
</li>
</ol>
<p><strong>需求验证</strong></p>
<ol>
<li>对需求进行分析和确认，以确保符合使用者预期</li>
<li>典型活动包括<ol>
<li>建立和维护操作概念和相关的场景；场景一般而言是指使用产品时可能发生的时间顺序。</li>
<li>分析需求，以确保其必要性、充分性和平衡性。</li>
<li>确认需求，以确保将要产生的产品能在预期的用户环境中运行并且工作正常。</li>
</ol>
</li>
</ol>
<p><strong>需求文档制作</strong></p>
<ol>
<li>需求开发工作完成的一个基本标志是形成了一份完整的、规范的、经过评审的需求规格说明书。</li>
<li>需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。</li>
</ol>
<h2 id="团队设计"><a href="#团队设计" class="headerlink" title="团队设计"></a>团队设计</h2><p><strong>团队智慧</strong></p>
<blockquote>
<p>发挥团队智慧两大挑战</p>
</blockquote>
<ol>
<li>确定整体架构之前很难进行分工</li>
<li>鼓励团队成员在讨论和评审会议中的参与程度</li>
</ol>
<p><strong>设计标准</strong></p>
<ol>
<li>命名规范：项目小组应当设计一个统一的命名规范来命名各个模块并建立系统词典</li>
<li>接口标准：组件之间的接口标准和格式也需要作为设计标准的内容之一加以定义</li>
<li>系统出错信息：系统异常信息和出错信息往往也需要通过一个规范加以标准化</li>
<li>设计表示标准：设计表示标准定义了设计工作的产物应当满足的标准。</li>
</ol>
<p><strong>复用性支持</strong></p>
<ol>
<li>在设计阶段必须要充分考虑复用的可能。为了支持复用，软件项目团队需要建立一套复用管理流程，具体而言，包括<ol>
<li>复用接口标准</li>
<li>复用文档标准</li>
<li>复用质量保证机制</li>
</ol>
</li>
</ol>
<p><strong>可测试性考虑</strong></p>
<blockquote>
<p>设计可测试性考虑主要体现在两方面</p>
</blockquote>
<ol>
<li>要尽可能减少测试代码的数量</li>
<li>要制作合理的测试计划。</li>
</ol>
<p><strong>可用性考虑</strong></p>
<ol>
<li>可用性的问题应当在设计阶段就开始考虑，而不能推延到实现阶段。</li>
<li>针对每一个关键功能都定义操作概念和操作场景。</li>
<li>分析操作场景以确保软件系统开发完成之后，系统使用者会满意。</li>
<li>必要时，可以邀请最终用户参与场景的评审，使用模拟、原型等技术，更好的把握用户真实意图。</li>
</ol>
<h2 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h2><p><strong>评审的考虑</strong></p>
<ol>
<li>设计的时候采用的策略是自顶向下、逐层精化，这有利于建立系统的整体观，</li>
<li>实现的时候为了方便对实现结果评审，建议采用自底向上的方式进行，首先实现底层的内容，然后对这些底层的模块进行评审，有利于复用策略的应用。</li>
</ol>
<p><strong>复用策略</strong></p>
<ol>
<li>采用自底向上的开发策略有利于进行复用。</li>
<li>几个经典的复用策略<ol>
<li>编码注释的应用：编码注释采用统一格式，标明功能，调用方式。异常信息等有利于复用的信息。</li>
<li>站立式会议：在会上，团队成员可以讨论实现计划，识别可复用组件，了解现有的复用组件库中的内容</li>
</ol>
</li>
</ol>
<p><strong>可测试性考虑</strong></p>
<p>实现计划必须与测试计划一致，不能出现集体测试的时候部分模块未实现的情况。</p>
<h2 id="集成策略选择"><a href="#集成策略选择" class="headerlink" title="集成策略选择"></a>集成策略选择</h2><h3 id="大爆炸集成策略"><a href="#大爆炸集成策略" class="headerlink" title="大爆炸集成策略"></a>大爆炸集成策略</h3><ol>
<li>定义：将所有已经完成的组件放在一起进行一次集成</li>
<li>优点：需要很少的测试用例</li>
<li>缺点：<strong>需要所有有待集成的组件质量非常高</strong>，否则会出现难以定位缺陷位置的问题，从而消耗很多测试时间；另外，系统越复杂，规模越大，问题越突出</li>
</ol>
<h3 id="逐一添加集成策略"><a href="#逐一添加集成策略" class="headerlink" title="逐一添加集成策略"></a>逐一添加集成策略</h3><ol>
<li>与大爆炸集成策略相反，采取一次添加一个组件的方式进行集成</li>
<li>优点：很容易定位缺陷位置，特别是在产品组件质量不高的情况下，每次集成之前都有着坚实的质量基础</li>
<li>缺点：需要测试用例非常多；存在有大量的回归测试，测试时间成本大</li>
</ol>
<h3 id="集簇集成策略"><a href="#集簇集成策略" class="headerlink" title="集簇集成策略"></a>集簇集成策略</h3><ol>
<li>定义：是对逐一添加集成策略的改进，把有相似功能或者有关联的模块优先进行集成，形成可以工作的组件，然后以组件为单位继续较高层次的集成</li>
<li>优点：可以尽早获得一些可以工作的组件，有利于其它组件测试工作的开展</li>
<li>缺点：过于关注个别组件，而缺乏系统的整体观，不能尽早发现系统层面的缺陷</li>
</ol>
<h3 id="扁平化集成策略"><a href="#扁平化集成策略" class="headerlink" title="扁平化集成策略"></a>扁平化集成策略</h3><ol>
<li>定义：优先集成高层的部件，然后逐步将各个组件、模块的真正实现加入系统。即尽快构建一个可以工作的扁平化系统</li>
<li>优点：<strong>可以尽早发现系统层面的缺陷</strong></li>
<li>缺点：为了确保完成的系统，需要大量的打“桩”（stub），即提供一些直接提供返回值的伪实现。这种方式往往不能覆盖整个系统应该处理的多种状态</li>
</ol>
<h2 id="验证与确认-V-V"><a href="#验证与确认-V-V" class="headerlink" title="验证与确认 V&amp;V"></a>验证与确认 V&amp;V</h2><p><strong>什么是 V&amp;V?</strong></p>
<ol>
<li>验证（Verification)活动也是检验获得的产品和产品组件能不能满足各自事先定义好的需求规格；</li>
<li>确认（Validation)活动是为了确保产品可以满足客户的需求以及实际操作场景的要求。</li>
<li>验证（Verification)和确认（Validation)都是为了提升最终产品的质量而采取的措施。</li>
</ol>
<p><strong>V&amp;V 的区别与联系</strong></p>
<ol>
<li>验证和确认的目的不同：<ol>
<li>验证是目的是确保选定的工作产品与事先指定给该工作产品的需求（即产品需求或产品组件需求）一致。</li>
<li>确认的目的则是确保开发完成的产品或者产品组件在即将要使用该产品或者产品组件的环境中工作正确，关注的是客户需求的满足。</li>
</ol>
</li>
<li>验证和确认又是相互依存、关系紧密的两个活动<ol>
<li>验证活动的依据来源于确认的目标，即产品组件需求必须与客户需求一致。</li>
<li>验证活动为确认活动提供了前提条件，在完成产品需求和产品组件需求之前，考虑客户需求是否满足是没有意义的。</li>
</ol>
</li>
</ol>
<p><strong>V&amp;V 的活动</strong></p>
<ol>
<li>环境准备<ol>
<li>对于验证工作，如果是评审，则需要准备文件材料、人员以及会议场所等；如果是测试，需要准备模拟器、场景生成程序、环境控制以及其他系统接口等</li>
<li>对于确认工作，则需要模拟真实环境和场景</li>
</ol>
</li>
<li>对象选择<ol>
<li>对于验证工作，验证对象往往从工作产品中选择</li>
<li>对于确认工作，确认对象从产品中选择</li>
</ol>
</li>
<li>活动实施<ol>
<li>确认工作活动包括早期对产品需求评审工作和最后的验收测试</li>
<li>验证工作：一般的评审和测试工作</li>
</ol>
</li>
<li>结果分析<ol>
<li>对于评审结果，可以根据评审结果反思软件开发过程的合理性、以及是否还有隐藏的缺陷</li>
<li>对于验收测试的结果，则可以关注那些一直遗留到验收阶段才被发现的缺陷，看看这些缺陷在什么阶段被引入，为什么前面未能发现等</li>
</ol>
</li>
</ol>
<p><strong>V&amp;V 的例子</strong></p>
<ol>
<li>单元测试：验证</li>
<li>集成：验证</li>
<li>需求评审：确认</li>
<li>验收测试：确认</li>
</ol>
<h2 id="思考与讨论-2"><a href="#思考与讨论-2" class="headerlink" title="思考与讨论"></a>思考与讨论</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458430.png" alt="image-20240101204930652"></p>
<p>答案：ABC。</p>
<p>客户需求描述的是客户的期望，是客户解决<strong>问题</strong>的愿望，典型的客户需求通常<strong>不包含功能</strong>，客户所受到的限制也应当作为需求开发过程中需要重点关注的内容。</p>
<p>系统功能描述包含在产品需求中。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458446.png" alt="image-20240101205009226"></p>
<p>答案：ABCD</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458464.png" alt="image-20240101205051120"></p>
<p>答案：ABCD</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458482.png" alt="image-20240101205108988"></p>
<p>答案：BCD</p>
<p>扁平化：先搭建系统（插桩），然后把组件替换成真实代码.A应该是不可以用大爆炸</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458509.png" alt="image-20240101205246672"></p>
<p>答案：ABCD</p>
<p>D：如果有20、30个，不能大爆炸（多了）；如果只有2个，大爆炸和逐一添加是一回事</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458911.png" alt="image-20240101205335181"></p>
<p>答案：BC</p>
<p>A：可以尽早，但不充分</p>
<p>B：因为打桩可能遗漏掉很多场景，往往不能覆盖整个系统应该处理的多种状态</p>
<p>C:集簇集成策略改进了逐一添加，将有相似功能或者有关联的模块优先进行集成，形成可以工作的组件。<strong>因为它是自底向上</strong>，同时按照<strong>相似功能分类</strong>，有助于复用策略。</p>
<p>D：大爆炸和逐一添加优缺点正好相反，没说逐一添加和扁平化</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458925.png" alt="image-20240101210514789"></p>
<p>答案：BC</p>
<p>确认是一头一尾（用户需求），验证是当中的部分（产品需求）</p>
<ul>
<li>事实上，确认和验证贯穿开发始终（但上面的更好理解）</li>
</ul>
<p>看解决方案本身有没有正确实现（评审、测试）：验证</p>
<p>客户的问题有没有得到好的解决：确认</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458946.png" alt="image-20240101210747962"></p>
<p>答案：A</p>
<p>软件开发典型流程：需求-设计-开发-代码评审-单元测试-集成测试（大部分是功能测试）-系统测试-试运行&#x2F;验收</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458971.png" alt="image-20240101210927296"></p>
<p>答案：BCD</p>
<p>确认解决用户的问题，对应用户需求</p>
<p>A：如果是中间件，不是完整系统，可能要（但是等同于用户手册）</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458990.png" alt="image-20240101212106654"></p>
<p>答案：BC</p>
<p>A：客户需求是问题，产品需求是解决方案，软件功能性描述是解决方案，所以是产品需求</p>
<p>D：客户不能主导，否则得应付很多变化</p>
<h1 id="7-项目支持活动"><a href="#7-项目支持活动" class="headerlink" title="7.项目支持活动"></a>7.项目支持活动</h1><p>项目管理支持活动包含：配置管理、度量和分析、决策分析和根因分析。</p>
<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p><strong>配置管理的目的</strong></p>
<p>建立与维护工作产品的完整性</p>
<p><strong>配置管理的概念</strong></p>
<ol>
<li>配置项：<ol>
<li>在配置管理当中作为单独实体进行管理和控制的工作产品集合</li>
<li>典型的可能作为配置项<strong>纳入配置管理</strong>的工作产品包含过程说明文档、项目开发计划文档、需求规格说明书、设计规格说明书、设计图表、产品规格说明书、程序代码、开发环境，如特定版本的编译器等、产品数据文件、产品技术文件、用户支持文档</li>
</ol>
</li>
<li>基线：基线是一个或多个配置项及相关的标识符的代表，是一组经正式审查同意的规格或工作产品集合，是未来开发工作或交付的基础，而且只能经由严格的变更控制程序才能改变。<ol>
<li>发布一个基线包括该基线所有的配置项以及这些配置项的最新变更，因此，可以将基线作为接下来工作的基础。</li>
<li>典型的发布基线时间点为需求分析之后、设计完成之后、单元测试之后以及最终产品发布。</li>
<li>是配置项持续演进的稳定基础</li>
</ol>
</li>
</ol>
<p><strong>配置管理的流程</strong></p>
<blockquote>
<p>配置管理是用管理的手段监督和指导如下工作的流程[CMMI 2006]</p>
</blockquote>
<ol>
<li>识别和记录配置项的物理特性和功能特性</li>
<li>控制上述特性的变更；</li>
<li>记录和报告变更过程和相应的配置项状态</li>
<li>验证配置项是否与需求一致</li>
</ol>
<p><strong>配置管理活动</strong></p>
<ol>
<li>识别配置项</li>
<li>建立配置管理系统</li>
<li>创建和发布基线</li>
<li>跟踪变更请求</li>
<li>控制配置项变更</li>
<li>建立配置管理记录</li>
<li>配置审计</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/27.png" alt="img"></p>
<blockquote>
<p>配置管理各个活动之间的关系</p>
</blockquote>
<h2 id="度量和分析"><a href="#度量和分析" class="headerlink" title="度量和分析"></a>度量和分析</h2><p><strong>度量和分析简介</strong></p>
<ol>
<li>意义：在软件项目管理决策的过程中，基于客观的数据很重要，这种客观决策可以显著消除错误决策的风险。而这些客观数据的获得，必须依照一定的流程以正确的方式获得和使用。度量和分析活动就定义了上述客观数据的获取与使用方式。</li>
<li>目的：建立与维持度量能力，以支持管理的信息需要。</li>
</ol>
<p><strong>度量和分析活动</strong></p>
<ol>
<li>建立度量目标</li>
<li>指定度量方式</li>
<li>指定数据收集和保存的流程</li>
<li>指定分析流程</li>
<li>收集度量数据</li>
<li>分析度量数据</li>
<li>保存数据和结果</li>
<li>交流度量结果</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/28.png" alt="img"></p>
<blockquote>
<p>活动组成就是 8 个圆圈内的内容</p>
</blockquote>
<h3 id="GQM-方法的原理和应用"><a href="#GQM-方法的原理和应用" class="headerlink" title="GQM 方法的原理和应用"></a>GQM 方法的原理和应用</h3><ol>
<li>GQM(Goal Question Metric)是一种应用非常广泛的<strong>建立软件度量体系的方法</strong>，从管理的目标出发，将目标归纳、分解为度量的指标，并把这些指标提炼成可以测量的值，是一种科学的、系统的思考问题的方式。<ol>
<li>概念层（目标）：目标是为某个特定的对象而定义的。这里的对象是指软件产品、软件过程以及相关的资源等。定义的目标基于不同原因和不同质量模型,也要参考不同的角色视图与特定的环境。</li>
<li>操作层（问题）：基于一定的刻画上述目标是否达成或者目标达成的进展情况的模型，使用一系列的问题来定义所研究的对象, 然后得出评价或评估特定目标达成进展情况。所选择的问题应当尽量体现质量相关的话题。</li>
<li>量化层（度量）：试图以量化的方式回答上述操作层识别出来的问题。</li>
</ol>
</li>
<li>示例：<ol>
<li>例子一：PM<ol>
<li>G：确保稳定性、可预测性的开发过程来满足计划的里程碑</li>
<li>Q：我的项目是否按照计划的轨迹前进，计划的里程碑都能实现嘛？</li>
<li>M：软件项目开发工作的挥发性（分支、流、统计变更管理 UCM 活动）</li>
</ol>
</li>
<li>例子二：QM<ol>
<li>G：最大化所有团队贡献者的生产力</li>
<li>Q：开发人员能够完成分配给他们的任务吗，或者他们遇到障碍了吗？</li>
<li>M：由个体或者工作组产生的项目工作的量级</li>
</ol>
</li>
<li>详见课本 153-155 页</li>
</ol>
</li>
</ol>
<h2 id="决策分析"><a href="#决策分析" class="headerlink" title="决策分析"></a>决策分析</h2><p><img src="https://eaglebear2002.github.io/8725/29.png" alt="img"></p>
<h2 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h2><ol>
<li><strong>避免类似错误反复发生</strong></li>
<li>一个正式根因分析过程往往包含下列的活动：<ol>
<li>识别和选定问题</li>
<li>根因分析</li>
<li>建立改进的行动方案</li>
<li>实施改进，评估效果</li>
</ol>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/31.png" alt="img"></p>
<h2 id="思考与讨论-3"><a href="#思考与讨论-3" class="headerlink" title="思考与讨论"></a>思考与讨论</h2><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458012.png" alt="image-20240101212814646"></p>
<p>答案：ABCD</p>
<p>配置审计要建立完整性</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458357.png" alt="image-20240101212900615"></p>
<p>答案：ABCD</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458375.png" alt="image-20240101212939623"></p>
<p>答案：BD</p>
<p>A对 B：评价标准最关键，而不是评价方法 C对 D：招标才是</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041458396.png" alt="image-20240101213044230"></p>
<p>答案：AD</p>
<p>A：不是所有时候都有丰富的数据，有时没有</p>
<p>D：有时候没有明确解决方案，也可以结束</p>
<h1 id="8-定量管理与仿真建模"><a href="#8-定量管理与仿真建模" class="headerlink" title="8.定量管理与仿真建模"></a>8.定量管理与仿真建模</h1><h2 id="高成熟度项目管理"><a href="#高成熟度项目管理" class="headerlink" title="高成熟度项目管理"></a>高成熟度项目管理</h2><blockquote>
<p>CMMI 模型</p>
</blockquote>
<p><img src="https://eaglebear2002.github.io/8725/35.png" alt="img"></p>
<p><strong>一般的项目管理</strong></p>
<ol>
<li>主要关心<ol>
<li>当前状况（注意：也可能使用数据）</li>
<li>是否需要调整干预</li>
</ol>
</li>
<li>但是，回答不了必须进行预测的问题，例如<ol>
<li>维持现状，项目最后是否能成功？</li>
<li>如果某些方面进行调整，会有什么不同的结果？</li>
</ol>
</li>
</ol>
<p><strong>定量的项目管理</strong></p>
<ol>
<li>基于数据，主要关心<ol>
<li>你对当前状态理解是否有足够信心？</li>
<li>对偏差的理解</li>
</ol>
</li>
<li>回答如下典型问题<ol>
<li>项目最后是否能成功？多大把握？是否需要预防？</li>
<li>如果某些方面进行调整，会有什么不同的结果？</li>
</ol>
</li>
</ol>
<p><strong>为什么需要理解偏差</strong></p>
<ol>
<li>有的时候，我们会面临这样的问题</li>
<li>客户希望 10 周以内交付，但是，历史数据表明，类似任务是 9~11 周完成，那这个任务该接受么？</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/36.png" alt="img"></p>
<h2 id="定量管理"><a href="#定量管理" class="headerlink" title="定量管理"></a>定量管理</h2><ol>
<li>构建定量模型<ol>
<li>子过程能力基线</li>
<li>过程模型</li>
</ol>
</li>
<li>应用模型：监控影响子过程的关键因素</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>（子）过程性能：遵循某个特定（子）过程的之后产生结果的量化描述，既包括（子）过程度量 Xi（例如，时间、缺陷消除效率、工时等），也包括产物度量 Yi（例如，缺陷密度，相应时间等）。</li>
<li>（子）过程性能基线：上述过程性能的一个定量化的刻画，一般包括均值和范围。通常用作过程性能的 benchmark。</li>
<li>过程或子过程性能模型：依据子过程的逻辑关系构建相应的数学模型，描述子过程性能基线和整体过程有意义的性能输出（例如，质量、生产效率、成本等）之间关系。例如过程 Yield 和 Phase Yield。</li>
</ol>
<h3 id="定量模型构建的关键实践"><a href="#定量模型构建的关键实践" class="headerlink" title="定量模型构建的关键实践"></a>定量模型构建的关键实践</h3><ol>
<li>基于 Yield 来构建一个基本的缺陷预测模型，假设<ol>
<li>上述阶段分别为需求开发、需求评审、设计、设计评审、编码、测试；</li>
<li>需要基于该模型也测最终产出物中有多少个缺陷？</li>
</ol>
</li>
<li>讨论<ol>
<li>需要补充哪些数据？请设计一个可行的数据获取要求；</li>
<li>上述数据显然不可能是一个恒定不变的数据，该如何处理？</li>
</ol>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/37.png" alt="img"></p>
<h3 id="定量模型应用（定量管理）的关键实践"><a href="#定量模型应用（定量管理）的关键实践" class="headerlink" title="定量模型应用（定量管理）的关键实践"></a>定量模型应用（定量管理）的关键实践</h3><p><img src="https://eaglebear2002.github.io/8725/33.png" alt="img"></p>
<h2 id="常用定量管理技术"><a href="#常用定量管理技术" class="headerlink" title="常用定量管理技术"></a>常用定量管理技术</h2><ol>
<li>定量管理技术通常被分为非统计技术和统计技术，这些技术的使用能够帮助解决软件项目管理中多种问题。</li>
</ol>
<h3 id="常用非统计技术"><a href="#常用非统计技术" class="headerlink" title="常用非统计技术"></a>常用非统计技术</h3><ol>
<li>非统计技术一般是为了描述数据集整体特征或者关联关系，从而帮助选择适用的统计技术以应用于给定的数据集，以及调查通过数据分析检测到异常的原因。例如，检查表（或列联表），帕累托图，直方图，因果图，散点图等。</li>
</ol>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><ol>
<li>直方图以频率统计的方式进行显示，可以描述过程属性的频率，例如缺陷修复的时间、每次测试发现的缺陷的个数、每天无故障工作的时间、计算产品的不合格率等。</li>
<li>一般用于有助于判断过程是否正常，过程能力是否满足需要，不良产品是否发生，分析产品质量问题的原因等。</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/38.png" alt="img"><img src="https://eaglebear2002.github.io/8725/39.png" alt="img"></p>
<h4 id="帕累托图"><a href="#帕累托图" class="headerlink" title="帕累托图"></a>帕累托图</h4><ol>
<li>一种特殊的直方图</li>
<li>按照由高到低排列的直方图</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/40.png" alt="img"></p>
<h4 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h4><ol>
<li>因果图是用来分析影响产品质量的各种原因的一种有效的定性的分析图，它将对特性或结果有影响的要素加以分类分析，是一种发现问题根本原因的方法，可以让项目组成员通过头脑风暴、集思广益的方法从各个方面各种不同的角度找出这些问题的所有原因。</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/41.png" alt="img"></p>
<h4 id="散布（点）图"><a href="#散布（点）图" class="headerlink" title="散布（点）图"></a>散布（点）图</h4><ol>
<li>整理和观察收集到的数据的常用图形工具</li>
<li>散布图表示的是一个变量相对于另一个变量的表现情况，可以假定一个变量是因变量，另一个变量是自变量。散布图通常表现了 5 种相关关系。如图所示的散布图中分别表现了两个变量之间的弱正相关、弱负相关、不相关、强正相关、强负相关。</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/42-1694577047595-18.png" alt="img"></p>
<h3 id="常用统计技术"><a href="#常用统计技术" class="headerlink" title="常用统计技术"></a>常用统计技术</h3><ol>
<li>统计思维认识到许多决策是在不确定条件下做出的。统计方法有助于量化这种不确定性并指导采取行动以减少不确定性。</li>
<li>统计分析支持许多类型的决策，在支持过程管理决策的统计分析中，有效的过程管理通常需要两级决策<ol>
<li>实时控制单个活动或子流程</li>
<li>根据当前和已完成的活动对未来和最终过程的结果进行预测</li>
</ol>
</li>
<li>常用的统计技术包括：统计过程控制图，回归分析，方差分析，预测区间，假设检验，敏感性分析等</li>
</ol>
<p><strong>控制图</strong></p>
<ol>
<li>控制图是根据概率统计原理构造的一种图，用来监测生产过程是否处于控制状态。</li>
<li>控制图是对过程质量数据测定、记录从而进行质量管理的一种用科学方法设计的图。</li>
<li>图上有中心线（CL)、上控制限（UCL)和下控制限（LCL)，并有按时间顺序抽取的样本统计量数值的描点序列。</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/43.png" alt="img"></p>
<ol>
<li>控制图可由正态分布演变而来</li>
<li>正态分布可用两个参数即均值 μ 和标准差 σ 来决定。正态分布有一个结论对质量管理很有用，即无论均值 μ 和标准差 σ 取何值，产品质量特性值落在 μ±3σ 之间的概率为 99.73%，落在 μ±3σ 之外的概率为 100%-99.73%&#x3D;0.27%，而超过一侧，即大于 μ+3σ 或小于 μ-3σ 的概率为 0.27%&#x2F;2&#x3D;0.135%≈1‰。</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/44.png" alt="img"></p>
<ol>
<li>两类错误（需要检验）：<ol>
<li>Ⅰ 类错误：虚发警报错误，在生产正常的情况下,纯粹出于偶然而点子出界的概率虽然很小,但不是绝对不可能发生。故当生产正常而根据点出界判断生产异常就犯了虚发警报错误,发生这种错误的概率通常记以 α</li>
<li>Ⅱ 类错误：漏发警报错误,在生产异常的情况下,产品质量的分布偏离典型分布,但总有一部分产品的质量特性值在上下控制界之内。如果抽到这样的产品进行检测描点,根据点未出界判断生产正常就为漏发警报错误,此概率通常记以 β。</li>
</ol>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/47.png" alt="img"></p>
<h1 id="补充：软件开发实践"><a href="#补充：软件开发实践" class="headerlink" title="补充：软件开发实践"></a>补充：软件开发实践</h1><h3 id="敏捷软件开发"><a href="#敏捷软件开发" class="headerlink" title="敏捷软件开发"></a>敏捷软件开发</h3><ol>
<li>敏捷中也有计划驱动</li>
</ol>
<h4 id="敏捷目的"><a href="#敏捷目的" class="headerlink" title="敏捷目的"></a>敏捷目的</h4><p>为了使软件开发团队具有高效工作和快速响应变化的能力</p>
<h4 id="敏捷原则"><a href="#敏捷原则" class="headerlink" title="敏捷原则"></a>敏捷原则</h4><ol>
<li>最重要的是通过尽早和不断交付有价值的软件满足客户需要</li>
<li>欢迎需求的变化</li>
<li>经常交付可以工作的软件，从几星期到几个月，时间尺度越短越好</li>
<li>业务人员和开发者应该在整个项目过程中始终朝夕在一起工作</li>
<li>最好的信息传达方式是面对面的交谈</li>
</ol>
<h4 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h4><h5 id="敏捷宣言内容"><a href="#敏捷宣言内容" class="headerlink" title="敏捷宣言内容"></a>敏捷宣言内容</h5><ol>
<li>敏捷软件开发宣言的 4 个简单的价值观:<ol>
<li>(1’)个体和交互 胜过 过程和工具</li>
<li>(1’)可以工作的软件 胜过 面面俱到的文档</li>
<li>(1’)客户合作 胜过 合同谈判</li>
<li>(1’)响应变化 胜过 遵循计划</li>
</ol>
</li>
<li>(1’)也就是说，尽管右项有其价值，我们更重视左项的价值</li>
</ol>
<h4 id="敏捷软件开发方法"><a href="#敏捷软件开发方法" class="headerlink" title="敏捷软件开发方法"></a>敏捷软件开发方法</h4><h5 id="极限编程-XP"><a href="#极限编程-XP" class="headerlink" title="极限编程 XP"></a>极限编程 XP</h5><ol>
<li>eXtreme Programming，极限的含义是指把好的开发实践运用到极致</li>
<li>极限编程的有效实践<ol>
<li>客户作为开发团队的成员 —— 客户代表</li>
<li>使用用户素材</li>
<li>短交付周期</li>
<li>验收测试</li>
<li>结对编程——结对编程就是由两名开发人员在同一台计算机上共同编写解决同一个问题的程序代码，通常一个人编码，另一个人对代码进行审查与测试，以保证代码的正确性与可读性。结对编程是加强开发人员相互沟通与评审的一种方式。</li>
<li>测试驱动开发——极限编程强调“测试先行”。在编码之前，应该首先设计好测试方案，然后再编程，直至所有测试都获得通过之后才可以结束工作。</li>
<li>集体所有</li>
<li>持续集成</li>
<li>可持续的开发速度 &lt;&#x3D;40h&#x2F;week</li>
<li>开放的工作空间</li>
<li>重构</li>
<li>使用隐喻</li>
</ol>
</li>
</ol>
<h5 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h5><ol>
<li>迭代式增量软件开发过程：</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/15.png" alt="img"></p>
<ol>
<li>Scrum 中的文档<ol>
<li>产品订单（product backlog)：整个项目的概要文档，包含了已划分优先等级的、项目要开发的系统或产品的需求清单，是动态的。</li>
<li>冲刺订单（sprint backlog)：细化了的文档，包含了团队如何实现下一个冲刺的需求信息。<ol>
<li>哪些产品订单会加入一次冲刺由冲刺计划会议决定。会议中，产品负责人告诉开发团队他们需要完成产品订单中的哪些订单项，开发团队决定在下一次冲刺中承诺完成多少订单项。</li>
<li>在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog)，这意味着在一个冲刺中需求是被冻结的。</li>
</ol>
</li>
<li>燃尽图（burn down chart)</li>
</ol>
</li>
<li>Scrum 常见活动<ol>
<li>Sprint Planning Meeting</li>
<li>Daily standup meeting</li>
<li>review meeting</li>
<li>retrospective meeting</li>
<li>sprint</li>
</ol>
</li>
<li>Empirical Process Control VS. Statistical Process Control，不同于统计过程控制方法（也叫预测式、计划式）不能解决不可预见的需求变化问题，Scrum 采用的实证过程控制承认问题无法完全理解或定义，即用户可以在项目过程中变更需求，关注于如何使开发团队快速推出和响应需求变化的能力最大化</li>
<li>Scrum VS. XP<ol>
<li>迭代周期不同。XP 迭代周期为 1<del>2 周，而 Scrum 迭代周期为 2</del>4 周</li>
<li>迭代中是否允许需求变更。XP 中只要变更需求与原需求所需时间资源相等即可变更，而 Scrum 在迭代中需求被冻结</li>
<li>迭代中，需求是否严格按照优先级来实现。XP 中务必遵守优先级别，Scrum 中则比较灵活，原因是可能有需求依赖问题</li>
<li>过程工程化。Scrum 开发过程并未工程化，要求开发者自觉保证，但 XP 则对开发流程定义严格，例如 TDD，结对编程，重构等</li>
</ol>
</li>
</ol>
<h5 id="Kanban-方法"><a href="#Kanban-方法" class="headerlink" title="Kanban 方法"></a>Kanban 方法</h5><ol>
<li>精益生产（丰田制造法）的具体实现</li>
<li>可视化工作流、限定 WIP、管理周期时间</li>
<li>马丁提出了微服务架构</li>
</ol>
<h2 id="补充：PSP-个体软件过程"><a href="#补充：PSP-个体软件过程" class="headerlink" title="补充：PSP 个体软件过程"></a>补充：PSP 个体软件过程</h2><p><img src="https://eaglebear2002.github.io/8725/11.png" alt="img"></p>
<h3 id="PSP-是什么？"><a href="#PSP-是什么？" class="headerlink" title="PSP 是什么？"></a>PSP 是什么？</h3><ol>
<li>PSP 是包括了数据记录表格、过程操作指南和规程在内的结构化框架。</li>
<li>PSP 着重于软件开发人员的个人能力提升，体现在估算能力、计划能力、计划执行以及质量管理等方面</li>
<li>基本的 PSP 包括策划、设计、编码、编译、单元测试以及总结等阶段。<ol>
<li>每个阶段都有相应的过程操作指南，用来指导该阶段的开发活动。</li>
<li>每个阶段，都有相应的过程操作指南，用来指导该阶段的开发活动。</li>
<li>所有的开发活动都需要记录相应的时间日志和缺陷日志。</li>
</ol>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/17.png" alt="img"></p>
<h3 id="PSP-基本原理（为什么要有-PSP）"><a href="#PSP-基本原理（为什么要有-PSP）" class="headerlink" title="PSP 基本原理（为什么要有 PSP）"></a>PSP 基本原理（为什么要有 PSP）</h3><ol>
<li>软件系统的整体质量由该系统中质量最差的某些组件所决定</li>
<li>软件组件的质量取决于开发工程师所使用的开发过程。</li>
<li>软件工程师应当自己度量、跟踪自己的工作流程，并建立持续的自我改进机制（在自己开发过程的偏差中学习、总结，并将这些经验教训整合到自己的开发实践），自己管理软件组件的质量。</li>
</ol>
<blockquote>
<p>上述基本原理除了继续肯定“过程质量决定最终产品质量“这一软件过程改进的之外，更加突出了个体软件工程师在管理和改进自身过程中的能动性。这就形成了 PSP 的理论基础。</p>
</blockquote>
<h3 id="PSP-的成熟度级别"><a href="#PSP-的成熟度级别" class="headerlink" title="PSP 的成熟度级别"></a>PSP 的成熟度级别</h3><p><img src="https://eaglebear2002.github.io/8725/18.png" alt="img"></p>
<h3 id="PSP-的度量"><a href="#PSP-的度量" class="headerlink" title="PSP 的度量"></a>PSP 的度量</h3><h4 id="基本度量项"><a href="#基本度量项" class="headerlink" title="基本度量项"></a>基本度量项</h4><ol>
<li>度量时间：序号、所属阶段、开始时间、结束时间、中断时间、净时间、中断原因</li>
<li>度量缺陷：序号、发现日期、注入阶段、消除阶段、消除时间、关联缺陷、缺陷产生原因</li>
<li>度量规模：使用 PROBE 方法<ol>
<li>选择的规模度量方式必须反映开发成本</li>
<li>度量规模必须被精确定义</li>
<li>度量规模必须有自动化方法统计</li>
<li>有助于早期规划</li>
</ol>
</li>
<li>日程（TSP）</li>
</ol>
<h4 id="度量的作用"><a href="#度量的作用" class="headerlink" title="度量的作用"></a>度量的作用</h4><ol>
<li>度量体现着决策者对试图要实现的目标的关切程度。</li>
<li>度量帮助过程的实践者了解过程状态，理解过程偏差。</li>
</ol>
<h4 id="规模度量标准"><a href="#规模度量标准" class="headerlink" title="规模度量标准"></a>规模度量标准</h4><ol>
<li>选择的度量方式必须反映开发成本。</li>
<li>选择的度量方式必须精确。</li>
<li>选择的度量方式必须能用自动化方法来统计。</li>
<li>选择的度量方式必须有助于早期规划。</li>
</ol>
<h4 id="规模的度量的困境"><a href="#规模的度量的困境" class="headerlink" title="规模的度量的困境"></a>规模的度量的困境</h4><ol>
<li>精确的度量方式往往不便于早期规划。</li>
<li>有助于早期规划的度量往往难以生成精确度量结果。</li>
</ol>
<h5 id="注意点-1：整理历史数据"><a href="#注意点-1：整理历史数据" class="headerlink" title="注意点 1：整理历史数据"></a>注意点 1：整理历史数据</h5><blockquote>
<p>以估算规模为例，可以假定代理规模与实际程序规模之间存在简单关系映射、正态分布、对数正态分布，也可以假定不知道两者之间的关系，按照线性回归方法进行计算。</p>
</blockquote>
<ol>
<li><p>简单方法</p>
<ol>
<li>内容：最小值作为 VS、最大值作为 VL、中值作为 M,VS 与 M 均值作为 S、VL 与 M 均值作为 L</li>
<li>优点：计算简单</li>
<li>缺点：不稳定</li>
</ol>
</li>
<li><p>正态分布法</p>
<ol>
<li>内容：均值作为 M，计算标准差 σ，则 S&#x3D;M-σ，VS&#x3D;M-2σ，L&#x3D;M+σ，VL&#x3D;M+2σ</li>
<li>优点：相对稳定，在历史数据基本符合正态分布的情况下，可以给出非常好的相对大小矩阵</li>
</ol>
</li>
<li><p>对数正态分布法:</p>
<ol>
<li>内容：<ol>
<li>以 e 为底计算所有数据的自然对数</li>
<li>取对数之后的值的均值作为 M，计算相应标准差 σ;S&#x3D;M-σ，VS&#x3D;M-2σ，L&#x3D;M+σ，VL&#x3D;M+2σ</li>
<li>取反对数</li>
</ol>
</li>
<li>优点：更加符合人们对于程序的规模的直观感觉，因为大多数人习惯写很多规模很小的程序，少量规模较大的程序</li>
</ol>
</li>
<li><p>线性回归方法</p>
<ol>
<li>计算的时候计算了两组线性回归的参数，也就是项目所需的资源并不是直接由程序规模和历史数据中的生产效率相除得到。程序的复杂度和程序规之间并不是简单的正相关关系。</li>
<li>线性回归方法估算的是一定概率条件下估算值的分布。例如最终实际程序规模有 90%的可能性落在（a,b)区间内</li>
<li>Range 为在一定概率条件下的变化区间，而 p 为概率</li>
<li>Variance 为扰动程度：有时候，历史数据中的一些极端数据会造成相关性的“假象”，故需要先进行数据除噪。</li>
</ol>
</li>
<li><p>Plan Size 和估算的类数量不呈现 45 度，是受到了估算误差和方法外代码的数量共同影响</p>
</li>
<li><p>该方法没有使用生产效率进行计算，为什么在 PROBE 中不使用生产效率？这样子使用好不好？因为 Plan Size 是在一个范围内波动，生产效率也在一个范围内波动，如果将生产效率作为分母，那么可能会导致更大的误差，也就违背了误差的出发点。</p>
</li>
<li><p>估算能力的强弱关注是多稳定，而不是多接近具体的实际情况</p>
</li>
</ol>
<h5 id="注意点-2：处理有限的历史数据"><a href="#注意点-2：处理有限的历史数据" class="headerlink" title="注意点 2：处理有限的历史数据"></a>注意点 2：处理有限的历史数据</h5><ol>
<li>规模估算<ol>
<li>往往可以依据历史数据来完成，使用代理规模与实际程序规模之间的关系。</li>
<li>其原因在于规模估算结果的偏差产生原因相对客观，偏差可以用以修正新的估算结果。</li>
<li>估算规模对历史数据的要求如下</li>
</ol>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/12.png" alt="img"></p>
<blockquote>
<p>其中 r 为相关性（两组数据之间相互关联的程度，PSP 中要求 r&gt;&#x3D; 0.7)，其中 S 为显著性（两组数据的相关关系出现的偶然性，PSP 要求 s&lt;&#x3D;0.05)</p>
</blockquote>
<ol>
<li>时间估算<ol>
<li>使用代理规模和实际开发时间的关系。</li>
<li>时间估算的偏差产生原因更加复杂：一方面和规模有关，另一方面和人的主观能动性有关。</li>
<li>历史数据中的时间偏差可参考价值不大。</li>
</ol>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/19.png" alt="img"></p>
<blockquote>
<p>其中 r 为相关性（两组数据之间相互关联的程度，PSP 中要求 r&gt;&#x3D; 0.7)，其中 S 为显著性（两组数据的相关关系出现的偶然性，PSP 要求 s&lt;&#x3D;0.05)</p>
</blockquote>
<h5 id="注意点-3：处理极端数据"><a href="#注意点-3：处理极端数据" class="headerlink" title="注意点 3：处理极端数据"></a>注意点 3：处理极端数据</h5><ol>
<li>极端数据可能造成相关性假象。</li>
</ol>
<p><img src="https://eaglebear2002.github.io/8725/16.png" alt="img"></p>
<h1 id="往年真题"><a href="#往年真题" class="headerlink" title="往年真题"></a>往年真题</h1><p>这篇文档按照ppt结构整理往年题中的选择题和大题，不含课堂练习（移步ppt整理.md）</p>
<p>同时，因为ppt整理内容冗杂，这里总结必背的知识点。</p>
<h1 id="2023回忆"><a href="#2023回忆" class="headerlink" title="2023回忆"></a>2023回忆</h1><p>选择：</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501357.png" alt="image-20240104163127294"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501335.png" alt="image-20240104163205348"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501343.png" alt="image-20240104163251725"></p>
<p>这个题把确认改成验证了</p>
<p>还有个新选择题：下面的内容+EVM仅仅能用在大型项目。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501328.png" alt="image-20240104163601174"></p>
<p>我忘了EVM不能用在质量管理了orz</p>
<p>大题：</p>
<p>1.生命周期模型+软件过程；瀑布模型</p>
<p>2.质量管理的理解，如何做到质量管理</p>
<p>3.质量路径</p>
<p>4.敏捷宣言</p>
<p>5.自主团队的特征和为什么要用自助团队</p>
<p>6.项目估算的理解和如何开展估算</p>
<p>7.定量管理的基本范式</p>
<p>8.CMMI对软件研发实践的启发，参考价值</p>
<h1 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>XX管理：目标、状态、纠偏</p>
<p>软件开发典型流程：<strong>需求-设计-开发-代码评审-单元测试-集成测试（大部分是功能测试）-系统测试-试运行&#x2F;验收</strong></p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p><strong>‏关于软件过程管理，以下哪一种说法是比较贴切的：</strong></p>
<p>‏A.软件过程管理关注的是企业软件<strong>过程能力</strong>的稳定输出和提升。</p>
<p>B.软件过程管理主要关注软件成本和质量目标的达成。</p>
<p>C.进入互联网时代，软件过程管理是过于老套的话题。</p>
<p>D.软件过程管理是软件企业发展到较高层次才需要关心的话题。</p>
<p>正确答案：A</p>
<p>‎<strong>软件危机和软件工程这两个概念提出时间是？</strong></p>
<p>A.上世纪八十年代</p>
<p>B.上世纪六十年代</p>
<p>C.上世纪七十年代</p>
<p>D.上世纪五十年代</p>
<p>正确答案：B</p>
<p><strong>软件开发的本质难题中哪一个与软件发展阶段没有直接关系？</strong></p>
<p>A.可变性</p>
<p>B.不可见性</p>
<p>C.一致性</p>
<p>D.复杂性</p>
<p>正确答案：B</p>
<p><strong>关于Brooks提及的软件开发本质难题，下列说法中不准确的是。AB</strong></p>
<p>A.本质难题总共有四个，分别为复杂、不可见、可变和质量挑战</p>
<p>B.既然是本质难题，那就说明是根植于软件开发本身，因而是不可能在软件开发当中得到缓解</p>
<p>C.严格来说，只有不可见才是真正的“本质”难题，其他三个因项目而异</p>
<p>D.四大本质难题贯穿软件发展的不同历史段，但是在不同历史阶段，相互凸显程度不一样</p>
<p>质量挑战不是本质难题；本质难题可以缓解，不可消除</p>
<p><strong>下列哪些项不属于管理活动应该包含的要素？ABD</strong></p>
<p>A.成本：成本、质量、工期是软件项目管理的三大目标，不是三大要素</p>
<p>B.质量</p>
<p>C.目标：管理活动包括目标、状态、纠偏</p>
<p>D.工期</p>
<p><strong>下列名词和术语中不属于软件过程的有哪些？BD</strong></p>
<p>A.SCRUM</p>
<p>B.CMM&#x2F;CMMI：是过程改进模型，而非软件过程或软件过程模型</p>
<p>C.GATE方法</p>
<p>D.IDEAL：是过程改进模型</p>
<p><strong>【2015B】CMM的创始⼈是哪位_____? C</strong></p>
<p>Boehm</p>
<p>Juran</p>
<p>Humphrey</p>
<p>Crosby</p>
<h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><h3 id="【2018Fall】【2020-mid】生命周期模型与软件过程的区别和联系"><a href="#【2018Fall】【2020-mid】生命周期模型与软件过程的区别和联系" class="headerlink" title="【2018Fall】【2020-mid】生命周期模型与软件过程的区别和联系"></a>【2018Fall】【2020-mid】生命周期模型与软件过程的区别和联系</h3><ol>
<li>(3’)生命周期模型是对一个软件开发过程的<strong>人为划分</strong>，以突出验证和上游开发阶段之间的对应关系。</li>
<li>(3’)生命周期模型是软件开发过程的框架，是对软件开发过程的一种粗粒度划分，侧重于主要阶段而不是内部细节。</li>
<li>(2’)生命周期模型往往不包括技术实践。</li>
</ol>
<h3 id="【2018Fall】软件项目管理和软件过程管理"><a href="#【2018Fall】软件项目管理和软件过程管理" class="headerlink" title="【2018Fall】软件项目管理和软件过程管理"></a>【2018Fall】软件项目管理和软件过程管理</h3><p>软件项目管理是<strong>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程</strong>。</p>
<ol>
<li>管理对象上：前者是各类软件项目，后者是软件过程</li>
<li>实现目标上：前者的三大典型目标是<strong>成本、质量和工期</strong>，为了降低&#x2F;减少各种无谓的损耗来实现本该有的性能；后者是为了让软件过程在开发效率、质量等方面有着更好性能绩效</li>
<li>参考模型上：前者参考生命周期模型，后者是CMM&#x2F;CMMI，SPICE等</li>
</ol>
<h3 id="【2022Fall】随着-ChatGPT-的横空出世，以大模型为代表的-AI-技术势必对各行各业带来前所未有的影响。具体到软件工程，人工智能技术的应用也日渐常见，请结合这一背景畅想下本课程涉及的若干话题可能在这一波-AI-浪潮中的挑战和机遇。至少应该包括如下话题：项目管理、质量管理、过程改进。"><a href="#【2022Fall】随着-ChatGPT-的横空出世，以大模型为代表的-AI-技术势必对各行各业带来前所未有的影响。具体到软件工程，人工智能技术的应用也日渐常见，请结合这一背景畅想下本课程涉及的若干话题可能在这一波-AI-浪潮中的挑战和机遇。至少应该包括如下话题：项目管理、质量管理、过程改进。" class="headerlink" title="【2022Fall】随着 ChatGPT 的横空出世，以大模型为代表的 AI 技术势必对各行各业带来前所未有的影响。具体到软件工程，人工智能技术的应用也日渐常见，请结合这一背景畅想下本课程涉及的若干话题可能在这一波 AI 浪潮中的挑战和机遇。至少应该包括如下话题：项目管理、质量管理、过程改进。"></a>【2022Fall】随着 ChatGPT 的横空出世，以大模型为代表的 AI 技术势必对各行各业带来前所未有的影响。具体到软件工程，人工智能技术的应用也日渐常见，请结合这一背景畅想下本课程涉及的若干话题可能在这一波 AI 浪潮中的挑战和机遇。至少应该包括如下话题：项目管理、质量管理、过程改进。</h3><blockquote>
<p>软件项目管理是针对于特定的一个项目组，<strong>项目目标</strong>的一个实现。如一个软件项目小组或者说某一个特定软件项目的成本质量、工期、要实现的这些目标。项目管理关注的是目标的一个实现。 </p>
<p>软件项目管理是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p>
<ol>
<li>软件项目管理包括估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理等等。</li>
<li>软件项目管理的对象是各类软件项目</li>
</ol>
<p>PSP 中面向用户的质量观，定义质量为<strong>满足用户需求的程度</strong>。</p>
<p>质量策略</p>
<ol>
<li><strong>使用缺陷管理来代替质量管理</strong></li>
<li>高质量的产品也就意味着组成软件产品的各个组件基本无缺陷</li>
<li>各个组件的高质量是通过高质量评审来实现的；</li>
</ol>
<p>PSP 质量控制的衍生指标</p>
<p>过程改进：CMMI模型</p>
</blockquote>
<p><strong>1. 项目管理：</strong></p>
<p><strong>挑战：</strong></p>
<ul>
<li><strong>复杂性增加：</strong> 大规模AI项目可能涉及复杂的模型训练、部署和维护，增加了项目管理的难度。</li>
<li><strong>不确定性：</strong> AI项目中存在许多不确定性因素，如模型性能、数据质量等，需要灵活的项目管理方法。</li>
</ul>
<p><strong>机遇：</strong></p>
<ul>
<li><strong>自动化项目管理：</strong> 利用AI技术自动化项目管理任务，例如资源分配、进度跟踪，提高管理效率。</li>
<li><strong>数据驱动决策：</strong> 利用大数据和分析技术，基于实时数据做出更准确的决策，提高项目成功的概率。</li>
</ul>
<p><strong>2. 质量管理：</strong></p>
<p><strong>挑战：</strong></p>
<ul>
<li><strong>模型不透明性：</strong> 对于使用深度学习等复杂模型的项目，模型的不透明性可能导致质量评估的困难。</li>
<li><strong>数据质量：</strong> AI系统对高质量数据的依赖性，使得数据质量成为质量管理的关键挑战。</li>
</ul>
<p><strong>机遇：</strong></p>
<ul>
<li><strong>自动化测试：</strong> 利用AI技术实现自动化测试，提高测试覆盖率和效率。</li>
<li><strong>质量监控：</strong> 利用实时监控和分析技术，对系统性能和输出进行持续监测，及时发现潜在问题。</li>
</ul>
<p><strong>3. 过程改进：</strong></p>
<p><strong>挑战：</strong></p>
<ul>
<li><strong>快速变化的技术：</strong> AI技术的快速发展使得过程改进需要更加灵活，适应快速变化的技术环境。</li>
<li><strong>人才需求：</strong> 缺乏AI方面的专业人才可能限制过程改进的实施。</li>
</ul>
<p><strong>机遇：</strong></p>
<ul>
<li><strong>自适应过程：</strong> 引入自适应的过程改进方法，能够根据项目和技术的变化进行灵活调整。</li>
<li><strong>AI辅助决策：</strong> 利用AI技术辅助决策过程改进策略，提高改进的准确性和效果。</li>
</ul>
<h3 id="【2015B】【2016】请描述-PDCA-模型的主要步骤"><a href="#【2015B】【2016】请描述-PDCA-模型的主要步骤" class="headerlink" title="【2015B】【2016】请描述 PDCA 模型的主要步骤"></a>【2015B】【2016】请描述 PDCA 模型的主要步骤</h3><p>软件过程改进模型PDCA 模型的步骤：</p>
<ol>
<li>分析现状，找出问题</li>
<li>分析影响质量的原因</li>
<li>找出措施</li>
<li>拟定措施计划</li>
<li>执行措施，执行计划</li>
<li>检查效果，发现问题</li>
<li>总结经验，纳入标准</li>
<li>遗留问题转入下期 PDCA 循环</li>
</ol>
<h3 id="IDEAL模型"><a href="#IDEAL模型" class="headerlink" title="IDEAL模型"></a>IDEAL模型</h3><p>软件过程改进模型IDEAL 模型解决了软件组织在各种质量改进环境下的需要。它包括了软件过程改进周期中的五个阶段，IDEAL 是代表这五个阶段的单词的首字母。</p>
<ol>
<li>I: Initiating 初始</li>
<li>D: Diagnosing 诊断</li>
<li>E: Establishing 建立</li>
<li>A: Acting 执行</li>
<li>L: Leveraging 调整</li>
</ol>
<h1 id="2-软件过程的历史演变和经典工作-1"><a href="#2-软件过程的历史演变和经典工作-1" class="headerlink" title="2.软件过程的历史演变和经典工作"></a>2.软件过程的历史演变和经典工作</h1><h2 id="选择-1"><a href="#选择-1" class="headerlink" title="选择"></a>选择</h2><p><strong>以下哪个因素促成了软件成为独立的产品？</strong></p>
<p>A.操作系统的出现</p>
<p>B.高级程序设计语言的出现</p>
<p>C.互联网的出现</p>
<p>D.个人电脑的出现</p>
<p>正确答案：A</p>
<p><strong>‌根据敏捷宣言，以下哪项描述了更多的价值？</strong></p>
<p>A.响应变化、个体和交互、流程和工作、客户协作</p>
<p>B.客户协作、遵循计划、可工作的软件、个体交互</p>
<p>C.个体和交互、可工作的软件、客户协作、响应变化</p>
<p>D.可工作的软件、个体交互、响应变化、相近的文档 </p>
<p>正确答案：C</p>
<p>‍<strong>以下描述中，哪几种是网络化和服务化这个阶段的典型软件应用特征？</strong></p>
<p>A.用户数量急剧增加</p>
<p>B.通过SaaS等方式来发布软件系统</p>
<p>C.快速演化、需求不确定</p>
<p>D.通过CD和DVD等方式支持大容量和快速分发软件拷贝</p>
<p>正确答案：A、B、C</p>
<p><strong>关于形式化方法的描述当中，不正确的有哪些？</strong></p>
<p>‎A.这种方法是网络化和服务化阶段用来应对软件开发本质四大难题而提出来的（错误，应该是软件成为独立的产品）</p>
<p>B.这种方法应用范围有限，例如：不适合跟客户讨论需求。</p>
<p>C.这种方法的主要目的是解决软件开发的效率问题（主要解决质量和正确性）</p>
<p>D.这种方法对开发人员技能有较高的要求</p>
<p>正确答案：A、C</p>
<p><strong>关于迭代式方法的说法哪些是比较恰当的？</strong></p>
<p>‌A.迭代式方法主要是为了解决软件开发的质量问题（应该是解决效率）</p>
<p>B.迭代式方法是上世纪九十年代中后期才出现的一种方法（1970-1980，敏捷才是九十年代中后期）</p>
<p>C.迭代式方法主要特征在于将软件开发过程视作一个逐步学习和交流的过程</p>
<p>D.迭代式方法是指一类具有类似特征的方法</p>
<p>正确答案：C、D</p>
<p><strong>DevOps的哪些特点可以有效支撑当前社会对软件系统的期望？</strong></p>
<p>A.敏捷开发、精益思想以及看板方法，支持快速开发、交付、迭代和演化</p>
<p>B.微服务架构设计</p>
<p>C.虚拟机技术的大量应用</p>
<p>D.工具链支持高效率的自动化</p>
<p>正确答案：A、B、C、D</p>
<p><strong>下列软件应用和开发的典型特征中属于软硬件一体化阶段的是？BC</strong></p>
<p>A.可以通过引入操作系统，摆脱了硬件束缚（软件成为独立的产品）</p>
<p>B.几乎不需要考虑需求变更</p>
<p>C.缺乏科班的软件工程师</p>
<p>D.系统兼容对应软件开发的成败非常关键（软件成为独立的产品）</p>
<p><strong>【2015B】XP规定开发⼈员每周⼯作时间不超过___⼩时，连续加班不可以超过两周，以免降低⽣产率？(B)</strong></p>
<p>30</p>
<p>40</p>
<p>50</p>
<p>60</p>
<p><strong>下列不属于看板方法典型实践的是？BD</strong></p>
<p>A.可视化工作流</p>
<p>B.站立式会议</p>
<p>C.限定WIP</p>
<p>D.重构</p>
<p><strong>下列术语描述的技术或者方法是同类型的是？CD</strong></p>
<p>A.CMMI SPICE PDCA：前两者是软件过程管理，后一个是软件过程改进</p>
<p>B.IDEAL XP SCRUM：IDEAL 是软件过程改进，XP 和 SCRUM 是软件过程</p>
<p>C.Cleanroom Gate TSP：软件过程</p>
<p>D.Waterfall SCRUM XP：软件实践</p>
<h2 id="简答-1"><a href="#简答-1" class="headerlink" title="简答"></a>简答</h2><h3 id="【2021Fall】【2020-mid】如何理解瀑布模型（6-分）"><a href="#【2021Fall】【2020-mid】如何理解瀑布模型（6-分）" class="headerlink" title="【2021Fall】【2020-mid】如何理解瀑布模型（6 分）"></a><strong>【2021Fall】【2020-mid】如何理解瀑布模型（6 分）</strong></h3><ol>
<li>(4’)瀑布模型不是单一模型，是<strong>一系列</strong>模型，覆盖最简单场景(过程元素少)到最复杂的场景(过程元素多)</li>
<li>(4’)软件项目应该<strong>结合实际情况</strong>选择<strong>合适过程元素</strong>的瀑布模型，基本原则是，项目面临困难和挑战越多，选择的模型应该越复杂</li>
<li>(4’)软件项目团队往往<strong>低估</strong>项目的挑战，选择了过于简单的不适用的瀑布模型</li>
</ol>
<h3 id="【2022Fall】【2021Fall】【2020-mid】请完整描述敏捷宣言的内容。我们应该如何正确理解敏捷宣言？（10-分）"><a href="#【2022Fall】【2021Fall】【2020-mid】请完整描述敏捷宣言的内容。我们应该如何正确理解敏捷宣言？（10-分）" class="headerlink" title="【2022Fall】【2021Fall】【2020-mid】请完整描述敏捷宣言的内容。我们应该如何正确理解敏捷宣言？（10 分）"></a><strong>【2022Fall】【2021Fall】【2020-mid】请完整描述敏捷宣言的内容。我们应该如何正确理解敏捷宣言？（10 分）</strong></h3><ol>
<li>敏捷软件开发宣言的 4 个简单的价值观：<ol>
<li>(1’)个体和交互 胜过 过程和工具</li>
<li>(1’)可以工作的软件 胜过 面面俱到的文档</li>
<li>(1’)客户合作 胜过 合同谈判</li>
<li>(1’)响应变化 胜过 遵循计划</li>
</ol>
</li>
<li>(1’)也就是说，尽管右项有其价值，我们更重视左项的价值</li>
</ol>
<blockquote>
<p>一些不合适的关于敏捷的说法：</p>
<ul>
<li>轻量级方法：这是对 XP 一类方法的误导，实际上，这类方法对工程规范有着极为严格的要求</li>
<li>变更驱动：仅仅是口号，对待变更，所有软件工程方法都是限制和管理的态度</li>
<li>TDD 可以提供更高的开发质量：并没有足够的证据支持</li>
</ul>
</blockquote>
<h3 id="【2020-mid】请结合软件发展的三大阶段，描述不同阶段的特点-典型软件开发方法和实践（10分）"><a href="#【2020-mid】请结合软件发展的三大阶段，描述不同阶段的特点-典型软件开发方法和实践（10分）" class="headerlink" title="【2020-mid】请结合软件发展的三大阶段，描述不同阶段的特点+典型软件开发方法和实践（10分）"></a><strong>【2020-mid】请结合软件发展的三大阶段，描述不同阶段的特点+典型软件开发方法和实践（10分）</strong></h3><ol>
<li>软硬件一体化<ol>
<li>特点：软件支持硬件完成计算任务、功能单一、复杂度有限、几乎不需要需求变更</li>
<li>主流开发方法：线性顺序过程，事实上是硬件开发流程；measure twice cut once；Code and Fix；</li>
</ol>
</li>
<li>软件成为独立的产品<ol>
<li>特点：摆脱了硬件的束缚(操作系统)、功能强大、个人电脑出现、需求多变、兼容性要求、来自市场的压力</li>
<li>主流开发方法：形式化方法、结构化程序设计和瀑布模型、成熟度模型</li>
</ol>
</li>
<li>网络化和服务化<ol>
<li>特点：功能更复杂、规模更大、用户数量急剧增加、快速演化和需求不确定、分发方式的变化、进一步的服务化和网络化、盛行开源和共享文化</li>
<li>主流开发方法：迭代式开发、敏捷开发(XP、Scrum、Kanban)、开源软件开发方式</li>
</ol>
</li>
</ol>
<blockquote>
<p>brooks本质难题对它的影响：</p>
<p>严格来说，只有不可见才是真正的“本质”难题，其他三个因项目而异（复杂性：实体数量众多；不可见性：软件项目是一个逻辑实体；可变性；一致性）</p>
<p>四大本质难题贯穿软件发展的不同历史段，但是在不同历史阶段，相互凸显程度不一样</p>
</blockquote>
<h3 id="”迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，-而是通过多个迭代周期，逐步来完成交付。“中什么词最重要？"><a href="#”迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，-而是通过多个迭代周期，逐步来完成交付。“中什么词最重要？" class="headerlink" title="”迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成， 而是通过多个迭代周期，逐步来完成交付。“中什么词最重要？"></a><strong>”迭代式：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成， 而是通过多个迭代周期，逐步来完成交付。“中什么词最重要？</strong></h3><p>逐步学习和交流的过程：确保满足客户的反馈和期望。</p>
<blockquote>
<p>背一下迭代式的定义</p>
</blockquote>
<h3 id="【2015B】【2016】请结合-SCRUM-这种敏捷方法论述敏捷方法应该具备的特征？同时解释为何常见的若干种描述敏捷方法对立面的方法的特征（例如，严格、重型、计划驱动等等）并不合适？10’"><a href="#【2015B】【2016】请结合-SCRUM-这种敏捷方法论述敏捷方法应该具备的特征？同时解释为何常见的若干种描述敏捷方法对立面的方法的特征（例如，严格、重型、计划驱动等等）并不合适？10’" class="headerlink" title="【2015B】【2016】请结合 SCRUM 这种敏捷方法论述敏捷方法应该具备的特征？同时解释为何常见的若干种描述敏捷方法对立面的方法的特征（例如，严格、重型、计划驱动等等）并不合适？10’"></a>【2015B】【2016】请结合 SCRUM 这种敏捷方法论述敏捷方法应该具备的特征？同时解释为何常见的若干种描述敏捷方法对立面的方法的特征（例如，严格、重型、计划驱动等等）并不合适？10’</h3><ol>
<li>特征<ol>
<li>小周期迭代</li>
<li>快速响应变更</li>
<li>价值交付</li>
<li>自动化</li>
</ol>
</li>
<li>特征解释：<ol>
<li>严格：所有优秀的工程方法和实践都是严格的。</li>
<li>重型：如上，此外，轻量级和重型其实并没有刻画具体方法，何为重型，并没有严格定义；而且，对于变更这件事情，几乎所有方法都是限制，因此，很难说敏捷方法是轻量级方法。</li>
<li>计划驱动：所有正式的项目都是计划驱动的，否则计划的作用无法体现</li>
</ol>
</li>
</ol>
<h3 id="【2015A】敏捷方法的特征有哪些？哪些关于敏捷特征的说法施加于敏捷方法之上是不合适的？为什么？10’"><a href="#【2015A】敏捷方法的特征有哪些？哪些关于敏捷特征的说法施加于敏捷方法之上是不合适的？为什么？10’" class="headerlink" title="【2015A】敏捷方法的特征有哪些？哪些关于敏捷特征的说法施加于敏捷方法之上是不合适的？为什么？10’"></a><strong>【2015A】敏捷方法的特征有哪些？哪些关于敏捷特征的说法施加于敏捷方法之上是不合适的？为什么？10’</strong></h3><ol>
<li>特征：小周期迭代式持续交付、敏捷宣言</li>
<li>关于敏捷方法的一些特征表述可能带着一定的误导，例如：<ol>
<li>轻量级方法：这是对以 XP 为代表的一类方法的误导，事实上，这类方法对工程规范有着极为严格的要求;</li>
<li>拥抱变更、变更驱动：仅仅是口号，对待变更，所有软件工程方法都是限制和管理的态度。</li>
<li>TDD 可以提供更高的开发质量：并没有足够的证据支持。</li>
</ol>
</li>
</ol>
<h3 id="【2014】为何说将“规范方法”、“计划驱动方法”等特征作为敏捷方法的对立面带有很大的误导性质？如何通过多种维度改进这种对各类开发过程的理解？10’"><a href="#【2014】为何说将“规范方法”、“计划驱动方法”等特征作为敏捷方法的对立面带有很大的误导性质？如何通过多种维度改进这种对各类开发过程的理解？10’" class="headerlink" title="【2014】为何说将“规范方法”、“计划驱动方法”等特征作为敏捷方法的对立面带有很大的误导性质？如何通过多种维度改进这种对各类开发过程的理解？10’"></a>【2014】为何说将“规范方法”、“计划驱动方法”等特征作为敏捷方法的对立面带有很大的误导性质？如何通过多种维度改进这种对各类开发过程的理解？10’</h3><ol>
<li>敏捷：敏捷目的、敏捷价值观、敏捷原则</li>
<li>影响敏捷与规范方法选择的五个维度<ol>
<li>如果只有强有力的规范而缺乏敏捷，将导致官僚作风，进而停滞不前。团队将陷入为了测量而测量的处境之中，缺乏创新。</li>
<li>缺乏创新的敏捷则如同一个新创公司在盈利之前的不负责任的狂热</li>
<li>计划驱动的开发人员必须敏捷，敏捷开发人员必须规范。</li>
</ol>
</li>
</ol>
<blockquote>
<p>这是因为敏捷方法并不排斥规范和计划，它们只是更加注重适应变化和快速交付价值。</p>
<p>严格的纪律和缺乏敏捷性会导致官僚主义和缺乏创新，而缺乏纪律的敏捷方法会导致不负责任的狂热和不稳定。因此，计划驱动的开发人员需要敏捷的思维方式和能力，而敏捷的开发人员需要有纪律的方法和实践来确保质量和可维护性。</p>
</blockquote>
<p>不对立，反而相得益彰：</p>
<ul>
<li><p>计划驱动的开发人员必须敏捷，敏捷开发人员必须规范。成功的关键在于找到两者的平衡点。</p>
</li>
<li><p>这个平衡点随项目所处的环境以及所涉及的风险而变化。仅凭一腔热情径直地采用极端方法的开发人员，必须学会如何根据实际情况恰当地平衡敏捷与规范。</p>
</li>
</ul>
<h3 id="【2021】简述DevOps实践、方法、技术-10分"><a href="#【2021】简述DevOps实践、方法、技术-10分" class="headerlink" title="【2021】简述DevOps实践、方法、技术(10分)"></a>【2021】简述DevOps实践、方法、技术(10分)</h3><ol>
<li>方法论的基础是<strong>软件敏捷开发、精益思想和看板 KanBan 方法</strong></li>
<li>以<strong>领域驱动设计</strong>为指导的微服务架构方式</li>
<li>大量<strong>虚拟化技术</strong>的使用</li>
<li>一切皆服务 <strong>XaaS</strong>(X as a Service) 的理念指导</li>
<li>构建了强大的<strong>工具链</strong>，支持高水平自动化。</li>
</ol>
<h3 id="Linus定律"><a href="#Linus定律" class="headerlink" title="Linus定律"></a>Linus定律</h3><p>大教堂与市集：开源软件开发方式</p>
<p>如果有足够多的 beta 测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。</p>
<h1 id="3-团队动力学-1"><a href="#3-团队动力学-1" class="headerlink" title="3.团队动力学"></a>3.团队动力学</h1><h2 id="选择-2"><a href="#选择-2" class="headerlink" title="选择"></a>选择</h2><p>**下列描述当中，属于过程经理的工作内容有哪些？AC **</p>
<p>A.建立团队的开发标准</p>
<p>B.主持项日周例会（项目组长）</p>
<p>C.记录周例会的会议记录</p>
<p>D.制定开发计划（计划经理）</p>
<h2 id="简答-2"><a href="#简答-2" class="headerlink" title="简答"></a>简答</h2><h3 id="【2020-mid】请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？5-分"><a href="#【2020-mid】请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？5-分" class="headerlink" title="【2020-mid】请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？5 分"></a>【2020-mid】请结合软件开发的特点介绍软件项目管理中自主型团队的必要性以及自主团队应该具备的特征？5 分</h3><ol>
<li>软件开发是一项既复杂又富有创造性的知识工作 (1’)</li>
<li>软件开发是一种智力劳动 (1’)<ol>
<li>处理和讨论 极其抽象的概念</li>
<li>把不同的部分（不可见）整合成一个可以工作的系统</li>
</ol>
</li>
<li>这就要求软件开发工程师<ul>
<li>全身心参与工作</li>
<li>主观意愿上追求卓越</li>
</ul>
</li>
<li>这就要求管理者<strong>激励并维持激励</strong></li>
<li>管理知识工作的关键规则是：管理者无法管理知识工作者，知识工作者必须<strong>实现并且学会自我管理</strong>。要自我管理，知识工作者必须：<ul>
<li>有积极性</li>
<li>能做出准确的估算和计划</li>
<li>懂得协商承诺</li>
<li>有效跟踪自己的计划</li>
<li>持续按计划交付高质量产物</li>
</ul>
</li>
<li>而“胶冻态团队”恰恰可以让知识工作者实现自我管理，也就是自主团队。</li>
<li>含义：软件工程师所从事的工作一般称之为复杂的知识工作。在这种性质的工作中，实现软件工程师的自我管理往往可以获得最好的工作效率和质量水平。如果整个团队的所有成员都实现了自我管理，也就形成了所谓的自主团队。<ul>
<li>自主团队可以形成“胶冻态团队”。</li>
</ul>
</li>
<li>自主团队具备如下的特点： （每两点 1 分）<ol>
<li>自行定义项目的目标</li>
<li>自行决定团队组成形式以及成员的角色</li>
<li>自行决定项目的开发策略</li>
<li>自行定义项目的开发过程</li>
<li>自行制定项目的开发计划</li>
<li>自行度量、管理和控制项目工作</li>
</ol>
</li>
</ol>
<h3 id="【2021】TSP中的典型角色，描述其中五个角色的职责-10分"><a href="#【2021】TSP中的典型角色，描述其中五个角色的职责-10分" class="headerlink" title="【2021】TSP中的典型角色，描述其中五个角色的职责(10分)"></a>【2021】<strong>TSP中的典型角色，描述其中五个角色的职责(10分)</strong></h3><ul>
<li>项目组长：激励团队成员，主持例会，汇报项目状态，分配工作任务，维护项目资料，组织项目总结</li>
<li>开发经理：指定开发策略，开展产品规模估算和时间资源估算（由开发经理做，而非计划经理做）；开发需求规格说明、高层设计、设计规格说明、用户支持文档；实现软件产品，开展集成测试和系统测试，参与项目总结</li>
<li>计划经理：带领小组开发项目计划，平衡计划，跟踪项目进度，参与项目总结</li>
<li>过程经理：带领团队定义和记录开发过程并且支持过程改进，建立和维护团队的开发标准（命名规范、编码规范、接口标准、…），记录和维护项目的会议记录，参与项目总结</li>
<li>质量经理：带领团队跟踪质量计划，向项目组长警示质量问题，评审以消除质量问题，项目小组评审的组织者和协调者，参与项目总结</li>
<li>支持经理：识别开发过程中需要用到的工具和设施，管理配饰管理系统，维护软件项目词汇表，维护项目风险和问题跟踪系统，支持开发过程中复用策略的应用，参与项目总结</li>
</ul>
<h3 id="【2022Fall】结合“软件开发作为一种知识工作，需要领导者而不是一般的经理”，阐述知识工作领导者应该具备的品质或者特点（至少三项）"><a href="#【2022Fall】结合“软件开发作为一种知识工作，需要领导者而不是一般的经理”，阐述知识工作领导者应该具备的品质或者特点（至少三项）" class="headerlink" title="【2022Fall】结合“软件开发作为一种知识工作，需要领导者而不是一般的经理”，阐述知识工作领导者应该具备的品质或者特点（至少三项）"></a>【2022Fall】结合“软件开发作为一种知识工作，需要领导者而不是一般的经理”，阐述知识工作领导者应该具备的品质或者特点（至少三项）</h3><p>•Honest – did what they said they would do 诚实 – 说到做到</p>
<p>•Competent – skills and knowledge 能力 – 技能和知识</p>
<p>•Visionary – can they see past the horizon, do they have a believable view of a desirable future? 远见——透过事物看本质，对理想的未来有可信的看法</p>
<p>•Inspirational – do they have a positive, enthusiastic, and energetic view of the future? 鼓舞人心-对未来有积极、热情、精力充沛的看法</p>
<h3 id="马斯洛需求理论是什么，对软件工程实践的启发？"><a href="#马斯洛需求理论是什么，对软件工程实践的启发？" class="headerlink" title="马斯洛需求理论是什么，对软件工程实践的启发？"></a>马斯洛需求理论是什么，对软件工程实践的启发？</h3><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501350.png" alt="image-20240102120635427"></p>
<ol>
<li>五个层次：生理需求（Physiological)、安全感（Safety)、爱和归属感（social)、获得尊敬（Esteem)、自我实现（Self-Actualization)</li>
<li>注意<ol>
<li>自我实现是最高的层次。</li>
<li>激励来自为没有满足的需求而努力奋斗。</li>
<li>低层次的需求必须在高层次需求满足之前得到充分满足。</li>
<li>满足高层次的需求的途径比满足低层次的途径更为广泛。</li>
</ol>
</li>
<li>威逼利诱比较低层，鼓励承诺在 4-5 层，效果比较好</li>
</ol>
<h3 id="请描述高质量评审团队的特征，并解释TSP是如何支持高质量评审团队的"><a href="#请描述高质量评审团队的特征，并解释TSP是如何支持高质量评审团队的" class="headerlink" title="请描述高质量评审团队的特征，并解释TSP是如何支持高质量评审团队的"></a>请描述高质量评审团队的特征，并解释TSP是如何支持高质量评审团队的</h3><p>问自主团队的特征<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501340.png" alt="image-20240101160042417"></p>
<h1 id="4-估算、计划和跟踪-1"><a href="#4-估算、计划和跟踪-1" class="headerlink" title="4.估算、计划和跟踪"></a>4.估算、计划和跟踪</h1><h2 id="选择-3"><a href="#选择-3" class="headerlink" title="选择"></a>选择</h2><p><strong>关于PROBE估算法，下述各种说法中，不正确的有哪些？</strong></p>
<p>A.PROBE估算结果带着小数，肯定不准确，因而， 不应该在项目估算的时候使用。</p>
<p>B.PROBE不能给出精确估算，因而适合用来跟用户讨论需求和规模。（精确度量和早期规划需要的度量之间的桥梁）</p>
<p>C.PROBE方法不能用来估算质量。</p>
<p>D.PROBE方法不需要历史数据。</p>
<p>正确答案：A、B、D</p>
<p><strong>下列关于挣值管理方法的描述中错误的是？ C</strong></p>
<p>A.这是一种可以用来跟踪项目预算消耗的方法</p>
<p>B.这种方法高度依赖估算准确性</p>
<p>C.这种方法可以支持质量管理</p>
<p>D.这种方法可以用来跟踪项目进度</p>
<p>C：挣值管理方法不支持质量管理，因为它们关注的是成本节约而不是质量改进。他们必须找到将质量考虑在内的正确解决方案来支持质量管理。</p>
<p><strong>完成一份完整的项目日程计划，需要下列哪些信息？ABD</strong></p>
<p>A.任务清单</p>
<p>B.任务顺序</p>
<p>C.质量要求</p>
<p>D.人员资源水平</p>
<p><strong>PROBE方法估算规模的时候，下列说法不恰当的是：AC</strong></p>
<p>PROBE A 方法要求三组以及三组以上的代理规模数据和实际规模数据，且要求其相关性R²大于等于 7；（是R&gt;0.7）</p>
<p>PROBE C 方法仅仅需要根据上一次项目中估算值和实际值的比例进行调整即可；</p>
<p>应用 PROBE A 方法的估算结果一定会好于 PROBE B 方法；（不一定）</p>
<p>PROBE 方法的优势之一是采取了相对大小，而非绝对大小，辅助估算着思考和判断；</p>
<p><strong>下列指标中适合用作风险参数的是：ABC</strong></p>
<p>A.发生概率；</p>
<p>B.影响程度；</p>
<p>C.风险系数；</p>
<p>D.触发阈值</p>
<h2 id="简答-3"><a href="#简答-3" class="headerlink" title="简答"></a>简答</h2><h3 id="【2020】EVM进度差异-为什么"><a href="#【2020】EVM进度差异-为什么" class="headerlink" title="【2020】EVM进度差异?为什么?"></a>【2020】EVM进度差异?为什么?</h3><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501948.png" alt="image-20240101230343197"></p>
<p>整体提前了，这周的工作没达到计划，创造价值比预计的少，可能是低估了项目的难度</p>
<p>总体进度，通过to date看，Earned value to date这一项里Actual&gt;Plan,说明迄今为止进度没有落后。</p>
<p>但是，Hours to date总共花的时间大于预期，每个小时预期创造0.3个价值，而实际每小时创造0.28的价值，说明实际工作效率不如预期，所以在下周或者过几周，这个项目的进度可能就会逐渐落后。</p>
<h3 id="【2021】EVM项目进度如何？是提前还是落后？项目有什么风险？"><a href="#【2021】EVM项目进度如何？是提前还是落后？项目有什么风险？" class="headerlink" title="【2021】EVM项目进度如何？是提前还是落后？项目有什么风险？"></a><strong>【2021】EVM项目进度如何？是提前还是落后？项目有什么风险？</strong></h3><p>第一天需要完成50个值，第二天需要完成20个值，第三天需要完成30个值。</p>
<p>BAC：第一天50，第二天70，第三天100.</p>
<p>超期情况，EV：第二天50值，AC：第二天100值。</p>
<p>CV&#x3D;EV-AC&#x3D;-50,SV&#x3D;EV-PV&#x3D;-20，所以进度滞后，进度效率低；费用超支，资金使用效率低</p>
<p>有可能出现第二天用户说，任务B和任务C不做了（项目进度落后变为了项目进度正常</p>
<h3 id="EVM例题"><a href="#EVM例题" class="headerlink" title="EVM例题"></a>EVM例题</h3><p>（1） 项目进度是否有偏差？偏差百分比多少？对应偏差日期约为多少周？（本题满分2分）</p>
<p>出现偏差，EV&#x3D;22.3,PV&#x3D;28.3,SPI&#x3D;EV&#x2F;PV&#x3D;79% 偏差百分比约为-20% 对应偏差日期约为7*-20%&#x3D;-1.4周</p>
<p>（2） 出现进度偏差的原因是什么？（本题满分2分）</p>
<p>出现进度偏差的原因可能是项目团队低估了工作的难度。</p>
<p>（3） 原计划在17周完成，按照目前进度，预计什么时候完成？ （本题满分2分）</p>
<p>actual 效率 22.3 &#x2F; 493.4 &#x3D; 0.045 每个hour获得的EV Value<br>plan 效率 28.2 &#x2F; 467 &#x3D; 0.060<br>实际时间T * 0.045 &#x3D; 17 * 0.06 T &#x3D; 22.6</p>
<p>根据目前进度，预计项目大约会在第23周完成。</p>
<p>（4） 如果还需要按照原定计划完成，在允许调整（增加或者减少）人员的情况下，可以怎么调整？为什么？ （本题满分4分）</p>
<p>如果还需要按照原定计划完成，可以增加项目团队的人数或增加每个人的任务量，以提高效率与进度。</p>
<h3 id="【2020】请简要描述按照通用计划框架，为了开发合理的项目计划，应该要做哪些估算？PROBE-方法充当了什么角色？"><a href="#【2020】请简要描述按照通用计划框架，为了开发合理的项目计划，应该要做哪些估算？PROBE-方法充当了什么角色？" class="headerlink" title="【2020】请简要描述按照通用计划框架，为了开发合理的项目计划，应该要做哪些估算？PROBE 方法充当了什么角色？"></a>【2020】<strong>请简要描述按照通用计划框架，为了开发合理的项目计划，应该要做哪些估算？PROBE 方法充当了什么角色？</strong></h3><p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501989.png" alt="image-20240101230943204"></p>
<h3 id="【2020】请描述一下PROBE方法的基本原理和过程，并解释在应用PROBE-A方法估算时间的时候，为什么不用历史数据中的生产效率数据"><a href="#【2020】请描述一下PROBE方法的基本原理和过程，并解释在应用PROBE-A方法估算时间的时候，为什么不用历史数据中的生产效率数据" class="headerlink" title="【2020】请描述一下PROBE方法的基本原理和过程，并解释在应用PROBE A方法估算时间的时候，为什么不用历史数据中的生产效率数据"></a>【2020】请描述一下PROBE方法的基本原理和过程，并解释在应用PROBE A方法估算时间的时候，为什么不用历史数据中的生产效率数据</h3><p>基本原理（4’）：2点</p>
<ul>
<li>代理使用<strong>相对大小</strong>而不是绝对大小</li>
<li>合理的代理作为<strong>精确度量和早期规划需要的度量之间</strong>的桥梁</li>
</ul>
<p>过程：</p>
<p>概要设计：确定产品功能和生产它们所需的<strong>组件&#x2F;模块</strong>，将它们与现有程序进行比较，估算它们的规模，并将它们组合起来得出总规模。</p>
<p>不适用生产效率的理由：在估算资源需求（例如，人时）的时候，<strong>生产效率一般在分母</strong>上，考虑到<strong>个体软件工程师生产效率波动</strong>，易导致的估算偏差范围变大。</p>
<h3 id="【2013】【2015A】【2018Fall】谈谈你对项目估算的认识，并简要解释应用-PROBE-方法估算的优缺点。"><a href="#【2013】【2015A】【2018Fall】谈谈你对项目估算的认识，并简要解释应用-PROBE-方法估算的优缺点。" class="headerlink" title="【2013】【2015A】【2018Fall】谈谈你对项目估算的认识，并简要解释应用 PROBE 方法估算的优缺点。"></a><strong>【2013】【2015A】【2018Fall】谈谈你对项目估算的认识，并简要解释应用 PROBE 方法估算的优缺点。</strong></h3><ul>
<li>项目估算<ul>
<li>规模估算：可以根据<strong>历史数据</strong>来完成，其原因在于规模估算结果的偏差产生原因相对客观，偏差可以用以修正新的估算结果</li>
<li>时间估算：产生原因更加复杂，一方面和规模有关，另一方面和人的<strong>主观能动性</strong>有关；因此时间估算偏差的原因可能来自估算结果本身，这使得历史数据中时间偏差参考价值不大</li>
</ul>
</li>
<li>估算本质上是一种猜测，追求的目标是<strong>一致性</strong>以及<strong>估算结果使用者对估算的信心</strong></li>
<li>PROBE估算原理：相对大小矩阵</li>
<li>PROBE优缺点<ul>
<li>优点：通过定义的估算过程、数据收集以及使用的框架，使得估算结果尽可能<strong>一致</strong>，从而使得一些统计方法可以被用来调整估算结果，增强使用者对估算结果的<strong>信心</strong></li>
<li>缺点：但是这种估算方法非常依赖<strong>高质量的历史数据</strong>，如果数据不完整或质量不高，就可能导致估算结果有显著偏差</li>
</ul>
</li>
</ul>
<h3 id="【2020-mid】请描述-PROBE-ABCD-方法在估算规模的时候，对历史数据的质量有什么要求？"><a href="#【2020-mid】请描述-PROBE-ABCD-方法在估算规模的时候，对历史数据的质量有什么要求？" class="headerlink" title="【2020-mid】请描述 PROBE ABCD 方法在估算规模的时候，对历史数据的质量有什么要求？"></a>【2020-mid】请描述 PROBE ABCD 方法在估算规模的时候，对历史数据的质量有什么要求？</h3><p>PROBE A B C D 方法需要使<strong>用高质量的历史数据</strong>来估算规模。这些数据必须<strong>完整、准确、可靠</strong>，并且客观地反映现实。它还必须准确反映给定时期的规模以及时期之间的变化情况。</p>
<h3 id="【2013】【2014】【2015A】【2015B】【2016】如何制定一份让人无法拒绝的计划，请描述基本步骤和一些注意事项"><a href="#【2013】【2014】【2015A】【2015B】【2016】如何制定一份让人无法拒绝的计划，请描述基本步骤和一些注意事项" class="headerlink" title="【2013】【2014】【2015A】【2015B】【2016】如何制定一份让人无法拒绝的计划，请描述基本步骤和一些注意事项"></a><strong>【2013】【2014】【2015A】【2015B】【2016】如何制定一份让人无法拒绝的计划，请描述基本步骤和一些注意事项</strong></h3><p><strong>正推</strong>:除了概要设计和资源估算之外，其他环节尽可能自动化完成。充分参考历史数据进行估算</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501989.png" alt="image-20240101230943204"></p>
<ol>
<li><p>估算规模</p>
</li>
<li><p>估算资源</p>
</li>
<li><p><strong>日程计划</strong>：任务清单-&gt;资源清单-&gt;日程计划</p>
</li>
<li><p><strong>质量计划</strong></p>
<ol>
<li>项目的质量计划中应当确定需要开展的<strong>质量保证活动</strong>。</li>
<li>典型的质量保证活动包括了个人评审、团队评审、单元测试、集成测试以及验收测试等。</li>
<li>在质量计划中需要解决的关键问题是该开展哪些活动，以及这些活动开展的程度，如时间、人数和目标是什么。</li>
</ol>
</li>
<li><p><strong>风险计划</strong></p>
<ol>
<li>目标：在风险发生前，识别出潜在的问题，以消除潜在问题对项目产生的负面影响。</li>
<li>风险管理大致分为两部分，即风险识别和风险应对。</li>
<li>识别风险之后，就应当制定相应的风险管理策略，以应对各类风险。典型的策略包括：风险转嫁、风险解决、风险缓解</li>
</ol>
</li>
</ol>
<h3 id="【2014】请解释规模估算和资源估算中估算偏差含义之间的差异，并据此简要列举对软件开发活动的启发？"><a href="#【2014】请解释规模估算和资源估算中估算偏差含义之间的差异，并据此简要列举对软件开发活动的启发？" class="headerlink" title="【2014】请解释规模估算和资源估算中估算偏差含义之间的差异，并据此简要列举对软件开发活动的启发？"></a>【2014】请解释规模估算和资源估算中估算偏差含义之间的差异，并据此简要列举对软件开发活动的启发？</h3><p>工作量与实际工作量之间的差距 VS 资源数量与实际资源数量之间的差距。</p>
<p>启发：编写描述准确的需求文档，<strong>监控</strong>估算偏差，并及时分析以避免延误。</p>
<h3 id="【2022Fall】挣值管理的三种实现方式。分别是简单、中级以及高级。请分别描述上述三种方式所具备的特质。"><a href="#【2022Fall】挣值管理的三种实现方式。分别是简单、中级以及高级。请分别描述上述三种方式所具备的特质。" class="headerlink" title="【2022Fall】挣值管理的三种实现方式。分别是简单、中级以及高级。请分别描述上述三种方式所具备的特质。"></a>【2022Fall】挣值管理的三种实现方式。分别是简单、中级以及高级。请分别描述上述三种方式所具备的特质。</h3><ol>
<li><p>简单实现：这种方式仅仅关注进度信息。</p>
<ol>
<li>在实现时，首先需要建立<strong>WBS</strong>，定义工作范围；</li>
<li>其次为WBS中每一项工作定义一个价值（PV）；</li>
<li>最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作（得到EV）。常用规则分别为0-100规则和50-50规则，<ol>
<li>前者只有当某项任务完成时，该任务的PV值将转化成EV值；后者只需要开始某项任务，即可以赋原PV值的50%作为EV值，完成时，再加上另外的50%。</li>
<li>而实际完成的工作所需成本AC不对EV值产生任何影响。</li>
</ol>
</li>
</ol>
</li>
<li><p>中级实现：在简单实现的基础上，加入<strong>日程偏差</strong>的计算。典型计算方式有：</p>
<ol>
<li>日程偏差SV &#x3D; EV – PV;</li>
<li>日程偏差指数SPI &#x3D; EV&#x2F;PV；</li>
</ol>
</li>
<li><p>高级实现：在中级实现的基础上，还需要考察项目的<strong>实际成本</strong>。</p>
</li>
</ol>
<h3 id="【2023】【2022】规模估算和资源估算的要点"><a href="#【2023】【2022】规模估算和资源估算的要点" class="headerlink" title="【2023】【2022】规模估算和资源估算的要点"></a>【2023】【2022】规模估算和资源估算的要点</h3><ol>
<li>尽可能划分详细一些：估算多个部件的时候，总的误差会比各个部件的误差的总和小</li>
<li><strong>建立对结果的信心</strong></li>
<li>依赖数据</li>
<li>估算要的是过程，而非结果，估算的过程是相关干系人达成一致共识的过程。</li>
</ol>
<blockquote>
<p>估算的目的：给各类计划提供<strong>决策依据</strong></p>
</blockquote>
<h3 id="【2014】估算与计划的差异"><a href="#【2014】估算与计划的差异" class="headerlink" title="【2014】估算与计划的差异"></a>【2014】估算与计划的差异</h3><p>目的不同、包含的活动不同、典型计划流程包括估算</p>
<ol>
<li>估算目的是给各类计划提供<strong>决策依据</strong>，估算对象分为规模、时间和日程。估算追求<strong>所有的参与者对规范结果的一个认同</strong>。而不是追求估算结果客观上的正确性</li>
<li>项目计划主要包括规模、资源估算、日程计划、质量计划、风险计划等，目的分别是保证项目的进度、质量、在风险发生前识别问题等</li>
<li>典型计划流程回顾：估算规模、估算资源、规划日程<img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501989.png" alt="image-20240101230943204"></li>
</ol>
<h3 id="【2014】应对风险的典型策略有哪些？请举例说明"><a href="#【2014】应对风险的典型策略有哪些？请举例说明" class="headerlink" title="【2014】应对风险的典型策略有哪些？请举例说明"></a>【2014】应对风险的典型策略有哪些？请举例说明</h3><p>识别风险之后，就应当制定相应的风险管理策略，以应对各类风险</p>
<p>典型策略：</p>
<ol>
<li>风险转嫁：通过某种安排，在放弃部分利益的同时，将部分的项目风险转嫁到其他的团队或者组织。比如有的公司采取外包的方式，把一部分有技术风险的产品组建交由其他公司开发。</li>
<li>风险解决：指采用一些有效措施，使得风险的来源不再存在。比如针对项目面临的技术风险，采取技术调研或者引进技术专家的手段。</li>
<li>风险缓解：指容忍风险的存在，采取一些措施监控风险，不让风险对项目最终目标的实现造成负面影响。一般情况下，都需要指定相应的风险缓解计划。当风险超过设定的阈值时，实施该计划，以使受冲击的部分回归到可接受的风险等级。</li>
</ol>
<h1 id="5-质量管理-1"><a href="#5-质量管理-1" class="headerlink" title="5.质量管理"></a>5.质量管理</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>质量实践和质量管理是不一样的</p>
<ol>
<li>质量实践包括测试等等</li>
<li>质量管理是对质量的管理，而不是实践，管理必须有上面所说的三个要素（有目标、状态跟踪、纠偏措施）</li>
</ol>
<h2 id="选择-4"><a href="#选择-4" class="headerlink" title="选择"></a>选择</h2><p><strong>关于质量路径（Quality Journey），下列说法中哪些不恰当。</strong></p>
<p>A.质量路径与个体软件工程师无关，是团队层面的集体努力。</p>
<p>B.高质量软件产品最终还是需要依赖测试来确保。</p>
<p>C.进入测试之前的高质量，是获得测试之后高质量软件系统的前提条件。</p>
<p>D.质量路径中所列举的方法都是提升开发质量的有效手段，可以随意选择使用。</p>
<p>正确答案：A、D</p>
<p><strong>关于面向用户的质量观，我们应该关注如下哪些问题？</strong></p>
<p>A.用户期望是否有优先级？</p>
<p>B.用户期望的优先级对软件开发的影响？</p>
<p>C.界面和可操作性是首要的，因为这是用户能直接感受到的。</p>
<p>D.真实用户是谁？</p>
<p>正确答案：A、B、D</p>
<p><strong>PSP当中为什么用缺陷管理替代质量管理？下述说法中正确的是：</strong></p>
<p>A.因为缺陷管理相关的活动（例如，测试等）本来就是软件开发中必须要开展的活动。</p>
<p>B.因为缺陷往往对应了面向用户质量观中的首要用户期望。</p>
<p>C.因为单纯质量管理很难操作。</p>
<p>D.因为缺陷管理和质量管理其实是一回事。</p>
<p>正确答案：B、C</p>
<p><strong>关于评审检查表，下述说法中不恰当的是：</strong></p>
<p>A.评审检查表应该保持稳定，确保缺陷不会被遗漏</p>
<p>B.评审检查表应该定期更新</p>
<p>C.项目团队所有人应该共用一份评审检查表，体现统一性</p>
<p>D.评审检查表应该是个性化的</p>
<p>正确答案：A、C</p>
<p><strong>关于评审，下述说法中不恰当是</strong>：</p>
<p>A.代码的个人评审应该安排在单元测试之后，确保评审对象有着较高的质量，提升评审价值。</p>
<p>B.如果安排了代码的小组评审，那么代码个人评审就可以不用做。</p>
<p>C.代码的个人评审也应该通过评审检查表来进行。</p>
<p>D.代码的个人评审最好交叉进行，因为阅读自己代码容易产生思维定式，不利于缺陷发现。</p>
<p>正确答案：A、D</p>
<p><strong>关于质量的各种定义当中，下述哪些质量属性属于内部属性？</strong></p>
<p>A.可靠性</p>
<p>B.安全性</p>
<p>C.可移植性</p>
<p>D.可扩展性</p>
<p>正确答案：C、D</p>
<p><strong>下述各个度量项中，哪一个不是PSP的基本度量项？</strong></p>
<p>A.规模</p>
<p>B.缺陷</p>
<p>C.时间</p>
<p>D.风险</p>
<p>正确答案：D</p>
<p><strong>关于PQI，下述说法中不恰当的是：</strong></p>
<p>A.PQI五个分指标都可以超过1.0，比如，设计时间多于编码时间的时候，该分指标就超过1.0了</p>
<p>B.PQI越高越好，最好达到1.0</p>
<p>C.PQI可以为过程改进提供依据</p>
<p>D.PQI可以用来辅助判断模块开发的质量</p>
<p>正确答案：A、B</p>
<h2 id="简答-4"><a href="#简答-4" class="headerlink" title="简答"></a>简答</h2><h3 id="【2020】请用真值表检验从CheckPW状态出发的状态组合，并给出该状态机是否正确的明确结论和理由。（本题满分-10-分）"><a href="#【2020】请用真值表检验从CheckPW状态出发的状态组合，并给出该状态机是否正确的明确结论和理由。（本题满分-10-分）" class="headerlink" title="【2020】请用真值表检验从CheckPW状态出发的状态组合，并给出该状态机是否正确的明确结论和理由。（本题满分 10 分）"></a>【2020】<strong>请用真值表检验从CheckPW状态出发的状态组合，并给出该状态机是否正确的明确结论和理由。（本题满分 10 分）</strong></h3><p>（注意这里在转换条件的基础上多写了-&gt;CheckID 后面才接&#x2F;后面的内容）</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501010.png" alt="image-20240103191336183" style="zoom:33%;" /><img src="往年真题除ppt内容.assets/image-20240103191351250.png" alt="image-20240103191351250" style="zoom:33%;" /></p>
<p>符合完整性：所有条件组合都包含在内，每一列都有东西。(不存在有一种排列组合ABC都没有变化)</p>
<p>违反正交性：同样条件组合的下一个状态需要唯一。（这里同一条件同时跳到BC状态是错误的）</p>
<h3 id="【2014】如何对某个软件产品组件进行产品质量评价？可以选择哪些度量元，这些度量元如何辅助判断产品组件的质量？"><a href="#【2014】如何对某个软件产品组件进行产品质量评价？可以选择哪些度量元，这些度量元如何辅助判断产品组件的质量？" class="headerlink" title="【2014】如何对某个软件产品组件进行产品质量评价？可以选择哪些度量元，这些度量元如何辅助判断产品组件的质量？"></a>【2014】如何对某个软件产品组件进行产品质量评价？可以选择哪些度量元，这些度量元如何辅助判断产品组件的质量？</h3><p>基本度量项：</p>
<ol>
<li>度量时间：序号、所属阶段、开始时间、结束时间、中断时间、净时间、中断原因</li>
<li>度量缺陷：序号、发现日期、注入阶段、消除阶段、消除时间、关联缺陷、缺陷产生原因</li>
<li>度量规模：使用 PROBE 方法</li>
<li>日程（TSP）</li>
</ol>
<p>质量控制的衍生指标：</p>
<p>Yield 指标用以度量每个阶段在消除缺陷方面的效率</p>
<p>A&#x2F;FR：质检失效比，用来衡量成功鉴定与失败鉴定的比率。</p>
<p>PQI：过程质量指标，用于提高最终产品的质量水平。</p>
<p>Review Rate：评审的速度，用于衡量软件工程师花在审查上的时间。</p>
<p>DRL（缺陷消除效率比）：衡量缺陷去除活动的有效性。</p>
<h3 id="【2015A】请结合-A-FR、PQI、Review-Rate、DRL、Yield-尽可能具体描述一个软件项目应该如何从多方面来确保开发的高质量？"><a href="#【2015A】请结合-A-FR、PQI、Review-Rate、DRL、Yield-尽可能具体描述一个软件项目应该如何从多方面来确保开发的高质量？" class="headerlink" title="【2015A】请结合 A&#x2F;FR、PQI、Review Rate、DRL、Yield 尽可能具体描述一个软件项目应该如何从多方面来确保开发的高质量？"></a>【2015A】请结合 A&#x2F;FR、PQI、Review Rate、DRL、Yield 尽可能具体描述一个软件项目应该如何从多方面来确保开发的高质量？</h3><p>这些指标既是开发过程中质量管理的一些参考指标，同时也体现在计划安排中应该注意的质量元素。具体如下：</p>
<ol>
<li>在项目计划过程中应该安排确保<strong>高质量开发结果</strong>的活动，例如，按照 A&#x2F;FR、PQI 等指标的要求，安排对各类产物（文档和代码）的个人评审和小组评审；</li>
<li>这些<strong>评审活动</strong>应该满足一定的要求，特别体现在时间方面。例如，评审时间应该多于测试时间的两倍以上（A&#x2F;FR）；评审时间应该是相应开放时间的 50%以上（PQI）；评审速度要求（Review Rate）等</li>
<li>充分借鉴质量指标所体现的开发质量状况，尽早制订相应的质量补救措施。例如，PQI 所体现的缺陷密度、所有上述指标的参考值等等。一旦超标，往往意味着质量方面有偏差，应当及时补救。</li>
<li>利用 yield 等指标，构建<strong>质量预测模型</strong>，更加积极地判定和控制开发质量；</li>
<li>依据 PQI 和 Yield 指标所体现的信息，通过过程改进来提升开发质量。</li>
</ol>
<h3 id="【2014】解释过程度量项定义时应当注意的方面，并且据此评价-PSP-基本度量元的合理之处？"><a href="#【2014】解释过程度量项定义时应当注意的方面，并且据此评价-PSP-基本度量元的合理之处？" class="headerlink" title="【2014】解释过程度量项定义时应当注意的方面，并且据此评价 PSP 基本度量元的合理之处？"></a>【2014】解释过程度量项定义时应当注意的方面，并且据此评价 PSP 基本度量元的合理之处？</h3><p>注意的方面：范围、定义、目标值、收集方法、报告方法和持续改进措施。</p>
<p>PSP 基本指标在时间、缺陷、规模、日程方面是合理的，并且是可操作的、可量化的和可测量的，以提供准确的评估。</p>
<h3 id="【2013】【2018Fall】解释-PQI-指标，如何计算，如何使用"><a href="#【2013】【2018Fall】解释-PQI-指标，如何计算，如何使用" class="headerlink" title="【2013】【2018Fall】解释 PQI 指标，如何计算，如何使用"></a>【2013】【2018Fall】解释 PQI 指标，如何计算，如何使用</h3><p>PQI 是用于衡量软件过程整体质量的指标。它由五个指标组成：设计、设计审查、代码审查、代码质量和程序质量。计算为 0.0 到 1.0 之间的值。当PQI值<strong>大于0.4</strong>时，组件的质量趋向于较高，当较低时，检查数据发现特定方面较低以进行改进。</p>
<p>用途：判断模块开发的质量，规划质量活动，过程改进。</p>
<h3 id="【2014】请区分质量管理和缺陷管理之间的联系和差异，并解释为何在软件开发中将质量和生产效率两者进行妥协不合适？"><a href="#【2014】请区分质量管理和缺陷管理之间的联系和差异，并解释为何在软件开发中将质量和生产效率两者进行妥协不合适？" class="headerlink" title="【2014】请区分质量管理和缺陷管理之间的联系和差异，并解释为何在软件开发中将质量和生产效率两者进行妥协不合适？"></a>【2014】请区分质量管理和缺陷管理之间的联系和差异，并解释为何在软件开发中将质量和生产效率两者进行妥协不合适？</h3><p>联系：确保产品或服务的质量。都是管理，有定义、状态跟踪和纠偏这三个要素。</p>
<p>差异：PSP 中采用了面向用户的质量观，定义质量为<strong>满足用户需求的程度</strong>。而客户的首要需求是不出错，所以质量管理：<strong>防止缺陷的发生。</strong></p>
<p>而缺陷管理：识别并纠正已发生的任何缺陷。所以可以替换质量管理（因为质量管理的可靠稳定、快、质量稳定不好定义三要素）。</p>
<p>在软件开发中，将质量和生产效率进行妥协可能导致一系列问题，这是因为质量和生产效率通常是相互关联的，而不是完全独立的。以下是一些原因说明为何在软件开发中不应该轻易妥协质量以换取生产效率：</p>
<ol>
<li><strong>维护性和可维护性：</strong> 低质量的代码通常更难以维护。虽然可能通过快速开发来提高生产效率，但如果代码质量低下，将来的维护成本可能会急剧增加。高质量的代码更容易理解、调试和修改。</li>
<li><strong>Bug 密度和软件稳定性：</strong> 生产效率的提高通常是通过更快速的迭代和交付实现的。然而，如果牺牲了质量，可能导致更高的 bug 密度。这可能会影响软件的稳定性，增加用户面临的问题。</li>
<li><strong>用户满意度：</strong> 质量问题直接关系到最终用户的体验。低质量的软件可能导致用户的不满，降低产品或服务的可接受性。用户满意度对于软件的长期成功至关重要。</li>
<li><strong>技术债务：</strong> 对质量的妥协可能导致积累的技术债务。技术债务是一种类似于财务债务的概念，表示为了提高开发速度而采取的一些捷径。这些债务可能需要未来花费更多的时间和资源来偿还。</li>
<li><strong>代码可读性和团队协作：</strong> 高质量的代码通常更具可读性，这对于团队协作至关重要。如果代码难以理解，团队成员之间的沟通效率将降低，可能导致更多的错误和问题。</li>
<li><strong>品牌声誉：</strong> 质量问题可能对品牌声誉产生负面影响。软件产品的品质直接影响用户对品牌的信任度。在竞争激烈的市场中，品牌声誉是一项重要的资产。</li>
</ol>
<h3 id="【2018Fall】什么是面向用户的质量观？这对质量管理的策略有什么影响？"><a href="#【2018Fall】什么是面向用户的质量观？这对质量管理的策略有什么影响？" class="headerlink" title="【2018Fall】什么是面向用户的质量观？这对质量管理的策略有什么影响？"></a>【2018Fall】什么是面向用户的质量观？这对质量管理的策略有什么影响？</h3><p>PSP 中采用了面向用户的质量观，定义质量为<strong>满足用户需求的程度</strong>。在这个定义中，就需要进一步明确：</p>
<ol>
<li>用户究竟是谁？</li>
<li>用户需求的优先级是什么？</li>
<li>这种用户的优先级对软件产品的开发过程产生什么样的影响？</li>
<li>怎样来度量这种质量观下的质量水平？</li>
</ol>
<p>典型用户质量期望：</p>
<ol>
<li>这款软件产品必须能够工作：因此可以使用缺陷管理代替质量管理</li>
<li>这款软件产品最好有较快的执行速度</li>
<li>这款软件产品最好在安全性、保密性、可用性、可靠性、兼容性、可维护性、可移植性等方面表现优异。</li>
</ol>
<p>对质量管理策略的影响：需要开发者在开发过程中考虑用户的优先级，衡量质量的高低。使用缺陷管理。</p>
<p>质量策略：</p>
<ol>
<li><strong>使用缺陷管理来代替质量管理</strong></li>
<li>高质量的产品也就意味着组成软件产品的各个组件基本无缺陷</li>
<li>各个组件的高质量是通过高质量评审来实现的；</li>
</ol>
<blockquote>
<p>质量策略为什么有效？提高生产效率，通过关注每个组件的质量，往往可以避免在集成测试和系统测试消除大量缺陷，减少消除代价，提升生产效率</p>
</blockquote>
<h3 id="【2014】为了追求极高的软件产品的质量目标，可能有的方法和这些方法的先后顺序分别是什么？"><a href="#【2014】为了追求极高的软件产品的质量目标，可能有的方法和这些方法的先后顺序分别是什么？" class="headerlink" title="【2014】为了追求极高的软件产品的质量目标，可能有的方法和这些方法的先后顺序分别是什么？"></a>【2014】为了追求极高的软件产品的质量目标，可能有的方法和这些方法的先后顺序分别是什么？</h3><p>考点是质量路径！！！</p>
<ol>
<li>第一步：各种测试</li>
<li>第二步：进入测试之前的产物质量提升</li>
<li>第三步：评审过程度量和稳定</li>
<li>第四步：质量意识和主人翁态度</li>
<li>第五步：个体 review 的度量和稳定</li>
<li>第六步：<strong>诉诸设计</strong></li>
<li>第七步：<strong>缺陷预防</strong></li>
<li>第八步：用户质量观 —— 其他质量属性</li>
</ol>
<h3 id="PSP质量策略是什么，如何在实际项目中应用？"><a href="#PSP质量策略是什么，如何在实际项目中应用？" class="headerlink" title="PSP质量策略是什么，如何在实际项目中应用？"></a>PSP质量策略是什么，如何在实际项目中应用？</h3><p>质量策略：</p>
<ol>
<li><strong>使用缺陷管理来代替质量管理</strong></li>
<li>高质量的产品也就意味着组成软件产品的各个组件基本无缺陷</li>
<li>各个组件的高质量是通过高质量评审来实现的；</li>
</ol>
<p>应用：</p>
<ol>
<li><p>进行评审与测试：使用评审检查表，个人评审，小组评审等。</p>
</li>
<li><p>PSP质量控制的衍生指标：Yield、A&#x2F;FR、PQI、Review Rate、DRL来消除缺陷、度量产品质量等。</p>
</li>
</ol>
<h3 id="PSP基本度量项有哪些？"><a href="#PSP基本度量项有哪些？" class="headerlink" title="PSP基本度量项有哪些？"></a>PSP基本度量项有哪些？</h3><ol>
<li>度量时间：序号、所属阶段、开始时间、结束时间、中断时间、净时间、中断原因</li>
<li>度量缺陷：序号、发现日期、注入阶段、消除阶段、消除时间、关联缺陷、缺陷产生原因</li>
<li>度量规模：使用 PROBE 方法<ol>
<li>选择的规模度量方式必须反映开发成本</li>
<li>度量规模必须被精确定义</li>
<li>度量规模必须有自动化方法统计</li>
<li>有助于早期规划</li>
</ol>
</li>
<li>日程（TSP）</li>
</ol>
<h3 id="【2013】【2015A】如果对质量的追求是无止境的，在不考虑资源和成本的前提下，有哪些可能有效的策略？"><a href="#【2013】【2015A】如果对质量的追求是无止境的，在不考虑资源和成本的前提下，有哪些可能有效的策略？" class="headerlink" title="【2013】【2015A】如果对质量的追求是无止境的，在不考虑资源和成本的前提下，有哪些可能有效的策略？"></a>【2013】【2015A】如果对质量的追求是无止境的，在不考虑资源和成本的前提下，有哪些可能有效的策略？</h3><ol>
<li>重视测试，并且将测试过程文档化并且稳定化;（设计+评审+测试）</li>
<li>重视小组评审，同样定义评审过程，并且使得评审过程的 performance 稳定化</li>
<li>重视个人评审，提升评审者技能;</li>
<li>重视设计</li>
<li>开展设计验证</li>
<li>质量策略：<ol>
<li><strong>使用缺陷管理来代替质量管理</strong></li>
<li>高质量的产品也就意味着组成软件产品的各个组件基本无缺陷</li>
<li>各个组件的高质量是通过高质量评审来实现的；</li>
<li>首先确保基本没有缺陷，然后再考察其他的质量目标。</li>
</ol>
</li>
</ol>
<h3 id="【2014】评审质量指标"><a href="#【2014】评审质量指标" class="headerlink" title="【2014】评审质量指标"></a>【2014】评审质量指标</h3><ul>
<li>Yield<ul>
<li><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501041.png" alt="image-20240101195653846"></li>
</ul>
</li>
<li>A&#x2F;FR<ul>
<li>PSP质检成本&#x2F;PSP失效成本，越高越好，但值太大的话评审过多，所以期望是2</li>
</ul>
</li>
<li>PQI<ul>
<li>5个数据乘积：设计质量 * 设计评审质量 * 代码评审质量 * 代码质量 * 程序质量</li>
</ul>
</li>
<li>评审速度<ul>
<li>代码评审速度小于200 LOC&#x2F;小时，文档评审速度小于4 Page&#x2F;小时</li>
</ul>
</li>
<li>DRL<ul>
<li>以某个测试阶段（一般为单元测试）每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是DRL</li>
</ul>
</li>
</ul>
<h3 id="【2014】请解释设计的层次的概念和意义，并解释如何将-PSP4-个设计模版应用在不同的设计层次之中？"><a href="#【2014】请解释设计的层次的概念和意义，并解释如何将-PSP4-个设计模版应用在不同的设计层次之中？" class="headerlink" title="【2014】请解释设计的层次的概念和意义，并解释如何将 PSP4 个设计模版应用在不同的设计层次之中？"></a>【2014】请解释设计的层次的概念和意义，并解释如何将 PSP4 个设计模版应用在不同的设计层次之中？</h3><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501058.png" alt="image-20240103205502430" style="zoom:50%;" />

<p>功能规格模板和操作规格模板用于规格说明，状态规格模板和逻辑规格模板用于高层设计&#x2F;详细设计。</p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501468.png" alt="image-20240103205759848"></p>
<p><img src="https://lapsey-pictures.oss-cn-shenzhen.aliyuncs.com/typora_imgs/202502041501893.png" alt="image-20240103205806732"></p>
<h3 id="PSP设计模板的用途与UML的关系"><a href="#PSP设计模板的用途与UML的关系" class="headerlink" title="PSP设计模板的用途与UML的关系"></a>PSP设计模板的用途与UML的关系</h3><table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>与UML比较</th>
</tr>
</thead>
<tbody><tr>
<td>操作规格模板（Operational Specification Template）</td>
<td>描述系统与外界的交互；  用于场景描述；  定义测试场景和测试用例；  用来与用户讨论需求</td>
<td>用例图、时序图</td>
</tr>
<tr>
<td>功能规格模板（Functional Specification Template）</td>
<td>描述系统对外接口；  包括类和继承关系、外部可见的属性和方法；  用形式化符号消除二义性</td>
<td>无对应图UML有类图方法的型构，但行为没有描述</td>
</tr>
<tr>
<td>状态规格模板（State Specification Template）</td>
<td>定义程序状态、状态之间转换以及状态转换动作</td>
<td>UML状态图</td>
</tr>
<tr>
<td>逻辑规格模板（Logical Specification Template）</td>
<td>描述系统内部静态逻辑；  用为代码配合形式化符号描述设计结果；  包括关键方法静态逻辑、方法调用、外部引用、关键数据的类型和定义</td>
<td>无对应图</td>
</tr>
</tbody></table>
<p>UML时序图和类图所描述的类之间的关系以及对象之间的交互信息在PSP模板中没有  </p>
<h1 id="6-团队工程开发-1"><a href="#6-团队工程开发-1" class="headerlink" title="6.团队工程开发"></a>6.团队工程开发</h1><h2 id="简答-5"><a href="#简答-5" class="headerlink" title="简答"></a>简答</h2><h3 id="【2020】解释客户需求与产品需求，并解释V-V的区别与联系。"><a href="#【2020】解释客户需求与产品需求，并解释V-V的区别与联系。" class="headerlink" title="【2020】解释客户需求与产品需求，并解释V&amp;V的区别与联系。"></a>【2020】<strong>解释客户需求与产品需求，并解释V&amp;V的区别与联系。</strong></h3><ul>
<li>客户需求是客户的期望，期望解决某个实际问题</li>
<li>产品需求是开发团队提供的解决方案</li>
<li>验证（Verification）检验产品或产品组件能不能满足预先定义的需求规格</li>
<li>确认validation 确保产品可以满足客户需求以及实际操作场景下的要求<br>联系：</li>
<li>验证的依据来源于确认的目标，即产品组件需求必须和客户需求一致。</li>
<li>验证活动为确认活动提供前提条件，在完成产品需求和产品组件需求之前，考虑客户需求是否满足是没有意义的。</li>
</ul>
<h3 id="【2014】请解释需求开发中客户需求和产品需求的差别，并设计一个流程来完成需求开发工作？6’"><a href="#【2014】请解释需求开发中客户需求和产品需求的差别，并设计一个流程来完成需求开发工作？6’" class="headerlink" title="【2014】请解释需求开发中客户需求和产品需求的差别，并设计一个流程来完成需求开发工作？6’"></a>【2014】请解释需求开发中客户需求和产品需求的差别，并设计一个流程来完成需求开发工作？6’</h3><p>客户需求描述的是客户的期望。往往表现为，客户在实际工作中碰到了一些具体问题，希望通过某个东西来帮忙解决这些问题。客户的这种解决问题的愿望，往往就表述为客户需求。比如，客户希望有一种快速进行数据计算的工具帮助他&#x2F;她完成繁琐的计算工作。这就是一个客户需求。</p>
<p>客户需求可能很简单，也可能很复杂；可能很清晰，也可能很模糊。这就需要开发团队与客户一起进行交流、协商，从而弄清客户的真正意图。</p>
<p><strong>产品需求</strong>描述的是开发团队所提供的解决方案。即针对上述的客户需求，开发团队设计出一个可以帮助客户解决工作当中碰到的问题的方案。</p>
<p>一个流程：</p>
<p>需求获取、需求汇总、需求验证、需求文档制作</p>
<h3 id="【2013】【2015A】产品组件集成策略有哪些？请解释这些策略的优缺点。在此基础上，解释如果要实现高质量集成，可能需要注意哪些方面。"><a href="#【2013】【2015A】产品组件集成策略有哪些？请解释这些策略的优缺点。在此基础上，解释如果要实现高质量集成，可能需要注意哪些方面。" class="headerlink" title="【2013】【2015A】产品组件集成策略有哪些？请解释这些策略的优缺点。在此基础上，解释如果要实现高质量集成，可能需要注意哪些方面。"></a>【2013】【2015A】产品组件集成策略有哪些？请解释这些策略的优缺点。在此基础上，解释如果要实现高质量集成，可能需要注意哪些方面。</h3><p><strong>大爆炸集成策略</strong></p>
<ol>
<li>定义：将所有已经完成的组件放在一起进行一次集成</li>
<li>优点：需要很少的测试用例（相比之下最少）</li>
<li>缺点：<ol>
<li><strong>需要所有有待集成的组件质量非常高</strong>，否则会出现难以定位缺陷位置的问题，从而消耗很多测试时间；</li>
<li>系统越复杂，规模越大，问题越突出</li>
</ol>
</li>
</ol>
<p><strong>逐一添加集成策略</strong></p>
<ol>
<li>与大爆炸集成策略相反，采取一次添加一个组件的方式进行集成</li>
<li>优点：很容易定位缺陷位置，特别是在产品组件质量不高的情况下，每次集成之前都有着坚实的质量基础</li>
<li>缺点<ol>
<li>需要测试用例非常多（相比之下最多）</li>
<li>存在有大量的回归测试，测试时间成本大</li>
</ol>
</li>
</ol>
<p><strong>集簇集成策略</strong></p>
<ol>
<li>定义：是对逐一添加集成策略的<strong>改进</strong>，把有相似功能或者有关联的模块优先进行集成，形成可以工作的组件，然后以组件为单位继续较高层次的集成</li>
<li>优点：可以尽早获得一些可以工作的组件，有利于其它组件测试工作的开展</li>
<li>缺点：过于关注<strong>个别组件</strong>，而缺乏系统的整体观，不能尽早发现系统层面的缺陷</li>
</ol>
<p><strong>扁平化集成策略</strong></p>
<ol>
<li>定义：优先集成高层的部件，然后逐步将各个组件、模块的真正实现加入系统。即尽快构建一个可以工作的扁平化系统</li>
<li>优点：<strong>可以尽早发现系统层面的缺陷</strong></li>
<li>缺点：为了确保完成的系统，需要大量的打“桩”（stub），即提供一些直接提供返回值的伪实现。这种方式往往不能覆盖整个系统应该处理的多种状态</li>
</ol>
<h1 id="7-项目支持活动-1"><a href="#7-项目支持活动-1" class="headerlink" title="7.项目支持活动"></a>7.项目支持活动</h1><h2 id="选择-5"><a href="#选择-5" class="headerlink" title="选择"></a>选择</h2><p>**在TSP的团队组建过程中，确定软件开发策略的是第几次会议？C **</p>
<p>A.第一次</p>
<p>B.第二次</p>
<p>C.第三次</p>
<p>D.第四次</p>
<h2 id="简答-6"><a href="#简答-6" class="headerlink" title="简答"></a>简答</h2><h3 id="为什么精确的度量方式往往不便于早期规划，而有助于早期规划的度量往往难以产生精确度量结果？"><a href="#为什么精确的度量方式往往不便于早期规划，而有助于早期规划的度量往往难以产生精确度量结果？" class="headerlink" title="为什么精确的度量方式往往不便于早期规划，而有助于早期规划的度量往往难以产生精确度量结果？"></a>为什么精确的度量方式往往不便于早期规划，而有助于早期规划的度量往往难以产生精确度量结果？</h3><ul>
<li>由于项目的不确定性，很多细节都不能够确定。</li>
<li>度量更好地反映项目的当前状态，使规划更容易。然而，由于不同开发阶段的度量方式不同，因此很难产生准确的指标。</li>
</ul>
<h3 id="【2013】请解释配置管理中配置项和产品基线的概念，并设计一个流程对单元测试后已经纳入配置库的代码，修改集成测试中的若干问题后，该如何控制变更"><a href="#【2013】请解释配置管理中配置项和产品基线的概念，并设计一个流程对单元测试后已经纳入配置库的代码，修改集成测试中的若干问题后，该如何控制变更" class="headerlink" title="【2013】请解释配置管理中配置项和产品基线的概念，并设计一个流程对单元测试后已经纳入配置库的代码，修改集成测试中的若干问题后，该如何控制变更"></a>【2013】请解释配置管理中配置项和产品基线的概念，并设计一个流程对单元测试后已经纳入配置库的代码，修改集成测试中的若干问题后，该如何控制变更</h3><ol>
<li>配置项：<ol>
<li>在配置管理当中作为单独实体进行管理和控制的工作产品集合</li>
<li>典型的可能作为配置项纳入配置管理的工作产品包含过程说明文档、项目开发计划文档、需求规格说明书、设计规格说明书、设计图表、产品规格说明书、程序代码、开发环境，如特定版本的编译器等、产品数据文件、产品技术文件、用户支持文档</li>
</ol>
</li>
<li>基线：基线是一个或多个配置项及相关的标识符的代表，是一组经正式审查同意的规格或工作产品集合，是未来开发工作或交付的基础，而且只能经由严格的变更控制程序才能改变。<ol>
<li>发布一个基线包括该基线所有的配置项以及这些配置项的最新变更，因此，可以将基线作为接下来工作的基础。</li>
<li>典型的发布基线时间点为需求分析之后、设计完成之后、单元测试之后以及最终产品发布。</li>
<li>是配置项持续演进的稳定基础</li>
</ol>
</li>
<li>如何控制变更（疑似是超纲内容）<ol>
<li>跟踪变更请求：<ol>
<li>启动变更请求处理程序，将变更情况保存在变更请求数据库中</li>
<li>分析变更建议和所需进行的修改将对工作产品、进度、日程等造成的影响</li>
<li>如果变更请求影响到其他基线，则与相关的干系人一起审查这些变更请求，并取得他们的同意</li>
<li>跟踪变更申请直到结项</li>
</ol>
</li>
<li>控制配置项变更：<ol>
<li>确认这些修订已得授权</li>
<li>更新配置项</li>
<li>将旧基线归档保存，并获取新基线</li>
<li>执行审查，确保该变更没有对基线造成意料外的影响</li>
<li>上当记录配置项的变更内容和变更理由</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>配置管理活动：</p>
<ol>
<li>识别配置项</li>
<li>建立配置管理系统</li>
<li>创建和发布基线</li>
<li>跟踪变更请求</li>
<li>控制配置项变更</li>
<li>建立配置管理记录</li>
<li>配置审计</li>
</ol>
</blockquote>
<h3 id="【2013】请结合-GQM-思想解释-PSP-过程的基本度量元有哪几个？"><a href="#【2013】请结合-GQM-思想解释-PSP-过程的基本度量元有哪几个？" class="headerlink" title="【2013】请结合 GQM 思想解释 PSP 过程的基本度量元有哪几个？"></a>【2013】请结合 GQM 思想解释 PSP 过程的基本度量元有哪几个？</h3><p>GQM 一个完整的GQM过程分为七个阶段:先期调研、制定GQM目标、产生GQM计划、产生测量计划、收集整理数据、数据分析、打包.其中最能体现GQM思想的是制定GQM目标和产生GQM计划两个阶段</p>
<ul>
<li><p>概念层（目标goal）：目标是为某个特定的对象而定义的。这里的对象是指软件产品、软件过程以及相关的资源等。</p>
</li>
<li><p>操作层（问题question）：基于一定的刻画上述目标是否达成或者目标达成的进展情况的模型，使用一系列的问题来定义所研究的对象, 然后得出评价或评估特定目标达成进展情况。所选择的问题应当尽量体现质量相关的话题。</p>
</li>
<li><p>量化层（度量measure）：试图以量化的方式回答上述操作层识别出来的问题。</p>
</li>
</ul>
<p>PSP基本度量项</p>
<ul>
<li><p>度量时间：所属阶段、开始时间、结束时间、中断时间、净时间</p>
</li>
<li><p>度量缺陷：发现日期、注入阶段、消除阶段、消除时间、关联缺陷</p>
</li>
<li><p>度量规模：</p>
<ul>
<li>选择的规模度量方式必须反映开发成本</li>
<li>必须精确定义</li>
<li>必须能有自动化方法统计</li>
<li>有助于早期规划</li>
</ul>
</li>
<li><p>日程（TSP）</p>
</li>
</ul>
<h3 id="【2015B】请描述一下度量和分析活动在一个软件项目当中的作用，以及应该如何正确开展？"><a href="#【2015B】请描述一下度量和分析活动在一个软件项目当中的作用，以及应该如何正确开展？" class="headerlink" title="【2015B】请描述一下度量和分析活动在一个软件项目当中的作用，以及应该如何正确开展？"></a>【2015B】请描述一下度量和分析活动在一个软件项目当中的作用，以及应该如何正确开展？</h3><p>作为项目管理支持类的活动，度量和分析活动可以支持如下的项目管理活动：</p>
<ol>
<li>客观的估计与计划</li>
<li>根据建立的计划和目标，跟踪实际进展</li>
<li>识别与解决过程改进相关议题</li>
<li>提供将度量结果纳入未来其他过程的基础</li>
</ol>
<p>意义：定义了<strong>客观数据的获取和使用方式</strong>， 帮助软件项目管理决策</p>
<p>正确开展：</p>
<ol>
<li>可以描述度量和分析活动<ol>
<li>建立度量目标</li>
<li>指定度量方式</li>
<li>指定数据收集和保存的流程</li>
<li>指定分析流程</li>
<li>收集度量数据</li>
<li>分析度量数据</li>
<li>保存数据和结果</li>
<li>交流度量结果</li>
</ol>
</li>
<li>也可以描述 GQM（见上一题）</li>
</ol>
<h1 id="8-定量管理与仿真建模-1"><a href="#8-定量管理与仿真建模-1" class="headerlink" title="8.定量管理与仿真建模"></a>8.定量管理与仿真建模</h1><h2 id="选择-6"><a href="#选择-6" class="headerlink" title="选择"></a>选择</h2><p><strong>下列描述中可能是子过程性能的是：AB</strong> </p>
<blockquote>
<p>它描述有意义的性能输出，如过程 Yield 和 Phase Yield</p>
</blockquote>
<p>A.需求评审消除缺陷的百分比；</p>
<p>B.单元测试消除的缺陷密度；</p>
<p>C.验收测试后暴露的缺陷数；</p>
<p>D.代码评审速度；</p>
<p><strong>以下各种定量管理技术当中，属于非统计技术的是：A</strong></p>
<p>A.帕累托分析；</p>
<p>B.控制图；</p>
<p>C.假设检验；</p>
<p>D.方差分析法；</p>
<p><strong>以下定量管理技术中，属于统计技术有：AC</strong></p>
<p>A.预测区间分析；</p>
<p>B.饼图；</p>
<p>C.敏感性分析；</p>
<p>D.因果分析；</p>
<p><strong>下列描述中属于定量管理场景的是：AD</strong></p>
<p>A.我们通过控制<strong>关键子过程</strong>的性能来确保项目整体目标的达成；</p>
<p>B.我们分析了导致生产效率不稳定的因素，并采取措施避免再次发生；</p>
<p>C.我们通过每天站立式会议和周例会控制项目进度偏差不超过 20%；</p>
<p>D.我们通过挣值管理方法来确保进度和成本与预期相符；(关心偏差)</p>
<p><strong>如上图，完全基于 Phase Yield 来构建一个缺陷预测模型，下列数据中必不可少的是：B</strong></p>
<p>A.每个注入缺陷阶段缺陷注入速度（个&#x2F;小时）；</p>
<p>B.每个缺陷消除阶段消除的缺陷个数；</p>
<p>C.每个阶段中从上游阶段遗留下来的缺陷比例；</p>
<p>D.每个缺陷消除阶段消除缺陷的比例；</p>
<p>Phase Yield &#x3D; 100 * (某阶段发现的缺陷个数)&#x2F;(某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数)</p>
<p><strong>通过软件过程建模和仿真，有助于完成下列哪些工作：ABD</strong></p>
<p>A.编制项目计划；</p>
<p>B.编制项目质量管理计划；</p>
<p>C.项目经理培训；</p>
<p>D.组织技术革新；</p>
<p><strong>下列步骤当中，不属于建模典型步骤的是：C</strong></p>
<p>A.定义和选择结果变量；</p>
<p>B.对过程进行抽象；</p>
<p>C.规划过程改进计划；</p>
<p>D.选择输入参数；</p>
<p><strong>上图是控制图的示例图，中心线（CL）两侧按照±σ，±2σ和±3σ分成 ABC 三个区域，以下描述中，属于要进一步探索的异常过程症状的是：C</strong></p>
<p>连续 4 个点呈现上升或者下降趋势；</p>
<p>连续 8 个点在中心线两侧，但是没有一个点在 C 区域；</p>
<p>连续 3 个点中有 2 个落在中心线同侧的 B 区以外；</p>
<p>连续 6 个点在中心线同一侧；</p>
<h2 id="简答-7"><a href="#简答-7" class="headerlink" title="简答"></a>简答</h2><h3 id="【2020-mid】请描述-CMMI-模型的-5-个等级的特征，并且解释为何-CMMI-模型不应该是敏捷方法的对立面："><a href="#【2020-mid】请描述-CMMI-模型的-5-个等级的特征，并且解释为何-CMMI-模型不应该是敏捷方法的对立面：" class="headerlink" title="【2020-mid】请描述 CMMI 模型的 5 个等级的特征，并且解释为何 CMMI 模型不应该是敏捷方法的对立面："></a>【2020-mid】请描述 CMMI 模型的 5 个等级的特征，并且解释为何 CMMI 模型不应该是敏捷方法的对立面：</h3><ol>
<li>五个等级的特征<ol>
<li>Initial 原始级别：过程不可预测，控制不善且反应迟钝。（开发相对混乱，依赖个人英雄主义，没有过程概念，救火文化盛行）</li>
<li>Managed 已管理级别：项目过程通常具有反应性特征。(项目小组体现出项目管理的特征，有项目计划和跟踪、需求管理、配置管理等)</li>
<li>Defined 已定义级别：组织内的过程通常具有主动性特征。（公司层面有标准流程和相应的规范，每个项目小组可以基于此定义自己的过程，使得优秀的做法可以在公司共享。）</li>
<li>Quantitatively Managed 定量管理级别：过程经过度量和控制（构建预测模型，已统计过程控制的手段来管理过程）</li>
<li>Optimizing 优化级：专注于过程改进（继续应用统计方法识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题。）</li>
</ol>
</li>
<li>原因解释：CMMI 是过程改进参考模型，敏捷是软件开发方法，两者是完全不同性质的事物</li>
</ol>
<blockquote>
<p>CMMI模型并不是开发模型，是⼀个过程改进的模型，刻画了软件组织从不成熟到成熟的路线图，简单说，CMMI模型不是⼀种具体的开发方法。而大部分所谓的敏捷方法都是开发方法，</p>
<p>因此，两者是完全不同性质的事物，将这两者对立是不合适的。</p>
</blockquote>
<h3 id="【2022Fall】CMMI为什么四级和五级被称为高等级？与普通等级的本质差别是什么？"><a href="#【2022Fall】CMMI为什么四级和五级被称为高等级？与普通等级的本质差别是什么？" class="headerlink" title="【2022Fall】CMMI为什么四级和五级被称为高等级？与普通等级的本质差别是什么？"></a>【2022Fall】CMMI为什么四级和五级被称为高等级？与普通等级的<strong>本质差别</strong>是什么？</h3><p>三级之前已经是标准过程了。</p>
<p>四级：通过一些数据模型做更好的管控，比如对未来结果的预测；</p>
<p>五级：专注于过程改进，继续应用统计方法识别过程偏差，让生产效率、质量水平越来越高。</p>
<p> 本质差别：基于数据构建定量模型，关心偏差，对项目的状态更加有信心，更加明确项目是否能成功、哪些地方要调整。</p>
<h3 id="【2016】CMMI每个等级的提升其过程改进的重点和出发点在哪里"><a href="#【2016】CMMI每个等级的提升其过程改进的重点和出发点在哪里" class="headerlink" title="【2016】CMMI每个等级的提升其过程改进的重点和出发点在哪里"></a>【2016】CMMI每个等级的提升其过程改进的重点和出发点在哪里</h3><ol>
<li><strong>Initial 原始级别：</strong><ul>
<li><strong>重点：</strong> 强调个人英雄主义，项目相对混乱，缺乏组织过程。</li>
<li><strong>出发点：</strong> 着重解决项目上的问题，没有过程概念。</li>
</ul>
</li>
<li><strong>Managed 已管理级别：</strong><ul>
<li><strong>重点：</strong> 强调项目管理，有一定的反应性。</li>
<li><strong>出发点：</strong> 引入项目管理实践，关注需求管理、配置管理等，确保项目按计划执行。</li>
</ul>
</li>
<li><strong>Defined 已定义级别：</strong><ul>
<li><strong>重点：</strong> 强调在组织层面定义过程，具有主动性。</li>
<li><strong>出发点：</strong> 制定标准流程和规范，使得每个项目小组可以基于这些定义构建自己的过程（自主团队），实现过程的标准化。</li>
</ul>
</li>
<li><strong>Quantitatively Managed 定量管理级别：</strong><ul>
<li><strong>重点：</strong> 强调度量和控制过程。</li>
<li><strong>出发点：</strong> 引入度量手段，构建预测模型，通过定量的方法来管理和控制过程，以实现更高的可靠性。</li>
</ul>
</li>
<li><strong>Optimizing 优化级：</strong><ul>
<li><strong>重点：</strong> 强调持续过程改进。</li>
<li><strong>出发点：</strong> 应用统计方法识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题，实现持续优化。</li>
</ul>
</li>
</ol>
<h3 id="【2021Fall、2013】基于-Yield-指标构建缺陷预测模型，并列举该模型的可能改进方案"><a href="#【2021Fall、2013】基于-Yield-指标构建缺陷预测模型，并列举该模型的可能改进方案" class="headerlink" title="【2021Fall、2013】基于 Yield 指标构建缺陷预测模型，并列举该模型的可能改进方案"></a><strong>【2021Fall、2013】基于 Yield 指标构建缺陷预测模型，并列举该模型的可能改进方案</strong></h3><p>Phase Yield &#x3D; 100 * (某阶段发现的缺陷个数) &#x2F; (某阶段注入的缺陷个数 + 进该阶段前遗留的缺陷个数)<br>Process Yield &#x3D; 100 * (第一次编译前发现的缺陷个数) &#x2F; (第一次编译前注入的缺陷个数)</p>
<p>图中阶段分别是需求开发、需求评审、设计、设计评审、编码、测试、测试评审</p>
<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/3.png" style="zoom: 50%;" />

<ol>
<li><p>总体思想：利用回归技术预测软件开发过程中各阶段的 Inject Rate（缺陷注入率）和 Yield（缺陷消除率）</p>
</li>
<li><p>Yield 指标只能用来估算，不可以用来度量。结合 Yield 指标和上图，只需要知道如下指标就可以基于 Yield 指标构建一个基本的缺陷预测模型：<strong>（需要的数据）</strong></p>
<ol start="2">
<li>注入阶段缺陷注入水平（密度或者速度）</li>
<li>消除阶段缺陷消除水平（速度或者能力）</li>
<li>历史数据中的软件规模、文档规模、开发人员规模</li>
</ol>
</li>
<li><p>步骤</p>
<ol>
<li>先假设所有都是关键子过程。经过敏感度分析-多元回归分析后，最后一般剩下三个关键子过程，其他有影响但是影响不大。这样就构建出了过程模型，其实指的就是关键子过程的数学关系<ol>
<li>如z &#x3D; ay1 + by2 + cy3 + d，其中 y1 &#x3D; ex1 + fx2 + g。X为关键子过程性能的<strong>关键影响因素</strong>，一般是根据经验找出来的。</li>
<li>关键子过程有性能描述，比如y是注入的缺陷，它的值是变量不是常量，每一次有波动。</li>
<li>模型为了预测缺陷，需要知道关键子过程的波动范围，一般是均值±一个标准差。</li>
</ol>
</li>
<li>在项目进行过程中不断收集数据，与预测数据进行比较，调整回归参数</li>
<li>项目过程中依据实际数据与预测数据的误差进行风险的预防、识别和控制</li>
</ol>
</li>
<li><p>改进方案</p>
<ol>
<li>结果受限于<strong>历史数据</strong>在简单性、可理解性、稳定性、可度量性、相关性等方法的质量。因此，维护历史数据。</li>
<li><strong>影响因子的选择</strong>上面不仅仅需要有关软件规模的数据，还需要有关开发过程、开发文档、开发人员等方面的数据，并且需要将数据可度量化。</li>
<li><strong>反馈模型</strong>。即在开发过程中随着实际数据的产生，将这些数据作为输入变量放入模型中以调整回归参数。</li>
<li>假设注入水平和消除水平都符合正态分布，计算均值和标准差，因此，可以用蒙特卡罗方法模拟结果。</li>
</ol>
</li>
</ol>
<h3 id="基本范式"><a href="#基本范式" class="headerlink" title="基本范式"></a>基本范式</h3><ol>
<li>构建定量模型<ol>
<li>子过程能力基线</li>
<li>过程模型：关键子过程的数学关系（输入和输出之间的数学关系）</li>
</ol>
</li>
<li>应用模型：监控影响子过程的关键因素</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="2022Fall-选择题"><a href="#2022Fall-选择题" class="headerlink" title="2022Fall-选择题"></a>2022Fall-选择题</h3><table>
<thead>
<tr>
<th>题面</th>
<th>选项</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>以下关于规模估算和度量的描述中，正确的是：</td>
<td>A. 功能点是一种可提供<strong>精确规模度量</strong>结果的方式 B. 规模数据扮演了沟通历史数据的桥梁的角色 C. 规模估算通常不用于质量计划当中 D. PROBE 只用于规模估算</td>
<td>AB</td>
</tr>
<tr>
<td>关于 <strong>PSP 缺陷日志</strong>，哪些信息是至关重要的</td>
<td>A.缺陷发现时间 B.缺陷重现方式 C.缺陷根因描述 D.缺陷关联的其他缺陷</td>
<td>ACD</td>
</tr>
</tbody></table>
<h3 id="更早的选择题"><a href="#更早的选择题" class="headerlink" title="更早的选择题"></a>更早的选择题</h3><table>
<thead>
<tr>
<th>出处</th>
<th>题面</th>
<th>选项</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2015B</td>
<td>下述内容在状态机验证中不用以验证状态机本身是否正确的是</td>
<td>A. 没有隐藏的陷阱和死循环 B. 状态<strong>转换</strong>是否完整 C. 状态描述是否完整 D. 状态转换是否正交</td>
<td>C</td>
</tr>
<tr>
<td>2015B</td>
<td>为了制定 Schedule plan，下述描述中，哪一项是不需要的</td>
<td>A. Task size B. Task Order C. Schedule Hour D. Task hour for each task</td>
<td>A</td>
</tr>
<tr>
<td>2015B</td>
<td>在上题中，还需要补充下述哪一项数据就可以定义 Schedule Plan 了</td>
<td>A. Task List B. Plan Value C. Earned Value D. Nothing</td>
<td>A</td>
</tr>
</tbody></table>
<h2 id="主观题"><a href="#主观题" class="headerlink" title="主观题"></a>主观题</h2><h3 id="更早的参考题目"><a href="#更早的参考题目" class="headerlink" title="更早的参考题目"></a>更早的参考题目</h3><p>【2016】TSP 项目经理、过程经理、计划经理的工作内容、项目总结角度 9’</p>
<p>【2014】马斯洛的“人的需求层次理论”描述的需求层次有哪几个？这样分层对软件开发有什么启发？6’</p>
<p>【2014】为了确保最终软件产品的质量，在项目计划阶段应该注意哪些问题？4 分</p>
<p>【2015B】请解释在质量保障活动中的 V&amp;V 分别是什么含义？两者之间的关系是什么？5 分</p>
<p>【2014】请举例说明验证和确认的区别和联系？ 4 分</p>
<p>【2014】请罗列集成测试的典型策略，并且解释各个集成测试策略的优缺点？8’</p>
<p>【2015B】请给出需求开发的完整过程，并且解释客户需求和产品需求的各自含义以及在需求开发过程中该如何体现客户需求和产品需求？8’</p>
<ol>
<li>基于风险分析平衡敏捷与规范<ol>
<li>敏捷风险 &gt; 计划驱动风险，启用基于风险的计划驱动方法</li>
<li>计划驱动风险 &gt; 敏捷风险，启用基于风险的敏捷方法</li>
<li>不能判断，则通过架构把敏捷部分封装起来，在敏捷部分使用基于风险的敏捷方法，在其他地方启用基于风险的计划驱动方法。</li>
</ol>
</li>
</ol>
<p>【2015B】请解释 A&#x2F;FR，PQI 的计算方式，并且解释这两个指标有什么用途？10’</p>
<h1 id="不在-2023Fall-课程范围内的简答题"><a href="#不在-2023Fall-课程范围内的简答题" class="headerlink" title="不在 2023Fall 课程范围内的简答题"></a>不在 2023Fall 课程范围内的简答题</h1><p>【2015A】请列出 Capture-recapture 方法进行缺陷预测的假设条件和相应的模型定义</p>
<ol>
<li>常见 CRC 模型定义了两个参数，即评审者发现缺陷能力 t 和缺陷的难度 h，t 是否一致以及 h 是否一致都会影响模型。一边来说，定义如下 4 个基本模型：</li>
<li>假设 h 和 t 都一样的 M0 模型</li>
<li>假设 h 不等而 t 都一样的 Mh 模型</li>
<li>假设 t 不等而 h 都一样的 Mt 模型</li>
<li>假设 t 和 h 都不等的 Mth 模型</li>
</ol>
<p>【2018Fall】什么是软件过程的多维视角？这对软件过程的融合和定制有什么启发？</p>
<h3 id="简述以下软件质量管理科学家-工程师的贡献"><a href="#简述以下软件质量管理科学家-工程师的贡献" class="headerlink" title="简述以下软件质量管理科学家&#x2F;工程师的贡献"></a>简述以下软件质量管理科学家&#x2F;工程师的贡献</h3><p>【2013】【2015B】【2016】Deming</p>
<ol>
<li>质量改进：提出质量改进的思想，被称为日本质量管理之父。</li>
<li>PDCA 循环：提出 PDCA 循环，被称为“戴明环”(Plan、 Do、Check、 Action)，为最基本的质量和管理工具</li>
<li>14 条原则：<ol>
<li>树立改进产品和服务的坚定目标，采用新的思维方法</li>
<li>停止依赖检验的办法获得质量</li>
<li>不再凭价格标签进货</li>
<li>坚持不懈地提高产品质量和生产率</li>
<li>岗位培训制度化</li>
<li>管理者的作用应突出强调</li>
<li>排除畏难情绪</li>
<li>打破部门和人员之间的障碍</li>
<li>不再给操作人员提空洞的口号</li>
<li>取消对操作人员规定的工作定额和指标</li>
<li>不再采用按年度对人员工件进行评估</li>
<li>创建积极的自我提高计划制度</li>
<li>让每个员工都投入到提高产品质量的活动中去</li>
</ol>
</li>
</ol>
<p>【2013】【2015B】【2016】Juran</p>
<ol>
<li>主编质量控制手册：《质量控制手册》为当今世界质量控制科学的“圣经”，奠定了“全面质量管理”TQM”的理论基础（Total Quality Management）</li>
<li>提出适用性质量：<ol>
<li>适用性质量：质量是一种适用性，即产品在使用期间能满足使用者的要求。</li>
<li>质量不仅仅要满足明确的需求，还要满足潜在的需求。该思想使得质量管理范围从生产过程中的控制进一步扩大到产品开发和工艺设计阶段，即挖掘用户潜在需求。</li>
</ol>
</li>
<li>提出质量三步曲：就是质量计划-&gt;质量控制-&gt;质量改进</li>
<li>提出 Juran 质量螺旋;</li>
<li>提出 80&#x2F;20 原则，认为有 80%的质量问题是由于领导责任引起的。从而将人力与质量管理结合起来。</li>
</ol>
<p>【2013】【2015B】【2016】Crosby</p>
<ol>
<li>提出零缺陷的概念<ol>
<li>零缺陷：第一次就把事情做对</li>
<li>想要做到这一点，就需要把工作放在预防上而不是质量检验上;</li>
</ol>
</li>
<li>提出质量管理的绝对性：<ol>
<li>质量就是符合要求，而不是“完美”</li>
<li>质量来自于预防，而不是检验</li>
<li>质量的标准是“零缺陷”，而不是可接受质量水平</li>
<li>质量的衡量标准是“不符合要求的代价”</li>
</ol>
</li>
<li>提出质量改进的基本要素（6C-变革 管理的六个阶段） ：<ol>
<li>领悟（Comprehension）：理解质量真谛</li>
<li>承诺（commitment）：制定质量策略的决心</li>
<li>能力（capability）：教育与培训</li>
<li>沟通（communication）：成功的经验文档化、制度化</li>
<li>改正（correction）：预防与提高绩效</li>
<li>坚持（continuance）：强调质量管理成为一种工作方式</li>
</ol>
</li>
<li>发展质量成熟度的度量。</li>
</ol>
<p>【2015B】【2016】Humphrey 软件过程之父</p>
<ol>
<li>采用 Crosby 的成熟度度量，提出了软件能力成熟度模型（CMM) ，对于软件过程管理与改进具有建设性作用。</li>
<li>将上述的理论和实践引入软件过程。</li>
</ol>
<h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>【2016】CI</p>
<p>【2016】CD&#x2F;CD</p>
<p>【2016】Pipeline Orchestration</p>
<p>【2016】Container</p>
<p>【2016】Micro Service</p>
<p>【2016】A&#x2F;B Testing</p>
<p>【2016】GitFlow</p>
<h3 id="描述用途"><a href="#描述用途" class="headerlink" title="描述用途"></a>描述用途</h3><p>【2016】Docker</p>
<p>【2016】Jenkins</p>
<p>【2016】JIRA</p>
<p>【2016】SonarQube</p>
<p>【2016】Git</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>标签:</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E8%AF%BE%E7%A8%8B/"># 课程</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/07/01/2023%E6%98%A5%E5%AD%A3%E3%80%8A%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/">2023春季《软件系统设计》考试重点</a>
            
            
            <a class="next" rel="next" href="/2023/01/14/2022%E7%A7%8B%E5%AD%A3%E3%80%8A%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">2022秋季《需求与商业模式》课程笔记</a>
            
        </section>


    </article>
</div>


    <div id="gitalk-container"></div>
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'blog_comment',
        owner: 'lyxx2535',
        admin: 'lyxx2535',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Annie | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | 2020 - 2025
            <br>
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<span class="site-uv">
    Total visitors:
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>&nbsp;|&nbsp;


<span class="site-pv">
    Total views:
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

          </span>
    </div>
</footer>

    </div>
</body>

</html>